[{"path":"https://r-spatial.github.io/spatialreg/articles/SpatialFiltering.html","id":"introduction-1","dir":"Articles","previous_headings":"","what":"Introduction 1","title":"Moran Eigenvectors","text":"Moran eigenvector approach (Dray, Legendre, Peres-Neto 2006; Griffith Peres-Neto 2006) involved spatial patterns represented maps eigenvectors; choosing suitable orthogonal patterns adding linear generalised linear model, spatial dependence present residuals can moved model. uses brute force search set eigenvectors matrix 𝐌𝐖𝐌\\mathbf{M W M}, $$\\mathbf{M} = \\mathbf{} - \\mathbf{X}(\\mathbf{X}^{\\rm T} \\mathbf{X})^{-1}\\mathbf{X}^{\\rm T}$$ symmetric idempotent projection matrix 𝐖\\mathbf{W} spatial weights. spatial lag form SpatialFiltering GLM form , 𝐗\\mathbf{X} nn-vector ones, intercept . general form, SpatialFiltering chooses subset nn eigenvectors reduce residual spatial autocorrelation error model covariates. lag form adds covariates assessment eigenvectors choose, use constructing eigenvectors. SpatialFiltering implemented contributed Yongwan Chun Michael Tiefelsdorf, presented Tiefelsdorf Griffith (2007); based Matlab code Pedro Peres-Neto discussed Dray, Legendre, Peres-Neto (2006) Griffith Peres-Neto (2006). Since SpatialFiltering approach allow weights used, see residual autocorrelation original linear model absorbed, ‘whitened’ inclusion selected eigenvectors model, covariate coefficients change little. addition eigenvectors – representing independent spatial pattern – relieves residual autocorrelation, otherwise makes changes substantive coefficient values. function also searches eigenvectors spatial lag variant underlying model, GLM framework. criterion permutation bootstrap test Moran’s II regression residuals, case, limited remaining spatial autocorrelation, set α=0.5\\alpha = 0.5. Even generous stopping rule, eigenvectors chosen; combined contribution just improves fit GLM model.  Figure fig:geigen2fig:geigen2 shows spatial patterns chosen match small amount spatial autocorrelation remaining model. Poisson regressions, closeness TCE sites highly significant. Since, however, many TCE sites also close densely populated urban areas possible presence point-source non-point-source pollution, premature take results simply face value. , however, potentially useful contrast cities Binghamton south study area several sites vicinity, Syracuse north without TCE sites data set.","code":"library(spdep) require(\"sf\", quietly=TRUE) if (packageVersion(\"spData\") >= \"2.3.2\") {     NY8 <- sf::st_read(system.file(\"shapes/NY8_utm18.gpkg\", package=\"spData\")) } else {     NY8 <- sf::st_read(system.file(\"shapes/NY8_bna_utm18.gpkg\", package=\"spData\"))     sf::st_crs(NY8) <- \"EPSG:32618\"     NY8$Cases <- NY8$TRACTCAS } ## Reading layer `NY8_utm18' from data source  ##   `/home/rsb/lib/r_libs/spData/shapes/NY8_utm18.gpkg' using driver `GPKG' ## Simple feature collection with 281 features and 17 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 358241.9 ymin: 4649755 xmax: 480393.1 ymax: 4808545 ## Projected CRS: WGS 84 / UTM zone 18N NY_nb <- read.gal(system.file(\"weights/NY_nb.gal\", package=\"spData\"), override.id=TRUE) library(spatialreg) nySFE <- SpatialFiltering(Z~PEXPOSURE+PCTAGE65P+PCTOWNHOME, data=NY8, nb=NY_nb, style=\"W\", verbose=FALSE) nylmSFE <- lm(Z~PEXPOSURE+PCTAGE65P+PCTOWNHOME+fitted(nySFE), data=NY8) summary(nylmSFE) ##  ## Call: ## lm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME + fitted(nySFE),  ##     data = NY8) ##  ## Residuals: ##     Min      1Q  Median      3Q     Max  ## -1.5184 -0.3523 -0.0105  0.3221  3.1964  ##  ## Coefficients: ##                    Estimate Std. Error t value Pr(>|t|)     ## (Intercept)        -0.51728    0.14606  -3.542 0.000469 *** ## PEXPOSURE           0.04884    0.03230   1.512 0.131717     ## PCTAGE65P           3.95089    0.55776   7.083 1.25e-11 *** ## PCTOWNHOME         -0.56004    0.15688  -3.570 0.000423 *** ## fitted(nySFE)vec13 -2.09397    0.60534  -3.459 0.000630 *** ## fitted(nySFE)vec44 -2.24003    0.60534  -3.700 0.000261 *** ## fitted(nySFE)vec6   1.02979    0.60534   1.701 0.090072 .   ## fitted(nySFE)vec38  1.29282    0.60534   2.136 0.033613 *   ## fitted(nySFE)vec20  1.10064    0.60534   1.818 0.070150 .   ## fitted(nySFE)vec14 -1.05105    0.60534  -1.736 0.083662 .   ## fitted(nySFE)vec75  1.90600    0.60534   3.149 0.001826 **  ## fitted(nySFE)vec21 -1.06331    0.60534  -1.757 0.080138 .   ## fitted(nySFE)vec36  1.17861    0.60534   1.947 0.052578 .   ## fitted(nySFE)vec61 -1.08582    0.60534  -1.794 0.073986 .   ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Residual standard error: 0.6053 on 267 degrees of freedom ## Multiple R-squared:  0.3401, Adjusted R-squared:  0.308  ## F-statistic: 10.58 on 13 and 267 DF,  p-value: < 2.2e-16 nylm <- lm(Z~PEXPOSURE+PCTAGE65P+PCTOWNHOME, data=NY8) anova(nylm, nylmSFE) ## Analysis of Variance Table ##  ## Model 1: Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME ## Model 2: Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME + fitted(nySFE) ##   Res.Df     RSS Df Sum of Sq      F    Pr(>F)     ## 1    277 119.619                                   ## 2    267  97.837 10    21.782 5.9444 3.988e-08 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 NYlistwW <- nb2listw(NY_nb, style = \"W\") set.seed(111) nyME <- ME(Cases~PEXPOSURE+PCTAGE65P+PCTOWNHOME, data=NY8, offset=log(POP8), family=\"poisson\", listw=NYlistwW, alpha=0.46) nyME ##   Eigenvector ZI pr(ZI) ## 0          NA NA   0.31 ## 1          24 NA   0.44 ## 2         223 NA   0.42 ## 3         206 NA   0.43 ## 4         169 NA   0.48 NY8$eigen_1 <- fitted(nyME)[,1] NY8$eigen_2 <- fitted(nyME)[,2] #gry <- brewer.pal(9, \"Greys\")[-1] plot(NY8[,c(\"eigen_1\", \"eigen_2\")]) nyglmME <- glm(Cases~PEXPOSURE+PCTAGE65P+PCTOWNHOME+offset(log(POP8))+fitted(nyME), data=NY8, family=\"poisson\") summary(nyglmME) ##  ## Call: ## glm(formula = Cases ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME + offset(log(POP8)) +  ##     fitted(nyME), family = \"poisson\", data = NY8) ##  ## Coefficients: ##                    Estimate Std. Error z value Pr(>|z|)     ## (Intercept)        -8.13431    0.18388 -44.237  < 2e-16 *** ## PEXPOSURE           0.14136    0.03134   4.511 6.45e-06 *** ## PCTAGE65P           4.16875    0.60149   6.931 4.19e-12 *** ## PCTOWNHOME         -0.39290    0.19222  -2.044  0.04096 *   ## fitted(nyME)vec24   1.62658    0.72243   2.252  0.02435 *   ## fitted(nyME)vec223  0.92941    0.70391   1.320  0.18671     ## fitted(nyME)vec206 -0.11559    0.68987  -0.168  0.86693     ## fitted(nyME)vec169 -1.82674    0.68142  -2.681  0.00735 **  ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## (Dispersion parameter for poisson family taken to be 1) ##  ##     Null deviance: 428.25  on 280  degrees of freedom ## Residual deviance: 340.08  on 273  degrees of freedom ## AIC: Inf ##  ## Number of Fisher Scoring iterations: 5 nyGLMp <- glm(Cases~PEXPOSURE+PCTAGE65P+PCTOWNHOME+offset(log(POP8)), data=NY8,family=\"poisson\") anova(nyGLMp, nyglmME, test=\"Chisq\") ## Analysis of Deviance Table ##  ## Model 1: Cases ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME + offset(log(POP8)) ## Model 2: Cases ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME + offset(log(POP8)) +  ##     fitted(nyME) ##   Resid. Df Resid. Dev Df Deviance Pr(>Chi)   ## 1       277     353.35                        ## 2       273     340.08  4   13.269  0.01003 * ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Spatial weights objects as sparse matrices and graphs","text":"Since spdep package created, spatial weights objects constructed lists three components attributes, old-style class listw objects. first component listw object nb object, list n integer vectors, least character vector region.id attribute n unique values (like row.names data.frame object); n number spatial entities. Component list contains integer identifiers neighbours sorted vector duplication values 1:n; neighbours, component vector length 1 value 0L. nb object may contain attribute indicating whether symmetric , whether neighbour j implies j neighbour . neighbour definitions symmetric construction, contiguities distance thresholds, others asymmetric, k-nearest neighbours. nb object redundantly stores -j j-links. second component listw object list n numeric vectors, length corresponding non-zero vectors nbobject. give values spatial weights -j neighbour pair. often case neighbours symmetric construction, weights , example weights row-standardised dividing row input weights count neighbours cardinality neighbour set . nb2listwfunction, also possible pass general weights, inverse distances, shares boundary lengths . third component listw object records style weights character code, \"B\" binary weights taking values zero one (one recorded), \"W\" row-standardised weights, . order subset listw objects, knowledge style may necessary obvious similar way sparse matrices stored, either row - like listw object, column. key insight storing zero values unnecessary, need store row column locations non-zero values. Early , Netlib library used provide limited support spdep sparse matrices, followed functionality SparseM, spam, Matrix. spdep spatialreg versions 1.2, vignette accompanying functionality moved spatialreg.","code":""},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"spatialreg-depends-on-matrix","dir":"Articles","previous_headings":"Introduction","what":"spatialreg depends on Matrix","title":"Spatial weights objects as sparse matrices and graphs","text":"Since Matrix recommended package, functionality increasingly used time, become one two packages spatialreg depends. reported loading:","code":"library(spatialreg) ## Loading required package: spData ## Loading required package: Matrix ## Loading required package: sf ## Linking to GEOS 3.13.0, GDAL 3.10.0, PROJ 9.5.0; sf_use_s2() is TRUE"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"getting-some-data","dir":"Articles","previous_headings":"Introduction","what":"Getting some data","title":"Spatial weights objects as sparse matrices and graphs","text":"legacy Columbus OH data set 49 spatial entities, polygons, defined boundaries policing districts city. spatialreg imports spdep turn depends sf.","code":"dothis <- TRUE if (!suppressPackageStartupMessages(require(sf, quietly=TRUE))) {   message(\"install the sf package\")   dothis <- FALSE } if (dothis) {   sf_extSoftVersion() } ##           GEOS           GDAL         proj.4 GDAL_with_GEOS     USE_PROJ_H  ##       \"3.13.0\"       \"3.10.0\"        \"9.5.0\"         \"true\"         \"true\"  ##           PROJ  ##        \"9.5.0\" library(sf) columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1]) ## Reading layer `columbus' from data source  ##   `/home/rsb/lib/r_libs/spData/shapes/columbus.gpkg' using driver `GPKG' ## Simple feature collection with 49 features and 20 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 5.874907 ymin: 10.78863 xmax: 11.28742 ymax: 14.74245 ## Projected CRS: Undefined Cartesian SRS with unknown unit row.names(columbus)[1:10] ##  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\""},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"finding-contiguous-neighbours-and-droppping-links","dir":"Articles","previous_headings":"Introduction","what":"Finding contiguous neighbours and droppping links","title":"Spatial weights objects as sparse matrices and graphs","text":"Contiguous neighbours often used polygonal spatial entities, poly2nb function defaulting queen criterion - entities neighbours share boundary point. see entity IDs copied across nb object: order make object complicated, let us drop neighbour links 21st entity (noting print method reports ID entity neighbours, number 1:n), plot resulting map neighbours:","code":"nb_q <- spdep::poly2nb(columbus) nb_q ## Neighbour list object: ## Number of regions: 49  ## Number of nonzero links: 236  ## Percentage nonzero weights: 9.829238  ## Average number of links: 4.816327 attr(nb_q, \"region.id\")[1:10] ##  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" spdep::is.symmetric.nb(nb_q) ## [1] TRUE col2 <- spdep::droplinks(nb_q, 21) ## Warning in spdep::droplinks(nb_q, 21): some observations have no neighbours ## Warning in spdep::droplinks(nb_q, 21): neighbour object has 3 sub-graphs nb_q[[21]] ## [1] 24 30 34 col2[[21]] ## [1] 0 col2 ## Neighbour list object: ## Number of regions: 49  ## Number of nonzero links: 230  ## Percentage nonzero weights: 9.579342  ## Average number of links: 4.693878  ## 1 region with no links: ## 21 ## 3 disjoint connected subgraphs spdep::is.symmetric.nb(col2) ## [1] TRUE coords <- st_coordinates(st_centroid(st_geometry(columbus))) plot(nb_q, coords, col=\"grey\") plot(col2, coords, add=TRUE)"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"using-sparse-matrices-to-represent-spatial-weights","dir":"Articles","previous_headings":"","what":"Using sparse matrices to represent spatial weights","title":"Spatial weights objects as sparse matrices and graphs","text":"present listw objects can coerced objects classes defined Matrix. style lost coercion, may possible reconstruct spatial weights sparse matrix representation preserve . start symmetric binary weights, first creating spatial weights object, signalling one entity neighbours zero.policy argument (default false). matrix graph representations -neighbour entities obvious.","code":"nb_B <- spdep::nb2listw(col2, style=\"B\", zero.policy=TRUE) nb_B$style ## [1] \"B\""},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"symmetric-sparse-matrices","dir":"Articles","previous_headings":"Using sparse matrices to represent spatial weights","what":"Symmetric sparse matrices","title":"Spatial weights objects as sparse matrices and graphs","text":"spdep provides coercion methods listw \"symmetricMatrix\", \"RsparseMatrix\" \"CsparseMatrix\" classes defined Matrix. \"RsparseMatrix\" representation similar listw, row-based, used less frequently operations sparse matrices. entity IDs passed using sparse matrix row column names present. believe listw object can represented symmetric matrix, storing triangle rather -j j-weights. coercion method check whether symmetry present proceeding: Let us now try retreive list neighbours symmetric sparse matrix. present, coerce one Matrix internal representation another order get \"dgCMatrix\" format used inside mat2listw, coerce \"dgTMatrix\" \"dsTMatrix\". style retreived automatically, set \"M\" indicate conversion matrix. neighbour links retreived correctly, IDs:","code":"library(spatialreg) library(Matrix) B <- as(nb_B, \"CsparseMatrix\") all(B == t(B)) ## [1] TRUE str(B) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:230] 1 2 0 2 3 0 1 3 4 1 ... ##   ..@ p       : int [1:50] 0 2 5 9 13 21 23 27 33 41 ... ##   ..@ Dim     : int [1:2] 49 49 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:49] \"1\" \"2\" \"3\" \"4\" ... ##   .. ..$ : chr [1:49] \"1\" \"2\" \"3\" \"4\" ... ##   ..@ x       : num [1:230] 1 1 1 1 1 1 1 1 1 1 ... ##   ..@ factors : list() rownames(B)[1:10] ##  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" nb_B1 <- spdep::mat2listw(as(as(B, \"TsparseMatrix\"), \"CsparseMatrix\"),     style=\"B\", zero.policy=TRUE) ## Warning in sn2listw(df, style = style, zero.policy = zero.policy, from_mat2listw = TRUE): no-neighbour observations found, set zero.policy to TRUE; ## this warning will soon become an error ## Warning in sn2listw(df, style = style, zero.policy = zero.policy, ## from_mat2listw = TRUE): neighbour object has 3 sub-graphs ## Warning in spdep::mat2listw(as(as(B, \"TsparseMatrix\"), \"CsparseMatrix\"), : ## neighbour object has 3 sub-graphs nb_B1$style ## [1] \"B\" all.equal(nb_B1$neighbours, col2, check.attributes=FALSE) ## [1] TRUE all.equal(attr(nb_B1$neighbours, \"region.id\"), attr(nb_B$neighbours, \"region.id\")) ## [1] TRUE"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"log-determinants-symmetric-weights-used-in-spatial-regression","dir":"Articles","previous_headings":"Using sparse matrices to represent spatial weights","what":"Log determinants (symmetric weights) used in spatial regression","title":"Spatial weights objects as sparse matrices and graphs","text":"initial reason implementing support sparse weights matrices spdep permit calculation log determinant term spatial regressions larger data sets. Using eigenvalue approach example spatialreg::eigenw limited need operate dense matrices memory solve eigenproblem: n large, may become impractical /time-consuming, permit rapid calculation values log determinant differing values spatial coefficient ρ\\rho. Matrix package provides many determinant methods, \"dsCMatrix\" resulting subtracting \"dsCMatrix\", product scalar \"dsTMatrix\", \"ddiMatrix\". value log determinant follows, calling sparse Cholesky decomposition internally suitable input matrices. computation sparse Cholesky decomposition value spatial coefficient ρ\\rho may avoided updating pre-computed object; approach provides fast accurate log determinants larger (large) data sets:","code":"rho <- 0.1 do_spatialreg <- FALSE if (requireNamespace(\"spatialreg\", quietly=TRUE)) do_spatialreg <- TRUE if (do_spatialreg) sum(log(1 - rho * spatialreg::eigenw(nb_B))) ## [1] -1.44787 n <- nrow(B) I <- Diagonal(n) class(I - rho * B) ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" c(determinant(I - rho * B, logarithm=TRUE)$modulus) ## [1] -1.44787 nW <- -B nChol <- Cholesky(nW, Imult=8) n * log(rho) + (2 * c(determinant(update(nChol, nW, 1/rho), sqrt=TRUE)$modulus)) ## [1] 15.40218"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"asymmetric-sparse-matrices","dir":"Articles","previous_headings":"Using sparse matrices to represent spatial weights","what":"Asymmetric sparse matrices","title":"Spatial weights objects as sparse matrices and graphs","text":"use row-standardisation leads asymmetry even underlying neighbours symmetric, unless entities matching numbers neighbours (example regular grid torus): lag method listw objects often used create spatially lagged values, returns values vector given product sparse general matrix input numeric vector. Note setting zero.policy TRUE, spatial lag entity 21, neighbours, zero construction:","code":"nb_W <- spdep::nb2listw(col2, style=\"W\", zero.policy=TRUE) W <- as(nb_W, \"CsparseMatrix\") str(W) ## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots ##   ..@ i       : int [1:230] 1 2 0 2 3 0 1 3 4 1 ... ##   ..@ p       : int [1:50] 0 2 5 9 13 21 23 27 33 41 ... ##   ..@ Dim     : int [1:2] 49 49 ##   ..@ Dimnames:List of 2 ##   .. ..$ : chr [1:49] \"1\" \"2\" \"3\" \"4\" ... ##   .. ..$ : chr [1:49] \"1\" \"2\" \"3\" \"4\" ... ##   ..@ x       : num [1:230] 0.333 0.25 0.5 0.25 0.25 ... ##   ..@ factors : list() all(W == t(W)) ## [1] FALSE set.seed(1) x <- runif(n) r1 <- as.numeric(W %*% x) r2 <- lag(nb_W, x, zero.policy=TRUE) all.equal(r1, r2, check.attributes=FALSE) ## [1] TRUE plot(x, r1, ylim=c(0,1)) c(x[21], r1[21]) ## [1] 0.9347052 0.0000000"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"log-determinants-asymmetric-weights-used-in-spatial-regression","dir":"Articles","previous_headings":"Using sparse matrices to represent spatial weights","what":"Log determinants (asymmetric weights) used in spatial regression","title":"Spatial weights objects as sparse matrices and graphs","text":"Calculating log determinant asymmetric weights (symmetric neighbours symmetry induced non-constant numbers neighbours) may carried using eigenvalues , result may complex vector (, discussed ). appropriate determinant method \"dgCMatrix\" objects uses LU decomposition internally: can show internal workings method :","code":"rho <- 0.5 sum(log(1 - rho * eigenw(nb_W))) ## [1] -1.594376 class(I - rho * W) ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" c(determinant(I - rho * W, logarithm=TRUE)$modulus) ## [1] -1.594376 LU <- lu(I - rho * W) sum(log(abs(diag(slot(LU, \"U\"))))) ## [1] -1.594376"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"log-determinants-symmetric-by-similarity","dir":"Articles","previous_headings":"Using sparse matrices to represent spatial weights","what":"Log determinants: symmetric by similarity","title":"Spatial weights objects as sparse matrices and graphs","text":"nb2listw function stores components can employed transform asymmetric weights matrix symmetry similarity, permitting log determinant computed using less costly numerical methods. \"W\" style used cardinalities neighbour sets (row sums) introduce row standardisation, stored attribute: first restore row-standarised matrix binary form (must symmetric), can pre- post-multiply square roots inverted neighbour counts, yielding symmetric matrix appropriate properties: can seen, division square root zero entity 21 problem row dW zero. transformation similarity permits use numerical methods sparse symmetric matrices (equivalently eigenvalues dense matrices). Note transformation available intrinsically asymmetric neighbours, intrinsically asymmetric general weights.","code":"d <- attr(nb_W$weights, \"comp\")$d all.equal(d, spdep::card(col2)) ## [1] TRUE dW <- Diagonal(n, d) %*% W all(dW == t(dW)) ## [1] TRUE isd <- Diagonal(n, 1/sqrt(d)) isd[21,21] ## [1] Inf Ws <- as(isd %*% dW %*% isd, \"symmetricMatrix\") rowSums(Ws)[21] ## [1] 0 class(Ws) ## [1] \"dsCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" c(determinant(I - rho * Ws, logarithm=TRUE)$modulus) ## [1] -1.594376"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"using-eigs-in-rspectra-for-finding-some-eigenvalues","dir":"Articles","previous_headings":"Using sparse matrices to represent spatial weights","what":"Using eigs in RSpectra for finding some eigenvalues","title":"Spatial weights objects as sparse matrices and graphs","text":"spatial regression, domain spatial coefficient given inverse maximum minimum eigenvalues. n moderate, eigenvalues anyway, interval line search available without extra effort. n somewhat larger, use may made eigs function RSpectra: case, results trivial small k. Using row-standardisation nice feature setting upper bound unity, graph methods finding whether lower bound -1.","code":"1/range(spatialreg::eigenw(nb_B)) ## [1] -0.3212551  0.1638329 if (!require(\"RSpectra\", quietly=TRUE)) dothis <- FALSE 1/c(eigs(B, k=1, which=\"SR\")$values, eigs(B, k=1, which=\"LR\")$values) ## [1] -0.3212551  0.1638329 1/range(eigenw(nb_W)) ## [1] -1.544645  1.000000 1/Re(c(eigs(W, k=1, which=\"SR\")$values, eigs(W, k=1, which=\"LR\")$values)) ## [1] -1.544645  1.000000"},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"converting-from-symmetric-adjacency-matrix-to-graph","dir":"Articles","previous_headings":"Using igraph for spatial weights as graphs","what":"Converting from symmetric adjacency matrix to graph","title":"Spatial weights objects as sparse matrices and graphs","text":"First ’ll see get sparse matrices graphs. mode symmetric matrix \"undirected\" definition:","code":"class(B) ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" object.size(B) ## 10824 bytes if (!require(\"igraph\", quietly=FALSE)) dothis <- FALSE ## Loading required package: igraph ##  ## Attaching package: 'igraph' ## The following objects are masked from 'package:stats': ##  ##     decompose, spectrum ## The following object is masked from 'package:base': ##  ##     union g1 <- graph_from_adjacency_matrix(B, mode=\"undirected\") class(g1) ## [1] \"igraph\" object.size(g1) ## 6544 bytes"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"converting-from-graph-to-symmetric-adjacency-matrix","dir":"Articles","previous_headings":"Using igraph for spatial weights as graphs","what":"Converting from graph to symmetric adjacency matrix","title":"Spatial weights objects as sparse matrices and graphs","text":"can also convert graph back matrix, note as_adjacency_matrix chooses particular class sparse matrix returned, conversion process typically leads many matrices fewer graph types, back fewer matrix types:","code":"# Matrix 1.4-2 vulnerability work-around ow <- options(\"warn\")$warn options(\"warn\"=2L) B1 <- try(as_adjacency_matrix(g1), silent=TRUE) if (!inherits(B1, \"try-error\")) print(class(B1)) ## [1] \"dgCMatrix\" ## attr(,\"package\") ## [1] \"Matrix\" if (!inherits(B1, \"try-error\")) print(object.size(B1)) ## 10824 bytes if (!inherits(B1, \"try-error\")) print(all.equal(B, as(B1, \"CsparseMatrix\"))) ## [1] TRUE options(\"warn\"=ow)"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"graph-components-in-spdep","dir":"Articles","previous_headings":"Using igraph for spatial weights as graphs","what":"Graph components in spdep","title":"Spatial weights objects as sparse matrices and graphs","text":"simple example using igraph existing spdep function Nicholas Lewin-Koh’s n.comp.nb early days package. useful know whether nb object divided separate subgraphs, entities members subgraph.","code":"res <- spdep::n.comp.nb(col2) table(res$comp.id) ##  ##  1  2  3  ## 42  1  6"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"graph-components-in-igraph","dir":"Articles","previous_headings":"Using igraph for spatial weights as graphs","what":"Graph components in igraph","title":"Spatial weights objects as sparse matrices and graphs","text":"result can obtained using clusters function igraph: holds row-standardised variant:","code":"c1 <- components(g1) c1$no == res$nc ## [1] TRUE all.equal(c1$membership, res$comp.id) ## [1] \"names for target but not for current\" all.equal(c1$csize, c(table(res$comp.id)), check.attributes=FALSE) ## [1] TRUE W <- as(spdep::nb2listw(col2, style=\"W\", zero.policy=TRUE), \"CsparseMatrix\") g1W <- graph_from_adjacency_matrix(W, mode=\"directed\", weighted=\"W\") c1W <- components(g1W) all.equal(c1W$membership, res$comp.id) ## [1] \"names for target but not for current\""},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"shortest-paths-in-weights-matrices-igraph","dir":"Articles","previous_headings":"Using igraph for spatial weights as graphs","what":"Shortest paths in weights matrices: igraph","title":"Spatial weights objects as sparse matrices and graphs","text":"Finding shortest paths spatial entities across given graph way express closeness. graph connected, possible traverse graph edges node , longest shortest path useful measure. igraph, .connected function tells us tells us graph connected, know figure . diameter measure diameter largest component subgraph. Note generates n x n matrix:","code":"is_connected(g1) ## [1] FALSE dg1 <- diameter(g1) dg1 ## [1] 7 sp_mat <- distances(g1) str(sp_mat) ##  num [1:49, 1:49] 0 1 1 2 2 3 4 3 3 4 ... ##  - attr(*, \"dimnames\")=List of 2 ##   ..$ : chr [1:49] \"1\" \"2\" \"3\" \"4\" ... ##   ..$ : chr [1:49] \"1\" \"2\" \"3\" \"4\" ..."},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"shortest-paths-in-weights-matrices-spdep","dir":"Articles","previous_headings":"Using igraph for spatial weights as graphs","what":"Shortest paths in weights matrices: spdep","title":"Spatial weights objects as sparse matrices and graphs","text":"spdep, using nblag maximum number lag orders - diameter, unknown advance (largest lag order number links greater zero), run problem represent missing neighbour information. insert zero weights matrix connection using zero.policy=TRUE, generate zero shortest path. create matrix matches one produced shortest.paths, need set non-structural zeros infinity (length path unconnected nodes), re-instate structural zeros diagonal:","code":"nbl10 <- spdep::nblag(col2, maxlag=10) ## Warning in spdep::nblag(col2, maxlag = 10): lag 1 neighbour object has 3 ## sub-graphs ## Warning in spdep::nblag(col2, maxlag = 10): lag 2 neighbour object has 4 ## sub-graphs ## Warning in spdep::nblag(col2, maxlag = 10): lag 3 neighbour object has 8 ## sub-graphs ## Warning in spdep::nblag(col2, maxlag = 10): lag 4 neighbour object has 8 ## sub-graphs ## Warning in spdep::nblag(col2, maxlag = 10): lag 5 neighbour object has 14 ## sub-graphs ## Warning in spdep::nblag(col2, maxlag = 10): lag 6 neighbour object has 29 ## sub-graphs ## Warning in spdep::nblag(col2, maxlag = 10): lag 7 neighbour object has 43 ## sub-graphs ## Warning in spdep::nblag(col2, maxlag = 10): lag 8 neighbour object has 49 ## sub-graphs ## Warning in spdep::nblag(col2, maxlag = 10): lag 9 neighbour object has 49 ## sub-graphs ## Warning in spdep::nblag(col2, maxlag = 10): lag 10 neighbour object has 49 ## sub-graphs vals <- sapply(nbl10, function(x) sum(spdep::card(x))) zero <- which(vals == 0) zero[1]-1 ## [1] 7 lmat <- lapply(nbl10[1:(zero[1]-1)], spdep::nb2mat, style=\"B\", zero.policy=TRUE) mat <- matrix(0, n, n) for (i in seq(along=lmat)) mat = mat + i*lmat[[i]] mat[mat==0] <- Inf diag(mat) <- 0 all.equal(mat, sp_mat, check.attributes=FALSE) ## [1] TRUE"},{"path":"https://r-spatial.github.io/spatialreg/articles/nb_igraph.html","id":"smirnovanselin-2009-cyclical-matrices","dir":"Articles","previous_headings":"Using igraph for spatial weights as graphs","what":"Smirnov/Anselin (2009) cyclical matrices","title":"Spatial weights objects as sparse matrices and graphs","text":"Another area graph representation might prove useful trying establish domain spatial coefficient spatial weights row-standardised. case construction know maximum eigenvalue 1. multiple blocks, graph components, numbers nodes per block greater 1, maximum eigenvalue 1. remaining problems numbers zero eigenvalues (least singleton graph components), whether non-singleton component fulfills condition termed Smirnov Anselin (2009) cyclical matrix, minimum eigenvalue -1. term cyclical appears used many different ways, clear use Smirnov Anselin (2009, pp. 2984-2985) indicates meaning used find relevant graph function. definition used block matrix (subgraph) cyclical : “every location, every pair neighbours connected.” , w[,j] w[,k] greater zero, w[j,k] must zero meet condition. internal function find_q1_q2 returns number non-singleton components, number meet condition. block/subgraph testing condition meets w[j,k] > 0, point breaks. Smirnov Anselin (2009) state rook neighbours regular grid meet condition: One block/graph component found, one meets cyclical matrix condition, also shown domain: apply spatial weights using , two non-singleton components, neither meeting cyclical matrix condition: construction, two-node connected graph components also meet condition, eigenvalues sum zero, maximum unity, minimum must -1.","code":"nb_r <- spdep::cell2nb(7, 7, type=\"rook\") nb_rW <- spdep::nb2listw(nb_r, style=\"W\") spdep:::find_q1_q2(nb_rW) ## [1] 1 1 1/range(Re(eigenw(similar.listw(nb_rW)))) ## [1] -1  1 spdep:::find_q1_q2(nb_W) ## [1] 2 0 1/range(Re(eigenw(similar.listw(nb_W)))) ## [1] -1.544645  1.000000"},{"path":"https://r-spatial.github.io/spatialreg/articles/sids_models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"North Carolina SIDS data set (models)","text":"data set presented first Symons, Grimson, Yuan (1983), analysed reference spatial nature data Cressie Read (1985), expanded Cressie Chan (1989), used detail Cressie (1991). 100 counties North Carolina, includes counts numbers live births (also non-white live births) numbers sudden infant deaths, July 1, 1974 June 30, 1978 July 1, 1979 June 30, 1984 periods. Cressie Read (1985), listing county neighbours based shared boundaries (contiguity) given, Cressie Chan (1989), Cressie (1991, 386–89), different listing based criterion distance county seats, cutoff 30 miles. county seat location coordinates given miles local (unknown) coordinate reference system. data also used exemplify range functions spatial statistics module user’s manual (Kaluzny et al. 1996).","code":""},{"path":"https://r-spatial.github.io/spatialreg/articles/sids_models.html","id":"getting-the-data-into-r","dir":"Articles","previous_headings":"","what":"Getting the data into R","title":"North Carolina SIDS data set (models)","text":"using spdep spatialreg packages, version: spdep, version 1.3-7.1, 2024-10-13, sf package tmap package. data sources referred documented help page nc.sids data set spData. actual data, included shapefile county boundaries North Carolina made available maptools package 1. data known geographical coordinates (longitude-latitude decimal degrees) assumed use NAD27 datum. now examine data set reproduced Cressie collaborators, included spData (formerly spdep), add neighbour relationships used Cressie Chan (1989) background map graph shown Figure :","code":"library(spdep) nc <- st_read(system.file(\"shapes/sids.gpkg\", package=\"spData\")[1], quiet=TRUE) #st_crs(nc) <- \"+proj=longlat +datum=NAD27\" row.names(nc) <- as.character(nc$FIPSNO) nc$ft.SID74 <- sqrt(1000)*(sqrt(nc$SID74/nc$BIR74) + sqrt((nc$SID74+1)/nc$BIR74)) nc$both <- factor(paste(nc$L_id, nc$M_id, sep=\":\")) ## [1] TRUE gal_file <- system.file(\"weights/ncCC89.gal\", package=\"spData\")[1] ncCC89 <- read.gal(gal_file, region.id=nc$FIPSNO)"},{"path":"https://r-spatial.github.io/spatialreg/articles/sids_models.html","id":"car-model-fitting","dir":"Articles","previous_headings":"Getting the data into R","what":"CAR model fitting","title":"North Carolina SIDS data set (models)","text":"now try replicate three four models fitted (Cressie Chan 1989) transformed rates variable. first thing try replicate 30 mile distance county seats neighbours, almost works. try reconstruct three four models fit, concluding can get quite close, number questions raised along way. Building weights much complicated, use combination distance-metric population--risk based weights, can get quite close (see also Kaluzny et al. 1996): first model () null model just intercept, second (II) includes 12 parcels contiguous counties 4 east-west 4 north-south bands, fourth (IV) includes transformed non-white birth-rate: Cressie identifies Anson county outlier, drops analysis. weights constructed complicated way, subsetted dropping row column weights matrix: appears numerical issues (convergence particular) uncertainties exact spatial weights matrix used make difficult reproduce results Cressie Chan (1989), also given Cressie (1991). now try replicate null weighted CAR model (Cressie intercept 2.838, θ̂\\hat{\\theta} 0.833, k=1): spatial parcels model seems work, Cressie’s θ̂\\hat{\\theta} 0.710, failure numerical Hessian used calculate standard error spatial coefficient: Finally, non-white model repeats Cressie’s finding much variance transformed SIDS rate 1974–8 can accounted transformed non-white birth variable (Cressie intercept 1.644, b̂\\hat{b} 0.0346, θ̂\\hat{\\theta} 0.640 — significant), estimate spatial coefficient close :  final figure shows value log likelihood function null model ():","code":"sids.nhbr30.dist <- nbdists(ncCC89, cbind(nc$east, nc$north)) sids.nhbr <- listw2sn(nb2listw(ncCC89, glist=sids.nhbr30.dist, style=\"B\", zero.policy=TRUE)) dij <- sids.nhbr[,3] n <- nc$BIR74 el1 <- min(dij)/dij el2 <- sqrt(n[sids.nhbr$to]/n[sids.nhbr$from]) sids.nhbr$weights <- el1*el2 if (packageVersion(\"spdep\") >= \"1.3.1\") {   sids.nhbr.listw <- sn2listw(sids.nhbr, style=\"B\", zero.policy=TRUE) } else {   sids.nhbr.listw <- sn2listw(sids.nhbr) } nc$ft.NWBIR74 <- sqrt(1000)*(sqrt(nc$NWBIR74/nc$BIR74) + sqrt((nc$NWBIR74+1)/nc$BIR74)) lm_nc <- lm(ft.SID74 ~ 1, data=nc) outl <- which.max(rstandard(lm_nc)) as.character(nc$NAME[outl]) ## [1] \"Anson\" W <- listw2mat(sids.nhbr.listw) W.4 <- W[-outl, -outl] sids.nhbr.listw.4 <- mat2listw(W.4) nc2 <- nc[!(1:length(nc$CNTY_ID) %in% outl),] library(spatialreg) ecarIaw <- spautolm(ft.SID74 ~ 1, data=nc2, listw=sids.nhbr.listw.4, weights=BIR74, family=\"CAR\") summary(ecarIaw) ##  ## Call: spautolm(formula = ft.SID74 ~ 1, data = nc2, listw = sids.nhbr.listw.4,  ##     weights = BIR74, family = \"CAR\") ##  ## Residuals: ##       Min        1Q    Median        3Q       Max  ## -2.010292 -0.639658 -0.062209  0.443549  2.018065  ##  ## Coefficients:  ##             Estimate Std. Error z value  Pr(>|z|) ## (Intercept) 2.945323   0.095135  30.959 < 2.2e-16 ##  ## Lambda: 0.86814 LR test value: 22.83 p-value: 1.7701e-06  ## Numerical Hessian standard error of lambda: 0.04838  ##  ## Log likelihood: -118.8432  ## ML residual variance (sigma squared): 1266.5, (sigma: 35.588) ## Number of observations: 99  ## Number of parameters estimated: 3  ## AIC: NA (not available for weighted model) ecarIIaw <- spautolm(ft.SID74 ~ both - 1, data=nc2, listw=sids.nhbr.listw.4, weights=BIR74, family=\"CAR\") summary(ecarIIaw) ##  ## Call:  ## spautolm(formula = ft.SID74 ~ both - 1, data = nc2, listw = sids.nhbr.listw.4,  ##     weights = BIR74, family = \"CAR\") ##  ## Residuals: ##      Min       1Q   Median       3Q      Max  ## -2.55896 -0.46338 -0.02035  0.38935  2.05682  ##  ## Coefficients:  ##         Estimate Std. Error z value  Pr(>|z|) ## both1:2  2.06223    0.20016 10.3031 < 2.2e-16 ## both1:3  2.91823    0.14139 20.6400 < 2.2e-16 ## both1:4  4.11486    0.29939 13.7439 < 2.2e-16 ## both2:1  2.57650    0.26905  9.5762 < 2.2e-16 ## both2:2  2.17403    0.18222 11.9305 < 2.2e-16 ## both2:3  2.67397    0.15329 17.4443 < 2.2e-16 ## both2:4  3.11361    0.24699 12.6062 < 2.2e-16 ## both3:1  2.94400    0.29893  9.8486 < 2.2e-16 ## both3:2  2.65391    0.14098 18.8250 < 2.2e-16 ## both3:3  2.91619    0.17099 17.0552 < 2.2e-16 ## both3:4  3.20425    0.20349 15.7468 < 2.2e-16 ## both4:3  3.80286    0.20806 18.2781 < 2.2e-16 ##  ## Lambda: 0.2109 LR test value: 1.3088 p-value: 0.25261  ## Numerical Hessian standard error of lambda: NaN  ##  ## Log likelihood: -99.25505  ## ML residual variance (sigma squared): 891.48, (sigma: 29.858) ## Number of observations: 99  ## Number of parameters estimated: 14  ## AIC: NA (not available for weighted model) ecarIVaw <- spautolm(ft.SID74 ~ ft.NWBIR74, data=nc2, listw=sids.nhbr.listw.4, weights=BIR74, family=\"CAR\") summary(ecarIVaw) ##  ## Call:  ## spautolm(formula = ft.SID74 ~ ft.NWBIR74, data = nc2, listw = sids.nhbr.listw.4,  ##     weights = BIR74, family = \"CAR\") ##  ## Residuals: ##      Min       1Q   Median       3Q      Max  ## -1.99056 -0.44858  0.15468  0.60623  1.95541  ##  ## Coefficients:  ##              Estimate Std. Error z value  Pr(>|z|) ## (Intercept) 1.4371519  0.2252729  6.3796 1.775e-10 ## ft.NWBIR74  0.0408354  0.0062919  6.4902 8.572e-11 ##  ## Lambda: 0.22391 LR test value: 1.1577 p-value: 0.28194  ## Numerical Hessian standard error of lambda: 0.5537  ##  ## Log likelihood: -114.0376  ## ML residual variance (sigma squared): 1201.5, (sigma: 34.663) ## Number of observations: 99  ## Number of parameters estimated: 4  ## AIC: NA (not available for weighted model) nc2$fitIV <- fitted.values(ecarIVaw) if (tmap4) {   tm_shape(nc2) + tm_polygons(fill=\"fitIV\", fill.scale=tm_scale(values=\"brewer.yl_or_br\"), fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"), frame=FALSE, item.r = 0), lwd=0.01) } else { tm_shape(nc2) + tm_fill(\"fitIV\") } ecarIawll <- spautolm(ft.SID74 ~ 1, data=nc2, listw=sids.nhbr.listw.4, weights=BIR74, family=\"CAR\", llprof=seq(-0.1, 0.9020532358, length.out=100)) plot(ll ~ lambda, ecarIawll$llprof, type=\"l\")"},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Roger Bivand. Maintainer, author. Gianfranco Piras. Author. Luc Anselin. Contributor. Andrew Bernat. Contributor. Eric Blankmeyer. Contributor. Yongwan Chun. Contributor. Virgilio Gómez-Rubio. Contributor. Daniel Griffith. Contributor. Martin Gubri. Contributor. Rein Halbersma. Contributor. James LeSage. Contributor. Angela Li. Contributor. Hongfei Li. Contributor. Jielai Ma. Contributor. Abhirup Mallik. Contributor, translator. Giovanni Millo. Contributor. Kelley Pace. Contributor. Josiah Parry. Contributor. Pedro Peres-Neto. Contributor. Tobias Rüttenauer. Contributor. Mauricio Sarrias. Contributor. JuanTomas Sayago. Contributor. Michael Tiefelsdorf. Contributor.","code":""},{"path":"https://r-spatial.github.io/spatialreg/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bivand R, Millo G, Piras G (2021). “Review Software Spatial Econometrics R.” Mathematics, 9(11). doi:10.3390/math9111276, https://www.mdpi.com/2227-7390/9/11/1276. Bivand R, Piras G (2015). “Comparing Implementations Estimation Methods Spatial Econometrics.” Journal Statistical Software, 63(18), 1–36. doi:10.18637/jss.v063.i18. Bivand R, Hauke J, Kossowski T (2013). “Computing Jacobian Gaussian spatial autoregressive models: illustrated comparison available methods.” Geographical Analysis, 45(2), 150–179. doi:10.1111/gean.12008. Bivand R, Pebesma E, Gómez-Rubio V (2013). Applied spatial data analysis R, Second edition. Springer, NY. https://asdar-book.org/. Pebesma E, Bivand R (2023). Spatial Data Science Applications R. Chapman & Hall. https://r-spatial.org/book/.","code":"@Article{,   title = {A Review of Software for Spatial Econometrics in {R}},   author = {Roger Bivand and Giovanni Millo and Gianfranco Piras},   journal = {Mathematics},   year = {2021},   volume = {9},   number = {11},   url = {https://www.mdpi.com/2227-7390/9/11/1276},   doi = {10.3390/math9111276}, } @Article{,   title = {Comparing Implementations of Estimation Methods for Spatial Econometrics},   author = {Roger Bivand and Gianfranco Piras},   journal = {Journal of Statistical Software},   year = {2015},   volume = {63},   number = {18},   pages = {1--36},   doi = {10.18637/jss.v063.i18}, } @Article{,   title = {Computing the Jacobian in Gaussian spatial autoregressive models: An illustrated comparison of available methods},   author = {Roger Bivand and Jan Hauke and Tomasz Kossowski},   journal = {Geographical Analysis},   year = {2013},   volume = {45},   number = {2},   pages = {150--179},   doi = {10.1111/gean.12008}, } @Book{,   author = {Roger S. Bivand and Edzer Pebesma and Virgilio Gómez-Rubio},   title = {Applied spatial data analysis with {R}, Second edition},   year = {2013},   publisher = {Springer, NY},   url = {https://asdar-book.org/}, } @Book{,   author = {Edzer Pebesma and Roger S. Bivand},   title = {Spatial Data Science With Applications in {R}},   year = {2023},   publisher = {Chapman & Hall},   url = {https://r-spatial.org/book/}, }"},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/index.html","id":"spatialreg-spatial-models-estimation-and-testing","dir":"","previous_headings":"","what":"spatialreg: spatial models estimation and testing","title":"Spatial Regression Analysis","text":"collection estimation functions spatial cross-sectional models (lattice/areal data using spatial weights matrices) contained now spdep. model fitting functions include maximum likelihood methods cross-sectional models proposed Cliff Ord (1973, ISBN: 0850860369) (1981, ISBN: 0850860814), fitting methods initially described Ord (1975) https://doi.org/10.1080/01621459.1975.10480272. models described Anselin (1988) https://doi.org/10.1007/978-94-015-7799-1. Spatial two stage least squares spatial general method moment models initially proposed Kelejian Prucha (1998) https://doi.org/10.1023/:1007707430416 (1999) https://doi.org/10.1111/1468-2354.00027 provided. Impact methods MCMC fitting methods proposed LeSage Pace (2009) https://doi.org/10.1201/9781420064254 implemented family cross-sectional spatial regression models. Methods fitting log determinant term maximum likelihood MCMC fitting compared Bivand et al. (2013) https://doi.org/10.1111/gean.12008, model fitting methods Bivand Piras (2015) https://doi.org/10.18637/jss.v063.i18; articles include extensive lists references. recent review provided Bivand, Millo Piras (2021) https://doi.org/10.3390/math9111276. spatialreg >= 1.1-1 corresponds spdep = 1.1-1, model fitting functions deprecated pass spatialreg, mask spatialreg. versions 1.2-1, functions made defunct spdep. version 1.3-6, add Anselin-Kelejian (1997) test stsls residual spatial autocorrelation https://doi.org/10.1177/016001769702000109. Default branch now main.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/GMerrorsar.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial simultaneous autoregressive error model estimation by GMM — GMerrorsar","title":"Spatial simultaneous autoregressive error model estimation by GMM — GMerrorsar","text":"implementation Kelejian Prucha's generalised moments estimator autoregressive parameter spatial model.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/GMerrorsar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial simultaneous autoregressive error model estimation by GMM — GMerrorsar","text":"","code":"GMerrorsar(formula, data = list(), listw, na.action = na.fail,  zero.policy = attr(listw, \"zero.policy\"), method=\"nlminb\", arnoldWied=FALSE,   control = list(), pars, scaleU=FALSE, verbose=NULL, legacy=FALSE,  se.lambda=TRUE, returnHcov=FALSE, pWOrder=250, tol.Hcov=1.0e-10) # S3 method for class 'Gmsar' summary(object, correlation = FALSE, Hausman=FALSE, ...) GMargminImage(obj, lambdaseq, s2seq)"},{"path":"https://r-spatial.github.io/spatialreg/reference/GMerrorsar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial simultaneous autoregressive error model estimation by GMM — GMerrorsar","text":"formula symbolic description model fit. details model specification given lm() data optional data frame containing variables model. default variables taken environment function called. listw listw object created example nb2listw na.action function (default na.fail), can also na.omit na.exclude consequences residuals fitted values - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE (default) assign NA - causing GMerrorsar() terminate error method default \"nlminb\", optionally method passed optim use alternative optimizer arnoldWied default FALSE control list control parameters. See details optim nlminb. pars starting values \\(\\lambda\\) \\(\\sigma^2\\) GMM optimisation, missing (default), approximated initial OLS model autocorrelation coefficient corrected weights style model sigma squared scaleU Default FALSE: scale OLS residuals computing moment matrices; used pars argument missing verbose default NULL, use global option value; TRUE, reports function values optimization. legacy default FALSE - compute using unfiltered values response right hand side variables; TRUE - compute fitted value residuals spatially filtered model using spatial error parameter se.lambda default TRUE, use analytical method described http://econweb.umd.edu/~prucha/STATPROG/OLS/desols.pdf returnHcov default FALSE, return Vo matrix spatial Hausman test tol.Hcov tolerance computing Vo matrix (default=1.0e-10) pWOrder default 250, returnHcov=TRUE, pass order powerWeights power series maximum limit object, obj Gmsar object GMerrorsar correlation logical; (default=FALSE), TRUE available Hausman TRUE, results Hausman test error models reported ... summary arguments passed lambdaseq given, increasing sequence lambda values gridding s2seq given, increasing sequence sigma squared values gridding","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/GMerrorsar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial simultaneous autoregressive error model estimation by GMM — GMerrorsar","text":"control list set care, function converge values close ML estimator without requiring computation Jacobian, resource-intensive part ML estimation. Note fitted() function output object assumes response variable may reconstructed sum trend, signal, noise (residuals). Since values response variable known, spatial lags used calculate signal components (Cressie 1993, p. 564). differs software, including GeoDa, use knowledge response variable making predictions fitting data. GMargminImage may used visualize shape surface argmin function used find lambda.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/GMerrorsar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial simultaneous autoregressive error model estimation by GMM — GMerrorsar","text":"list object class Gmsar type \"ERROR\" lambda simultaneous autoregressive error coefficient coefficients GMM coefficient estimates rest.se GMM coefficient standard errors s2 GMM residual variance SSE sum squared GMM errors parameters number parameters estimated lm.model lm object returned estimating \\(\\lambda=0\\) call call used create object residuals GMM residuals lm.target lm object returned GMM fit fitted.values Difference residuals response variable formula model formula aliased NULL, details aliased variables zero.policy zero.policy model vv list internal bigG litg components testing optimisation surface optres object returned optimizer pars start parameter values optimisation Hcov Spatial DGP covariance matrix Hausman test available legacy input choice unfiltered filtered values lambda.se value computed input argument TRUE arnoldWied Arnold-Wied moments used GMs2 GM argmin sigma squared scaleU input choice scaled OLS residuals vcov variance-covariance matrix regression coefficients na.action (possibly) named vector excluded omitted observations non-default na.action argument used","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/GMerrorsar.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial simultaneous autoregressive error model estimation by GMM — GMerrorsar","text":"Kelejian, H. H., Prucha, . R., 1999. Generalized Moments Estimator Autoregressive Parameter Spatial Model. International Economic Review, 40, pp. 509–533; Cressie, N. . C. 1993 Statistics spatial data, Wiley, New York. Roger Bivand, Gianfranco Piras (2015). Comparing Implementations Estimation Methods Spatial Econometrics. Journal Statistical Software, 63(18), 1-36. doi:10.18637/jss.v063.i18 .","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/GMerrorsar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial simultaneous autoregressive error model estimation by GMM — GMerrorsar","text":"Luc Anselin Roger Bivand","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/GMerrorsar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial simultaneous autoregressive error model estimation by GMM — GMerrorsar","text":"","code":"#require(\"spdep\", quietly=TRUE) data(oldcol, package=\"spdep\") COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  spdep::nb2listw(COL.nb, style=\"W\"), method=\"eigen\") (x <- summary(COL.errW.eig, Hausman=TRUE)) #>  #> Call: #> errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"W\"), method = \"eigen\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -34.81174  -6.44031  -0.72142   7.61476  23.33626  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 59.893219   5.366163 11.1613 < 2.2e-16 #> INC         -0.941312   0.330569 -2.8476 0.0044057 #> HOVAL       -0.302250   0.090476 -3.3407 0.0008358 #>  #> Lambda: 0.56179, LR test value: 7.9935, p-value: 0.0046945 #> Asymptotic standard error: 0.13387 #>     z-value: 4.1966, p-value: 2.7098e-05 #> Wald statistic: 17.611, p-value: 2.7098e-05 #>  #> Log likelihood: -183.3805 for error model #> ML residual variance (sigma squared): 95.575, (sigma: 9.7762) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 376.76, (AIC for lm: 382.75) #> Hausman test: 4.902, df: 3, p-value: 0.17911 #>  coef(x) #>               Estimate Std. Error   z value     Pr(>|z|) #> (Intercept) 59.8932190 5.36616256 11.161276 0.0000000000 #> INC         -0.9413120 0.33056857 -2.847554 0.0044056574 #> HOVAL       -0.3022502 0.09047605 -3.340665 0.0008357787 COL.errW.GM <- GMerrorsar(CRIME ~ INC + HOVAL, data=COL.OLD,  spdep::nb2listw(COL.nb, style=\"W\"), returnHcov=TRUE) (x <- summary(COL.errW.GM, Hausman=TRUE)) #>  #> Call: #> GMerrorsar(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"W\"), returnHcov = TRUE) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -30.5432  -6.5553  -2.1921  10.0553  28.7497  #>  #> Type: GM SAR estimator #> Coefficients: (GM standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 62.513752   5.121339  12.207 < 2.2e-16 #> INC         -1.128283   0.339745  -3.321  0.000897 #> HOVAL       -0.296957   0.095699  -3.103  0.001915 #>  #> Lambda: 0.40196 (standard error): 0.42334 (z-value): 0.94948 #> Residual variance (sigma squared): 106.64, (sigma: 10.327) #> GM argmin sigma squared: 106.36 #> Number of observations: 49  #> Number of parameters estimated: 5  #> Hausman test: 6.6406, df: 3, p-value: 0.08428 #>  coef(x) #>               Estimate Std. Error   z value     Pr(>|z|) #> (Intercept) 62.5137525 5.12133863 12.206526 0.0000000000 #> INC         -1.1282834 0.33974492 -3.320972 0.0008970455 #> HOVAL       -0.2969573 0.09569889 -3.103038 0.0019154486 aa <- GMargminImage(COL.errW.GM) levs <- quantile(aa$z, seq(0, 1, 1/12)) image(aa, breaks=levs, xlab=\"lambda\", ylab=\"s2\") points(COL.errW.GM$lambda, COL.errW.GM$s2, pch=3, lwd=2) contour(aa, levels=signif(levs, 4), add=TRUE)  COL.errW.GM1 <- GMerrorsar(CRIME ~ INC + HOVAL, data=COL.OLD,  spdep::nb2listw(COL.nb, style=\"W\")) summary(COL.errW.GM1) #>  #> Call: #> GMerrorsar(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"W\")) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -30.5432  -6.5553  -2.1921  10.0553  28.7497  #>  #> Type: GM SAR estimator #> Coefficients: (GM standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 62.513752   5.121339  12.207 < 2.2e-16 #> INC         -1.128283   0.339745  -3.321  0.000897 #> HOVAL       -0.296957   0.095699  -3.103  0.001915 #>  #> Lambda: 0.40196 (standard error): 0.42334 (z-value): 0.94948 #> Residual variance (sigma squared): 106.64, (sigma: 10.327) #> GM argmin sigma squared: 106.36 #> Number of observations: 49  #> Number of parameters estimated: 5  #>  require(\"sf\", quietly=TRUE) nydata <- st_read(system.file(\"shapes/NY8_bna_utm18.gpkg\", package=\"spData\")[1], quiet=TRUE) suppressMessages(nyadjmat <- as.matrix(foreign::read.dbf(system.file(  \"misc/nyadjwts.dbf\", package=\"spData\")[1])[-1])) suppressMessages(ID <- as.character(names(foreign::read.dbf(system.file(  \"misc/nyadjwts.dbf\", package=\"spData\")[1]))[-1])) identical(substring(ID, 2, 10), substring(as.character(nydata$AREAKEY), 2, 10)) #> [1] TRUE listw_NY <- spdep::mat2listw(nyadjmat, as.character(nydata$AREAKEY), style=\"B\") esar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, family=\"SAR\", method=\"eigen\") summary(esar1f) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, family = \"SAR\", method = \"eigen\") #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.56754 -0.38239 -0.02643  0.33109  4.01219  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.618193   0.176784 -3.4969 0.0004707 #> PEXPOSURE    0.071014   0.042051  1.6888 0.0912635 #> PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09 #> PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930 #>  #> Lambda: 0.040487 LR test value: 5.2438 p-value: 0.022026  #> Numerical Hessian standard error of lambda: 0.017201  #>  #> Log likelihood: -276.1069  #> ML residual variance (sigma squared): 0.41388, (sigma: 0.64333) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 564.21 #>  esar1gm <- GMerrorsar(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  data=nydata, listw=listw_NY) summary(esar1gm) #>  #> Call:GMerrorsar(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  #>     data = nydata, listw = listw_NY) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.641411 -0.396370 -0.026618  0.341740  4.204264  #>  #> Type: GM SAR estimator #> Coefficients: (GM standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.604364   0.174576 -3.4619 0.0005364 #> PEXPOSURE    0.067902   0.041164  1.6496 0.0990337 #> PCTAGE65P    3.775308   0.622965  6.0602 1.359e-09 #> PCTOWNHOME  -0.437545   0.188906 -2.3162 0.0205468 #>  #> Lambda: 0.03605 (standard error): 0.2022 (z-value): 0.17829 #> Residual variance (sigma squared): 0.41585, (sigma: 0.64487) #> GM argmin sigma squared: 0.45141 #> Number of observations: 281  #> Number of parameters estimated: 6  #>  esar1gm1 <- GMerrorsar(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  data=nydata, listw=listw_NY, method=\"Nelder-Mead\") summary(esar1gm1) #>  #> Call:GMerrorsar(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  #>     data = nydata, listw = listw_NY, method = \"Nelder-Mead\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.641390 -0.396374 -0.026616  0.341745  4.204277  #>  #> Type: GM SAR estimator #> Coefficients: (GM standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.604384   0.174580 -3.4619 0.0005363 #> PEXPOSURE    0.067907   0.041165  1.6496 0.0990225 #> PCTAGE65P    3.775275   0.622969  6.0601  1.36e-09 #> PCTOWNHOME  -0.437518   0.188910 -2.3160 0.0205572 #>  #> Lambda: 0.036057 (standard error): 0.20221 (z-value): 0.17832 #> Residual variance (sigma squared): 0.41585, (sigma: 0.64487) #> GM argmin sigma squared: 0.45139 #> Number of observations: 281  #> Number of parameters estimated: 6  #>"},{"path":"https://r-spatial.github.io/spatialreg/reference/MCMCsamp.html","id":null,"dir":"Reference","previous_headings":"","what":"MCMC sample from fitted spatial regression — MCMCsamp","title":"MCMC sample from fitted spatial regression — MCMCsamp","text":"MCMCsamp method uses rwmetrop, random walk Metropolis algorithm, LearnBayes make MCMC samples fitted maximum likelihood spatial regression models.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/MCMCsamp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MCMC sample from fitted spatial regression — MCMCsamp","text":"","code":"MCMCsamp(object, mcmc = 1L, verbose = NULL, ...) # S3 method for class 'Spautolm' MCMCsamp(object, mcmc = 1L, verbose = NULL, ...,  burnin = 0L, scale=1, listw, control = list()) # S3 method for class 'Sarlm' MCMCsamp(object, mcmc = 1L, verbose = NULL, ...,     burnin=0L, scale=1, listw, listw2=NULL, control=list())"},{"path":"https://r-spatial.github.io/spatialreg/reference/MCMCsamp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MCMC sample from fitted spatial regression — MCMCsamp","text":"object spatial regression model object fitted maximum likelihood spautolm mcmc number MCMC iterations burnin verbose default NULL, use global option value; TRUE, reports progress ... Arguments passed burnin number burn-iterations sampler scale positive scale parameter listw, listw2 listw objects created example nb2listw; object(s) used fitting model control list extra control arguments - see spautolm","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/MCMCsamp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MCMC sample from fitted spatial regression — MCMCsamp","text":"object class “mcmc” suited coda, attributes: “accept” acceptance rate; “type” input ML fitted model type “SAR”, “CAR”, “SMA”, “lag”, “mixed”, “error”, “sac”, “sacmixed”; “timings” run times","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/MCMCsamp.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"MCMC sample from fitted spatial regression — MCMCsamp","text":"acceptance rate 0.05, warning issued; consider increasing mcmc.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/MCMCsamp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"MCMC sample from fitted spatial regression — MCMCsamp","text":"Jim Albert (2007) Bayesian Computation R, Springer, New York, pp. 104-105.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/MCMCsamp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"MCMC sample from fitted spatial regression — MCMCsamp","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/MCMCsamp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"MCMC sample from fitted spatial regression — MCMCsamp","text":"","code":"require(\"sf\", quietly=TRUE) nydata <- st_read(system.file(\"shapes/NY8_bna_utm18.gpkg\", package=\"spData\")[1], quiet=TRUE) suppressMessages(nyadjmat <- as.matrix(foreign::read.dbf(system.file(  \"misc/nyadjwts.dbf\", package=\"spData\")[1])[-1])) suppressMessages(ID <- as.character(names(foreign::read.dbf(system.file(  \"misc/nyadjwts.dbf\", package=\"spData\")[1]))[-1])) identical(substring(ID, 2, 10), substring(as.character(nydata$AREAKEY), 2, 10)) #> [1] TRUE #require(\"spdep\", quietly=TRUE) listw_NY <- spdep::mat2listw(nyadjmat, as.character(nydata$AREAKEY), style=\"B\") esar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, family=\"SAR\", method=\"eigen\") summary(esar1f) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, family = \"SAR\", method = \"eigen\") #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.56754 -0.38239 -0.02643  0.33109  4.01219  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.618193   0.176784 -3.4969 0.0004707 #> PEXPOSURE    0.071014   0.042051  1.6888 0.0912635 #> PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09 #> PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930 #>  #> Lambda: 0.040487 LR test value: 5.2438 p-value: 0.022026  #> Numerical Hessian standard error of lambda: 0.017201  #>  #> Log likelihood: -276.1069  #> ML residual variance (sigma squared): 0.41388, (sigma: 0.64333) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 564.21 #>  res <- MCMCsamp(esar1f, mcmc=1000, burnin=200, listw=listw_NY) summary(res) #>  #> Iterations = 1:1000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 1000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD  Naive SE Time-series SE #> lambda       0.04611 0.01498 0.0004736       0.001756 #> (Intercept) -0.65331 0.19263 0.0060916       0.026540 #> PEXPOSURE    0.08968 0.04897 0.0015486       0.006607 #> PCTAGE65P    3.69656 0.52425 0.0165784       0.057839 #> PCTOWNHOME  -0.39485 0.23949 0.0075732       0.037397 #>  #> 2. Quantiles for each variable: #>  #>                  2.5%      25%      50%      75%    97.5% #> lambda       0.015004  0.03557  0.04640  0.05531  0.07351 #> (Intercept) -1.089847 -0.77125 -0.63878 -0.51969 -0.34027 #> PEXPOSURE   -0.001914  0.05288  0.09113  0.12367  0.18519 #> PCTAGE65P    2.672002  3.33982  3.67753  4.04290  4.74392 #> PCTOWNHOME  -0.845780 -0.56384 -0.41154 -0.21860  0.07637 #>  # \\dontrun{ esar1fw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, weights=POP8, family=\"SAR\", method=\"eigen\") summary(esar1fw) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, weights = POP8, family = \"SAR\", method = \"eigen\") #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.48488 -0.26823  0.09489  0.46552  4.28343  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.797063   0.144054 -5.5331 3.146e-08 #> PEXPOSURE    0.080545   0.028334  2.8428  0.004473 #> PCTAGE65P    3.816731   0.576037  6.6258 3.453e-11 #> PCTOWNHOME  -0.380778   0.156507 -2.4330  0.014975 #>  #> Lambda: 0.0095636 LR test value: 0.32665 p-value: 0.56764  #> Numerical Hessian standard error of lambda: 0.016522  #>  #> Log likelihood: -251.6017  #> ML residual variance (sigma squared): 1104.1, (sigma: 33.229) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: NA (not available for weighted model) #>  res <- MCMCsamp(esar1fw, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD  Naive SE Time-series SE #> lambda       0.01296 0.01568 0.0002218      0.0008193 #> (Intercept) -0.79417 0.15064 0.0021303      0.0085373 #> PEXPOSURE    0.07886 0.02974 0.0004206      0.0016661 #> PCTAGE65P    3.79201 0.58160 0.0082250      0.0316924 #> PCTOWNHOME  -0.38114 0.16875 0.0023864      0.0100745 #>  #> 2. Quantiles for each variable: #>  #>                 2.5%      25%      50%      75%    97.5% #> lambda      -0.01785  0.00281  0.01326  0.02352  0.04254 #> (Intercept) -1.09757 -0.89163 -0.79274 -0.69957 -0.47937 #> PEXPOSURE    0.02125  0.05871  0.07958  0.09926  0.13413 #> PCTAGE65P    2.68865  3.36618  3.80173  4.17535  4.89445 #> PCTOWNHOME  -0.70327 -0.49343 -0.37753 -0.27046 -0.03549 #>  ecar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, family=\"CAR\", method=\"eigen\") summary(ecar1f) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, family = \"CAR\", method = \"eigen\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.539732 -0.384311 -0.030646  0.335126  3.808848  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.648362   0.181129 -3.5796 0.0003442 #> PEXPOSURE    0.077899   0.043692  1.7829 0.0745986 #> PCTAGE65P    3.703830   0.627185  5.9055 3.516e-09 #> PCTOWNHOME  -0.382789   0.195564 -1.9574 0.0503053 #>  #> Lambda: 0.084123 LR test value: 5.8009 p-value: 0.016018  #> Numerical Hessian standard error of lambda: 0.030872  #>  #> Log likelihood: -275.8283  #> ML residual variance (sigma squared): 0.40758, (sigma: 0.63842) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 563.66 #>  res <- MCMCsamp(ecar1f, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD  Naive SE Time-series SE #> lambda       0.08485 0.03007 0.0004252       0.001841 #> (Intercept) -0.66321 0.21541 0.0030463       0.014591 #> PEXPOSURE    0.08242 0.04990 0.0007057       0.003038 #> PCTAGE65P    3.65269 0.64308 0.0090945       0.039341 #> PCTOWNHOME  -0.35759 0.22515 0.0031840       0.014851 #>  #> 2. Quantiles for each variable: #>  #>                  2.5%      25%      50%     75%   97.5% #> lambda       0.021075  0.06565  0.08492  0.1070  0.1398 #> (Intercept) -1.173329 -0.78618 -0.63961 -0.5233 -0.2863 #> PEXPOSURE   -0.008489  0.04927  0.07836  0.1125  0.1967 #> PCTAGE65P    2.400330  3.17755  3.65477  4.0908  4.9428 #> PCTOWNHOME  -0.761115 -0.51656 -0.37324 -0.2168  0.1507 #>  esar1fw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, weights=POP8, family=\"SAR\", method=\"eigen\") summary(esar1fw) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, weights = POP8, family = \"SAR\", method = \"eigen\") #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.48488 -0.26823  0.09489  0.46552  4.28343  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.797063   0.144054 -5.5331 3.146e-08 #> PEXPOSURE    0.080545   0.028334  2.8428  0.004473 #> PCTAGE65P    3.816731   0.576037  6.6258 3.453e-11 #> PCTOWNHOME  -0.380778   0.156507 -2.4330  0.014975 #>  #> Lambda: 0.0095636 LR test value: 0.32665 p-value: 0.56764  #> Numerical Hessian standard error of lambda: 0.016522  #>  #> Log likelihood: -251.6017  #> ML residual variance (sigma squared): 1104.1, (sigma: 33.229) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: NA (not available for weighted model) #>  res <- MCMCsamp(esar1fw, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD Naive SE Time-series SE #> lambda       0.01421 0.01648 0.000233      0.0009767 #> (Intercept) -0.79603 0.15920 0.002251      0.0097286 #> PEXPOSURE    0.08092 0.03097 0.000438      0.0018774 #> PCTAGE65P    3.77070 0.60576 0.008567      0.0381835 #> PCTOWNHOME  -0.37884 0.17038 0.002410      0.0102914 #>  #> 2. Quantiles for each variable: #>  #>                 2.5%       25%      50%      75%    97.5% #> lambda      -0.01732  0.002764  0.01370  0.02629  0.04646 #> (Intercept) -1.12961 -0.899430 -0.80307 -0.69685 -0.48183 #> PEXPOSURE    0.02262  0.059634  0.08016  0.10062  0.14212 #> PCTAGE65P    2.58384  3.361796  3.81098  4.18747  4.90361 #> PCTOWNHOME  -0.69813 -0.495245 -0.38500 -0.26182 -0.03602 #>  ecar1fw <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, weights=POP8, family=\"CAR\", method=\"eigen\") summary(ecar1fw) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, weights = POP8, family = \"CAR\", method = \"eigen\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.491042 -0.270906  0.081435  0.451556  4.198134  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.790154   0.144862 -5.4545 4.910e-08 #> PEXPOSURE    0.081922   0.028593  2.8651  0.004169 #> PCTAGE65P    3.825858   0.577720  6.6223 3.536e-11 #> PCTOWNHOME  -0.386820   0.157436 -2.4570  0.014010 #>  #> Lambda: 0.022419 LR test value: 0.38785 p-value: 0.53343  #> Numerical Hessian standard error of lambda: 0.038977  #>  #> Log likelihood: -251.5711  #> ML residual variance (sigma squared): 1102.9, (sigma: 33.21) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: NA (not available for weighted model) #>  res <- MCMCsamp(ecar1fw, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD  Naive SE Time-series SE #> lambda       0.03646 0.04020 0.0005686       0.002593 #> (Intercept) -0.83219 0.15755 0.0022281       0.009562 #> PEXPOSURE    0.09116 0.03438 0.0004863       0.002139 #> PCTAGE65P    3.74091 0.59000 0.0083439       0.035836 #> PCTOWNHOME  -0.34906 0.17055 0.0024119       0.010630 #>  #> 2. Quantiles for each variable: #>  #>                 2.5%       25%      50%      75%     97.5% #> lambda      -0.04545  0.009909  0.04055  0.06473  0.108790 #> (Intercept) -1.15043 -0.936965 -0.82876 -0.72797 -0.532623 #> PEXPOSURE    0.02618  0.068120  0.08997  0.11245  0.165457 #> PCTAGE65P    2.56456  3.350294  3.72433  4.13057  4.958447 #> PCTOWNHOME  -0.69327 -0.461490 -0.34685 -0.24507 -0.001185 #>  # } esar0 <- errorsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY) summary(esar0) #>  #> Call:errorsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  #>     data = nydata, listw = listw_NY) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.56754 -0.38239 -0.02643  0.33109  4.01219  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.618193   0.176784 -3.4969 0.0004707 #> PEXPOSURE    0.071014   0.042051  1.6888 0.0912635 #> PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09 #> PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930 #>  #> Lambda: 0.040487, LR test value: 5.2438, p-value: 0.022026 #> Asymptotic standard error: 0.016214 #>     z-value: 2.4971, p-value: 0.01252 #> Wald statistic: 6.2356, p-value: 0.01252 #>  #> Log likelihood: -276.1069 for error model #> ML residual variance (sigma squared): 0.41388, (sigma: 0.64333) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 564.21, (AIC for lm: 567.46) #>  res <- MCMCsamp(esar0, mcmc=1000, burnin=200, listw=listw_NY) summary(res) #>  #> Iterations = 1:1000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 1000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD  Naive SE Time-series SE #> lambda       0.04682 0.01895 0.0005993       0.002739 #> (Intercept) -0.65775 0.21896 0.0069243       0.031633 #> PEXPOSURE    0.08543 0.05260 0.0016634       0.007626 #> PCTAGE65P    3.65044 0.57371 0.0181422       0.060983 #> PCTOWNHOME  -0.36116 0.23745 0.0075089       0.036472 #>  #> 2. Quantiles for each variable: #>  #>                   2.5%      25%      50%      75%    97.5% #> lambda       0.0109828  0.03340  0.04839  0.05958  0.08139 #> (Intercept) -1.0771095 -0.81427 -0.62781 -0.51408 -0.23029 #> PEXPOSURE   -0.0004135  0.04738  0.07927  0.11564  0.20607 #> PCTAGE65P    2.5911599  3.20769  3.63005  4.09097  4.74100 #> PCTOWNHOME  -0.8037868 -0.54136 -0.35322 -0.20277  0.17058 #>  # \\dontrun{ esar0w <- errorsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, weights=POP8) summary(esar0) #>  #> Call:errorsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  #>     data = nydata, listw = listw_NY) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.56754 -0.38239 -0.02643  0.33109  4.01219  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.618193   0.176784 -3.4969 0.0004707 #> PEXPOSURE    0.071014   0.042051  1.6888 0.0912635 #> PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09 #> PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930 #>  #> Lambda: 0.040487, LR test value: 5.2438, p-value: 0.022026 #> Asymptotic standard error: 0.016214 #>     z-value: 2.4971, p-value: 0.01252 #> Wald statistic: 6.2356, p-value: 0.01252 #>  #> Log likelihood: -276.1069 for error model #> ML residual variance (sigma squared): 0.41388, (sigma: 0.64333) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 564.21, (AIC for lm: 567.46) #>  res <- MCMCsamp(esar0w, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD  Naive SE Time-series SE #> lambda       0.01177 0.01571 0.0002221      0.0008781 #> (Intercept) -0.79575 0.14274 0.0020186      0.0078442 #> PEXPOSURE    0.08036 0.02929 0.0004143      0.0017545 #> PCTAGE65P    3.81500 0.57129 0.0080793      0.0330363 #> PCTOWNHOME  -0.38426 0.15508 0.0021932      0.0087813 #>  #> 2. Quantiles for each variable: #>  #>                 2.5%      25%      50%      75%    97.5% #> lambda      -0.01899  0.00175  0.01220  0.02213  0.04328 #> (Intercept) -1.07330 -0.89063 -0.79366 -0.70020 -0.51399 #> PEXPOSURE    0.02200  0.06082  0.08123  0.10067  0.13675 #> PCTAGE65P    2.70738  3.41885  3.80976  4.20150  4.94589 #> PCTOWNHOME  -0.70906 -0.47931 -0.38839 -0.28703 -0.06345 #>  esar1 <- errorsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, etype=\"emixed\") summary(esar1) #>  #> Call:errorsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  #>     data = nydata, listw = listw_NY, etype = \"emixed\") #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.81562 -0.37641 -0.02224  0.33638  4.00054  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>                  Estimate Std. Error z value  Pr(>|z|) #> (Intercept)     -1.118019   0.247425 -4.5186 6.225e-06 #> PEXPOSURE        0.218279   0.079245  2.7545  0.005879 #> PCTAGE65P        3.416477   0.645587  5.2920 1.210e-07 #> PCTOWNHOME       0.036593   0.249835  0.1465  0.883551 #> lag.(Intercept)  0.121515   0.057636  2.1083  0.035003 #> lag.PEXPOSURE   -0.035075   0.015943 -2.2000  0.027808 #> lag.PCTAGE65P    0.263096   0.220118  1.1953  0.231989 #> lag.PCTOWNHOME  -0.155680   0.059213 -2.6291  0.008560 #>  #> Lambda: 0.022723, LR test value: 1.6846, p-value: 0.19432 #> Asymptotic standard error: 0.017169 #>     z-value: 1.3235, p-value: 0.18567 #> Wald statistic: 1.7516, p-value: 0.18567 #>  #> Log likelihood: -269.5398 for error model #> ML residual variance (sigma squared): 0.39759, (sigma: 0.63055) #> Number of observations: 281  #> Number of parameters estimated: 10  #> AIC: 559.08, (AIC for lm: 558.76) #>  res <- MCMCsamp(esar1, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                     Mean      SD  Naive SE Time-series SE #> lambda           0.02791 0.01696 0.0002398       0.001257 #> (Intercept)     -1.11089 0.24295 0.0034359       0.019066 #> PEXPOSURE        0.20998 0.08066 0.0011407       0.006616 #> PCTAGE65P        3.44550 0.61861 0.0087484       0.045120 #> PCTOWNHOME       0.03249 0.25058 0.0035437       0.022380 #> lag.(Intercept)  0.11788 0.05850 0.0008273       0.004548 #> lag.PEXPOSURE   -0.03381 0.01626 0.0002299       0.001358 #> lag.PCTAGE65P    0.25893 0.23503 0.0033238       0.019521 #> lag.PCTOWNHOME  -0.15337 0.05824 0.0008236       0.004496 #>  #> 2. Quantiles for each variable: #>  #>                      2.5%      25%      50%      75%      97.5% #> lambda          -0.004792  0.01604  0.02829  0.03980  0.0616941 #> (Intercept)     -1.549205 -1.28823 -1.12499 -0.91520 -0.6509996 #> PEXPOSURE        0.063165  0.15363  0.20577  0.26455  0.3711420 #> PCTAGE65P        2.335975  3.01533  3.44864  3.91005  4.6644758 #> PCTOWNHOME      -0.505045 -0.11695  0.05420  0.19038  0.5171339 #> lag.(Intercept)  0.006027  0.07616  0.11689  0.16220  0.2310606 #> lag.PEXPOSURE   -0.064845 -0.04488 -0.03385 -0.02339 -0.0009086 #> lag.PCTAGE65P   -0.195440  0.09430  0.24778  0.43584  0.6912104 #> lag.PCTOWNHOME  -0.263176 -0.19213 -0.15386 -0.11592 -0.0317401 #>  lsar0 <- lagsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY) summary(lsar0) #>  #> Call:lagsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.586752 -0.391580 -0.022469  0.338017  4.029430  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.514495   0.156154 -3.2948  0.000985 #> PEXPOSURE    0.047627   0.034509  1.3801  0.167542 #> PCTAGE65P    3.648198   0.599046  6.0900 1.129e-09 #> PCTOWNHOME  -0.414601   0.169554 -2.4453  0.014475 #>  #> Rho: 0.038893, LR test value: 6.9683, p-value: 0.0082967 #> Asymptotic standard error: 0.015053 #>     z-value: 2.5837, p-value: 0.0097755 #> Wald statistic: 6.6754, p-value: 0.0097755 #>  #> Log likelihood: -275.2447 for lag model #> ML residual variance (sigma squared): 0.41166, (sigma: 0.6416) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 562.49, (AIC for lm: 567.46) #> LM test for residual autocorrelation #> test value: 1.4633, p-value: 0.22641 #>  res <- MCMCsamp(lsar0, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD  Naive SE Time-series SE #> rho          0.03924 0.01531 0.0002166      0.0009369 #> (Intercept) -0.51482 0.16721 0.0023647      0.0103798 #> PEXPOSURE    0.05057 0.03374 0.0004771      0.0019411 #> PCTAGE65P    3.58543 0.66827 0.0094508      0.0442173 #> PCTOWNHOME  -0.41083 0.18638 0.0026358      0.0118147 #>  #> 2. Quantiles for each variable: #>  #>                 2.5%      25%      50%      75%    97.5% #> rho          0.01129  0.02805  0.03879  0.05012  0.07010 #> (Intercept) -0.84632 -0.62884 -0.50852 -0.39309 -0.20739 #> PEXPOSURE   -0.01768  0.02886  0.04981  0.07205  0.11808 #> PCTAGE65P    2.28982  3.12634  3.60888  4.03227  4.88549 #> PCTOWNHOME  -0.74664 -0.54787 -0.40497 -0.28735 -0.03815 #>  lsar1 <- lagsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, type=\"mixed\") summary(lsar1) #>  #> Call:lagsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, type = \"mixed\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.799308 -0.390125 -0.021371  0.346128  3.965251  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>                  Estimate Std. Error z value  Pr(>|z|) #> (Intercept)     -1.131233   0.249631 -4.5316 5.853e-06 #> PEXPOSURE        0.218364   0.079301  2.7536  0.005894 #> PCTAGE65P        3.361158   0.654123  5.1384 2.771e-07 #> PCTOWNHOME       0.071903   0.253967  0.2831  0.777085 #> lag.(Intercept)  0.132544   0.056175  2.3595  0.018300 #> lag.PEXPOSURE   -0.035239   0.015536 -2.2681  0.023322 #> lag.PCTAGE65P    0.161685   0.223690  0.7228  0.469798 #> lag.PCTOWNHOME  -0.140681   0.058529 -2.4036  0.016234 #>  #> Rho: 0.026981, LR test value: 2.558, p-value: 0.10974 #> Asymptotic standard error: 0.016766 #>     z-value: 1.6093, p-value: 0.10755 #> Wald statistic: 2.5899, p-value: 0.10755 #>  #> Log likelihood: -269.1031 for mixed model #> ML residual variance (sigma squared): 0.39587, (sigma: 0.62918) #> Number of observations: 281  #> Number of parameters estimated: 10  #> AIC: 558.21, (AIC for lm: 558.76) #> LM test for residual autocorrelation #> test value: 4.908, p-value: 0.026732 #>  res <- MCMCsamp(lsar1, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                     Mean      SD  Naive SE Time-series SE #> rho              0.02471 0.01629 0.0002304       0.001219 #> (Intercept)     -1.12989 0.24291 0.0034353       0.017687 #> PEXPOSURE        0.21704 0.08665 0.0012254       0.007356 #> PCTAGE65P        3.40551 0.61299 0.0086689       0.043441 #> PCTOWNHOME       0.04146 0.25683 0.0036321       0.019859 #> lag.(Intercept)  0.12868 0.05650 0.0007991       0.004535 #> lag.PEXPOSURE   -0.03472 0.01732 0.0002449       0.001526 #> lag.PCTAGE65P    0.17214 0.20763 0.0029364       0.015671 #> lag.PCTOWNHOME  -0.13618 0.06186 0.0008749       0.005326 #>  #> 2. Quantiles for each variable: #>  #>                      2.5%      25%      50%      75%     97.5% #> rho             -0.008938  0.01339  0.02554  0.03617  0.054650 #> (Intercept)     -1.604105 -1.28894 -1.12504 -0.97119 -0.660270 #> PEXPOSURE        0.053725  0.15881  0.21725  0.27236  0.389018 #> PCTAGE65P        2.213387  2.99625  3.42281  3.85452  4.551724 #> PCTOWNHOME      -0.451879 -0.14346  0.04721  0.22476  0.545593 #> lag.(Intercept)  0.019705  0.09016  0.13030  0.16767  0.243720 #> lag.PEXPOSURE   -0.067460 -0.04719 -0.03527 -0.02388  0.003145 #> lag.PCTAGE65P   -0.238603  0.04557  0.17728  0.29777  0.562834 #> lag.PCTOWNHOME  -0.246111 -0.18197 -0.13460 -0.09357 -0.018730 #>  ssar0 <- sacsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY) summary(ssar0) #>  #> Call:sacsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.468382 -0.375687 -0.034996  0.314714  3.833950  #>  #> Type: sac  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.386572   0.123188 -3.1381  0.001701 #> PEXPOSURE    0.026684   0.024013  1.1112  0.266479 #> PCTAGE65P    3.089824   0.562851  5.4896 4.029e-08 #> PCTOWNHOME  -0.323052   0.137449 -2.3503  0.018756 #>  #> Rho: 0.089451 #> Asymptotic standard error: 0.019427 #>     z-value: 4.6046, p-value: 4.1325e-06 #> Lambda: -0.08192 #> Asymptotic standard error: 0.033201 #>     z-value: -2.4674, p-value: 0.01361 #>  #> LR test value: 10.114, p-value: 0.0063661 #>  #> Log likelihood: -273.672 for sac model #> ML residual variance (sigma squared): 0.3766, (sigma: 0.61368) #> Number of observations: 281  #> Number of parameters estimated: 7  #> AIC: 561.34, (AIC for lm: 567.46) #>  res <- MCMCsamp(ssar0, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD Naive SE Time-series SE #> rho         -0.04897 0.07268 0.001028        0.02171 #> lambda       0.07158 0.07109 0.001005        0.01911 #> (Intercept) -0.79253 0.30171 0.004267        0.05929 #> PEXPOSURE    0.12518 0.08005 0.001132        0.01428 #> PCTAGE65P    3.33373 0.62239 0.008802        0.04114 #> PCTOWNHOME  -0.24558 0.24700 0.003493        0.03231 #>  #> 2. Quantiles for each variable: #>  #>                  2.5%      25%      50%        75%    97.5% #> rho         -0.148205 -0.10220 -0.07484 -0.0003653  0.09879 #> lambda      -0.097739  0.03709  0.10543  0.1218063  0.13809 #> (Intercept) -1.371833 -1.01584 -0.80342 -0.5327538 -0.26199 #> PEXPOSURE   -0.001867  0.05674  0.12102  0.1859304  0.27450 #> PCTAGE65P    2.139989  2.91933  3.33752  3.7143648  4.58803 #> PCTOWNHOME  -0.743597 -0.40260 -0.25567 -0.0792356  0.24964 #>  ssar1 <- sacsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, type=\"sacmixed\") summary(ssar1) #>  #> Call:sacsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, type = \"sacmixed\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.633958 -0.363826 -0.019927  0.348238  3.655509  #>  #> Type: sacmixed  #> Coefficients: (asymptotic standard errors)  #>                  Estimate Std. Error z value  Pr(>|z|) #> (Intercept)     -1.133298   0.247495 -4.5791 4.670e-06 #> PEXPOSURE        0.206963   0.074480  2.7788  0.005456 #> PCTAGE65P        3.083983   0.671081  4.5955 4.316e-06 #> PCTOWNHOME       0.174800   0.256280  0.6821  0.495196 #> lag.(Intercept)  0.153427   0.050817  3.0192  0.002534 #> lag.PEXPOSURE   -0.033400   0.013817 -2.4173  0.015634 #> lag.PCTAGE65P   -0.079738   0.222144 -0.3589  0.719634 #> lag.PCTOWNHOME  -0.102502   0.056760 -1.8059  0.070940 #>  #> Rho: 0.092495 #> Asymptotic standard error: 0.023829 #>     z-value: 3.8817, p-value: 0.00010375 #> Lambda: -0.091069 #> Asymptotic standard error: 0.038431 #>     z-value: -2.3697, p-value: 0.017804 #>  #> LR test value: 22.379, p-value: 0.0010335 #>  #> Log likelihood: -267.5392 for sacmixed model #> ML residual variance (sigma squared): 0.35617, (sigma: 0.5968) #> Number of observations: 281  #> Number of parameters estimated: 11  #> AIC: 557.08, (AIC for lm: 567.46) #>  res <- MCMCsamp(ssar1, mcmc=5000, burnin=500, listw=listw_NY) summary(res) #>  #> Iterations = 1:5000 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 5000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                      Mean      SD  Naive SE Time-series SE #> rho             -0.005935 0.06247 0.0008835       0.012391 #> lambda           0.025149 0.06578 0.0009302       0.012564 #> (Intercept)     -1.104966 0.25946 0.0036694       0.020691 #> PEXPOSURE        0.220056 0.08072 0.0011415       0.006564 #> PCTAGE65P        3.448064 0.68477 0.0096841       0.053253 #> PCTOWNHOME       0.002352 0.25423 0.0035954       0.018914 #> lag.(Intercept)  0.107623 0.06651 0.0009406       0.007925 #> lag.PEXPOSURE   -0.034004 0.01609 0.0002276       0.001352 #> lag.PCTAGE65P    0.279208 0.31780 0.0044943       0.037387 #> lag.PCTOWNHOME  -0.134012 0.06451 0.0009123       0.005533 #>  #> 2. Quantiles for each variable: #>  #>                     2.5%      25%       50%      75%     97.5% #> rho             -0.10755 -0.05711 -0.014110  0.05341  0.099104 #> lambda          -0.09950 -0.03206  0.037324  0.08249  0.118177 #> (Intercept)     -1.60962 -1.28203 -1.096564 -0.93087 -0.597130 #> PEXPOSURE        0.05429  0.16818  0.217623  0.27874  0.368060 #> PCTAGE65P        2.11661  3.00219  3.455553  3.93036  4.829667 #> PCTOWNHOME      -0.46367 -0.19124 -0.002169  0.17287  0.544393 #> lag.(Intercept) -0.02153  0.05985  0.109887  0.15841  0.231289 #> lag.PEXPOSURE   -0.06423 -0.04610 -0.033598 -0.02331 -0.001144 #> lag.PCTAGE65P   -0.29223  0.02822  0.266936  0.50401  0.926973 #> lag.PCTOWNHOME  -0.26326 -0.17692 -0.130161 -0.08812 -0.009731 #>  # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/ME.html","id":null,"dir":"Reference","previous_headings":"","what":"Moran eigenvector GLM filtering — ME","title":"Moran eigenvector GLM filtering — ME","text":"Moran eigenvector filtering function intended remove spatial autocorrelation residuals generalised linear models. uses brute force eigenvector selection reach subset vectors added RHS GLM model reduce residual autocorrelation specified alpha value. Since eigenvector selection works symmetric weights, weights made symmetric eigenvectors found (spdep 0.5-50).","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ME.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moran eigenvector GLM filtering — ME","text":"","code":"ME(formula, data=list(), family = gaussian, weights, offset,  na.action=na.fail,listw=NULL, alpha=0.05, nsim=99, verbose=NULL,  stdev=FALSE, zero.policy=NULL)"},{"path":"https://r-spatial.github.io/spatialreg/reference/ME.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moran eigenvector GLM filtering — ME","text":"formula symbolic description model fit data optional data frame containing variables model family description error distribution link function           used model weights optional vector weights used fitting process offset can used specify priori known component included linear predictor fitting na.action function (default options(\"na.action\")), can also na.omit na.exclude consequences residuals fitted values - cases spatial weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. listw listw object created example nb2listw alpha used stopping rule choose eigenvectors including one p-value exceeding alpha nsim number permutations permutation bootstrap finding p-values verbose default NULL, use global option value; TRUE report eigenvectors selected stdev TRUE, p-value calculated bootstrap permutation standard deviate using pnorm alternative=\"greater\", FALSE Hope-type p-value zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ME.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Moran eigenvector GLM filtering — ME","text":"eigenvectors inclusion chosen calculating empirical Moran's values initial model plus doubly centred symmetric spatial weights matrix eigenvectors turn. first eigenvector chosen lowest Moran's value. procedure repeated lowest remaining Moran's value permutation-based probability value alpha. probability value either Hope-type based using mean standard deviation permutations calculate ZI based stdev argument.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ME.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moran eigenvector GLM filtering — ME","text":"object class Me_res: selection matrix summarising selection eigenvectors inclusion, columns: Eigenvector number selected eigenvector ZI permutation-based standardized deviate Moran's stdev=TRUE pr(ZI) probability value: stdev=TRUE permutation-based standardized deviate, FALSE Hope-type probability value, cases -sided first row value start search vectors matrix selected eigenvectors order selection","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ME.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Moran eigenvector GLM filtering — ME","text":"Dray S, Legendre P Peres-Neto PR (2005) Spatial modeling: comprehensive framework principle coordinate analysis neigbbor matrices (PCNM), Ecological Modelling; Griffith DA Peres-Neto PR (2006) Spatial modeling ecology: flexibility eigenfunction spatial analyses.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ME.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Moran eigenvector GLM filtering — ME","text":"Roger Bivand Pedro Peres-Neto","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/ME.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Moran eigenvector GLM filtering — ME","text":"","code":"#require(\"spdep\", quietly=TRUE) data(hopkins, package=\"spData\") hopkins_part <- hopkins[21:36,36:21] hopkins_part[which(hopkins_part > 0, arr.ind=TRUE)] <- 1 hopkins.rook.nb <- spdep::cell2nb(16, 16, type=\"rook\") glmbase <- glm(c(hopkins_part) ~ 1, family=\"binomial\") lw <- spdep::nb2listw(hopkins.rook.nb, style=\"B\") set.seed(123) system.time(MEbinom1 <- ME(c(hopkins_part) ~ 1, family=\"binomial\",  listw=lw, alpha=0.05, verbose=TRUE, nsim=49)) #> eV[,1], I: 0.08290518 ZI: NA, pr(ZI): 0.04 #> eV[,9], I: 0.06426565 ZI: NA, pr(ZI): 0.14 #>    user  system elapsed  #>   1.258   0.007   1.272  glmME <- glm(c(hopkins_part) ~ 1 + fitted(MEbinom1), family=\"binomial\") #anova(glmME, test=\"Chisq\") coef(summary(glmME)) #>                       Estimate Std. Error   z value     Pr(>|z|) #> (Intercept)          -1.146132  0.1542253 -7.431543 1.073378e-13 #> fitted(MEbinom1)vec1  8.293309  2.4532307  3.380566 7.233663e-04 #> fitted(MEbinom1)vec9  5.215112  2.3949596  2.177537 2.944054e-02 anova(glmbase, glmME, test=\"Chisq\") #> Analysis of Deviance Table #>  #> Model 1: c(hopkins_part) ~ 1 #> Model 2: c(hopkins_part) ~ 1 + fitted(MEbinom1) #>   Resid. Df Resid. Dev Df Deviance  Pr(>Chi)     #> 1       255     292.23                           #> 2       253     275.39  2   16.841 0.0002203 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 # \\dontrun{ require(\"sf\", quietly=TRUE) columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) #require(\"spdep\", quietly=TRUE) col.gal.nb <- spdep::read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) lw <- spdep::nb2listw(col.gal.nb) lmbase <- lm(CRIME ~ INC + HOVAL, data=columbus) lagcol <- SpatialFiltering(CRIME ~ 1, ~ INC + HOVAL, data=columbus,  nb=col.gal.nb, style=\"W\", alpha=0.1, verbose=TRUE) #> Step 0 SelEvec 0 MinMi 0.2123742 ZMinMi 2.681 Pr(ZI) 0.007340246  #> Step 1 SelEvec 6 MinMi 0.1178225 ZMinMi 1.84512 Pr(ZI) 0.06502014  #> Step 2 SelEvec 4 MinMi 0.06242664 ZMinMi 1.494821 Pr(ZI) 0.1349611  lagcol #>   Step SelEvec      Eval      MinMi   ZMinMi      Pr(ZI)        R2    gamma #> 0    0       0 0.0000000 0.21237415 2.681000 0.007340246 0.5524040  0.00000 #> 1    1       6 0.7161123 0.11782248 1.845120 0.065020139 0.6038801 25.46181 #> 2    2       4 0.8682938 0.06242664 1.494821 0.134961136 0.6531288 26.68319 lmlag <- lm(CRIME ~ INC + HOVAL + fitted(lagcol), data=columbus) anova(lmbase, lmlag) #> Analysis of Variance Table #>  #> Model 1: CRIME ~ INC + HOVAL #> Model 2: CRIME ~ INC + HOVAL + fitted(lagcol) #>   Res.Df    RSS Df Sum of Sq      F   Pr(>F)    #> 1     46 6014.9                                 #> 2     44 4661.3  2    1353.6 6.3884 0.003666 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 set.seed(123) system.time(lagcol1 <- ME(CRIME ~ INC + HOVAL, data=columbus, family=\"gaussian\",  listw=lw, alpha=0.1, verbose=TRUE)) #> eV[,6], I: 0.1178225 ZI: NA, pr(ZI): 0.08 #> eV[,4], I: 0.06242664 ZI: NA, pr(ZI): 0.27 #>    user  system elapsed  #>   0.528   0.000   0.532  lagcol1 #>   Eigenvector ZI pr(ZI) #> 0          NA NA   0.01 #> 1           6 NA   0.08 #> 2           4 NA   0.27 lmlag1 <- lm(CRIME ~ INC + HOVAL + fitted(lagcol1), data=columbus) anova(lmbase, lmlag1) #> Analysis of Variance Table #>  #> Model 1: CRIME ~ INC + HOVAL #> Model 2: CRIME ~ INC + HOVAL + fitted(lagcol1) #>   Res.Df    RSS Df Sum of Sq      F   Pr(>F)    #> 1     46 6014.9                                 #> 2     44 4661.3  2    1353.6 6.3884 0.003666 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1  set.seed(123) lagcol2 <- ME(CRIME ~ INC + HOVAL, data=columbus, family=\"gaussian\",  listw=lw, alpha=0.1, stdev=TRUE, verbose=TRUE) #> eV[,6], I: 0.1178225 ZI: 1.5509, pr(ZI): 0.06046283 #> eV[,4], I: 0.06242664 ZI: 0.681174, pr(ZI): 0.2478807 lagcol2 #>   Eigenvector       ZI      pr(ZI) #> 0          NA 2.351591 0.009346653 #> 1           6 1.550900 0.060462832 #> 2           4 0.681174 0.247880696 lmlag2 <- lm(CRIME ~ INC + HOVAL + fitted(lagcol2), data=columbus) anova(lmbase, lmlag2) #> Analysis of Variance Table #>  #> Model 1: CRIME ~ INC + HOVAL #> Model 2: CRIME ~ INC + HOVAL + fitted(lagcol2) #>   Res.Df    RSS Df Sum of Sq      F   Pr(>F)    #> 1     46 6014.9                                 #> 2     44 4661.3  2    1353.6 6.3884 0.003666 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 NA.columbus <- columbus NA.columbus$CRIME[20:25] <- NA COL.ME.NA <- ME(CRIME ~ INC + HOVAL, data=NA.columbus, family=\"gaussian\",  listw=lw, alpha=0.1, stdev=TRUE, verbose=TRUE,  na.action=na.exclude) #> Warning: subsetting caused increase in subgraph count #> eV[,8], I: 0.1426723 ZI: 1.483169, pr(ZI): 0.06901474 #> eV[,1], I: 0.09838877 ZI: 0.9862904, pr(ZI): 0.1619953 COL.ME.NA$na.action #> 20 21 22 23 24 25  #> 20 21 22 23 24 25  #> attr(,\"class\") #> [1] \"exclude\" summary(lm(CRIME ~ INC + HOVAL + fitted(COL.ME.NA), data=NA.columbus,  na.action=na.exclude)) #>  #> Call: #> lm(formula = CRIME ~ INC + HOVAL + fitted(COL.ME.NA), data = NA.columbus,  #>     na.action = na.exclude) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -30.1382  -6.0105   0.4095   7.1504  19.9399  #>  #> Coefficients: #>                    Estimate Std. Error t value Pr(>|t|)     #> (Intercept)        66.92248    5.28663  12.659 3.33e-15 *** #> INC                -1.40484    0.35678  -3.938  0.00034 *** #> HOVAL              -0.30446    0.09831  -3.097  0.00366 **  #> fitted(COL.ME.NA)1 29.69422   10.58481   2.805  0.00788 **  #> fitted(COL.ME.NA)2 26.61612   11.29187   2.357  0.02367 *   #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 10.48 on 38 degrees of freedom #>   (6 observations deleted due to missingness) #> Multiple R-squared:  0.6294,\tAdjusted R-squared:  0.5904  #> F-statistic: 16.13 on 4 and 38 DF,  p-value: 8.353e-08 #>  nc.sids <- st_read(system.file(\"shapes/sids.gpkg\", package=\"spData\")[1], quiet=TRUE) rn <- as.character(nc.sids$FIPS) ncCC89_nb <- spdep::read.gal(system.file(\"weights/ncCC89.gal\", package=\"spData\")[1],  region.id=rn) #> Warning: neighbour object has 3 sub-graphs ncCR85_nb <- spdep::read.gal(system.file(\"weights/ncCR85.gal\", package=\"spData\")[1],  region.id=rn) glmbase <- glm(SID74 ~ 1, data=nc.sids, offset=log(BIR74),  family=\"poisson\") set.seed(123) MEpois1 <- ME(SID74 ~ 1, data=nc.sids, offset=log(BIR74),  family=\"poisson\", listw=spdep::nb2listw(ncCR85_nb, style=\"B\"), alpha=0.2, verbose=TRUE) #> eV[,1], I: 0.1327384 ZI: NA, pr(ZI): 0.03 #> eV[,8], I: 0.06936385 ZI: NA, pr(ZI): 0.12 #> eV[,4], I: 0.03584503 ZI: NA, pr(ZI): 0.3 MEpois1 #>   Eigenvector ZI pr(ZI) #> 0          NA NA   0.01 #> 1           1 NA   0.03 #> 2           8 NA   0.12 #> 3           4 NA   0.30 glmME <- glm(SID74 ~ 1 + fitted(MEpois1), data=nc.sids, offset=log(BIR74),  family=\"poisson\") anova(glmME, test=\"Chisq\") #> Analysis of Deviance Table #>  #> Model: poisson, link: log #>  #> Response: SID74 #>  #> Terms added sequentially (first to last) #>  #>  #>                 Df Deviance Resid. Df Resid. Dev  Pr(>Chi)     #> NULL                               99     203.34               #> fitted(MEpois1)  3   32.499        96     170.84 4.108e-07 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 anova(glmbase, glmME, test=\"Chisq\") #> Analysis of Deviance Table #>  #> Model 1: SID74 ~ 1 #> Model 2: SID74 ~ 1 + fitted(MEpois1) #>   Resid. Df Resid. Dev Df Deviance  Pr(>Chi)     #> 1        99     203.34                           #> 2        96     170.84  3   32.499 4.108e-07 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/ML_models.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial simultaneous autoregressive model estimation by maximum likelihood — ML_models","title":"Spatial simultaneous autoregressive model estimation by maximum likelihood — ML_models","text":"lagsarlm function provides Maximum likelihood estimation spatial simultaneous autoregressive lag spatial Durbin (mixed) models form: $$y = \\rho W y + X \\beta + \\varepsilon$$ \\(\\rho\\) found optimize() first, \\(\\beta\\) parameters generalized least squares subsequently (one-dimensional search using optim performs badly platforms). spatial Durbin (mixed) model, spatially lagged independent variables added X. Note interpretation fitted coefficients use impact measures, feedback loops induced data generation process model. one sparse matrix methods, larger numbers observations can handled, interval= argument may need set weights row-standardised. Maximum likelihood estimation spatial simultaneous autoregressive error models form: $$y = X \\beta + u, u = \\lambda W u + \\varepsilon$$ \\(\\lambda\\) found optimize() first, \\(\\beta\\) parameters generalized least squares subsequently. one sparse matrix methods, larger numbers observations can handled, interval= argument may need set weights row-standardised. etype “emixed”, -called spatial Durbin error model fitted. Maximum likelihood estimation spatial simultaneous autoregressive “SAC/SARAR” models form: $$y = \\rho W1 y + X \\beta + u, u = \\lambda W2 u + \\varepsilon$$ \\(\\rho\\) \\(\\lambda\\) found nlminb optim() first, \\(\\beta\\) parameters generalized least squares subsequently.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ML_models.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial simultaneous autoregressive model estimation by maximum likelihood — ML_models","text":"","code":"lagsarlm(formula, data = list(), listw, na.action, Durbin, type,  method=\"eigen\", quiet=NULL, zero.policy=NULL, interval=NULL,  tol.solve=.Machine$double.eps, trs=NULL, control=list()) errorsarlm(formula, data=list(), listw, na.action, weights=NULL,  Durbin, etype, method=\"eigen\", quiet=NULL, zero.policy=NULL,  interval = NULL, tol.solve=.Machine$double.eps, trs=NULL, control=list()) sacsarlm(formula, data = list(), listw, listw2 = NULL, na.action, Durbin, type,  method=\"eigen\", quiet=NULL, zero.policy=NULL, tol.solve=.Machine$double.eps,  llprof=NULL, interval1=NULL, interval2=NULL, trs1=NULL, trs2=NULL,  control = list()) # S3 method for class 'Sarlm' summary(object, correlation = FALSE, Nagelkerke = FALSE,  Hausman=FALSE, adj.se=FALSE, ...) # S3 method for class 'Sarlm' print(x, ...) # S3 method for class 'summary.Sarlm' print(x, digits = max(5, .Options$digits - 3),  signif.stars = FALSE, ...) # S3 method for class 'Sarlm' residuals(object, ...) # S3 method for class 'Sarlm' deviance(object, ...) # S3 method for class 'Sarlm' coef(object, ...) # S3 method for class 'Sarlm' vcov(object, ...) # S3 method for class 'Sarlm' fitted(object, ...)"},{"path":"https://r-spatial.github.io/spatialreg/reference/ML_models.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial simultaneous autoregressive model estimation by maximum likelihood — ML_models","text":"formula symbolic description model fit. details model specification given lm() data optional data frame containing variables model. default variables taken environment function called. listw, listw2 listw object created example nb2listw; nb2listw given, set spatial weights listw argument na.action function (default options(\"na.action\")), can also na.omit na.exclude consequences residuals fitted values - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. weights optional vector weights used fitting process. Non-NULL weights can used indicate different observations different variances (values weights inversely proportional variances); equivalently, elements weights positive integers w_i, response y_i mean w_i unit-weight observations (including case w_i observations equal y_i data summarized) - lm Durbin default FALSE (spatial lag model); TRUE, full spatial Durbin model; formula object, subset explanatory variables lag type (use ‘Durbin=’ argument - retained backwards compatibility ) default \"lag\", may set \"mixed\"; \"mixed\", lagged intercept dropped spatial weights style \"W\", row-standardised weights, otherwise included; “Durbin” may used instead “mixed” etype (use ‘Durbin=’ argument - retained backwards compatibility ) default \"error\", may set \"emixed\" include spatially lagged independent variables added X; \"emixed\", lagged intercept dropped spatial weights style \"W\", row-standardised weights, otherwise included method \"eigen\" (default) - Jacobian computed product (1 - rho*eigenvalue) using eigenw, \"spam\" \"Matrix_J\" strictly symmetric weights lists styles \"B\" \"C\", made symmetric similarity (Ord, 1975, Appendix C) possible styles \"W\" \"S\", using code spam Matrix packages calculate determinant; “Matrix” “spam_update” provide updating Cholesky decomposition methods; \"LU\" provides alternative sparse matrix decomposition approach. addition, \"Chebyshev\" Monte Carlo \"MC\" approximate log-determinant methods; Smirnov/Anselin (2009) trace approximation available \"moments\". Three methods: \"SE_classic\", \"SE_whichMin\", \"SE_interp\" provided experimentally, first attempt emulate behaviour Spatial Econometrics toolbox ML fitting functions. use grids log determinant values, latter two attempt ameliorate features \"SE_classic\". quiet default NULL, use !verbose global option value; FALSE, reports function values optimization. zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE (default) assign NA - causing lagsarlm() terminate error interval default NULL, search interval autoregressive parameter tol.solve tolerance detecting linear dependencies columns matrices inverted - passed solve() (default=1.0e-10). may used necessary extract coefficient standard errors (instance lowering 1e-12), errors solve() may constitute indications poorly scaled variables: variables scales differing much autoregressive coefficient, values matrix may different scale, inverting matrix analytically possible definition, numerically unstable; rescaling RHS variables alleviates better setting tol.solve small value llprof default NULL, can either integer, divide feasible ranges grid points, two-column matrix spatial coefficient values, evaluate likelihood function trs1, trs2 default NULL, given, vectors weights object powered spatial weights matrix traces output trW; given, used Jacobian methods interval1, interval2 default NULL, search intervals weights object autoregressive parameters trs default NULL, given, vector powered spatial weights matrix traces output trW; given, insert asymptotic analytical values numerical Hessian instead approximated values; may used get around problems raised numerical Hessian poorly conditioned, generating NaNs subsequent operations; use trs recommended control list extra control arguments - see section object Sarlm object lagsarlm, errorsarlm sacsarlm correlation logical; 'TRUE', correlation matrix estimated parameters including sigma returned printed (default=FALSE) Nagelkerke TRUE, Nagelkerke pseudo R-squared reported Hausman TRUE, results Hausman test error models reported adj.se TRUE, adjust coefficient standard errors number fitted coefficients x Sarlm object lagsarlm, errorsarlm sacsarlm print.Sarlm, summary object summary.Sarlm print.summary.Sarlm digits number significant digits use printing signif.stars logical. TRUE, \"significance stars\" printed           coefficient. ... arguments passed methods","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ML_models.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial simultaneous autoregressive model estimation by maximum likelihood — ML_models","text":"asymptotic standard error \\(\\rho\\) computed method=“eigen”, full matrix operations involved costly large n typically associated choice method=\"spam\" \"Matrix\". applies coefficient covariance matrix. Taken asymptotic matrix literature, typically badly scaled, elements involving \\(\\rho\\) (lag model) \\(\\lambda\\) (error model) small, parts matrix can large (often many orders magnitude difference). often happens tol.solve argument needs set smaller value default, RHS variables can centred reduced range. Versions package 0.4-38 include numerical Hessian values asymptotic standard errors available. change introduced permit simulation distributions impact measures. warnings made regard variable scaling also apply case. Note fitted() function output object assumes response variable may reconstructed sum trend, signal, noise (residuals). Since values response variable known, spatial lags used calculate signal components (Cressie 1993, p. 564). differs software, including GeoDa, use knowledge response variable making predictions fitting data. Refer help page predict.Sarlm discussions references. numerical optimisation used find values lambda rho sacsarlm, care needs shown. found surface 2D likelihood function often forms “banana trench” (low rho, high lambda) (high rho, high lambda) (high rho, low lambda) values. addition, sometimes banana optima towards ends, one local, global, conseqently choice starting point final optimization becomes crucial. default approach use just (0, 0) starting point, (rho, lambda) values gstsls, lie central part “trench”, either four values (low rho, high lambda), (0, 0), (high rho, high lambda), (high rho, low lambda), use best start points final optimization. Optionally, nine points can used spanning whole (lower, upper) space.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ML_models.html","id":"control-arguments","dir":"Reference","previous_headings":"","what":"Control arguments","title":"Spatial simultaneous autoregressive model estimation by maximum likelihood — ML_models","text":"tol.opt: desired accuracy optimization - passed optimize() (default=square root double precision machine tolerance, larger root may used needed, see help(boston) example) returnHcov: (error model) default TRUE, return Vo matrix spatial Hausman test pWOrder: (error model) default 250, returnHcov=TRUE method “eigen”, pass order powerWeights power series maximum limit fdHess: default NULL, set (method != \"eigen\") internally; use fdHess compute approximate Hessian using finite differences using sparse matrix methods; used make coefficient covariance matrix number observations large; may turned save resources need optimHess: default FALSE, use fdHess nlme, TRUE, use optim calculate Hessian optimum optimHessMethod: default “optimHess”, may “nlm” one optim methods compiled_sse: default FALSE; logical value used log likelihood function choose compiled code computing SSE Imult: default 2; used preparing Cholesky decompositions updating Jacobian function super: NULL (default), set FALSE use simplicial decomposition sparse Cholesky decomposition method “Matrix_J”, set  .logical(NA) method “Matrix”, TRUE, use supernodal decomposition cheb_q: default 5; highest power approximating polynomial Chebyshev approximation MC_p: default 16; number random variates MC_m: default 30; number products random variates matrix spatial weights matrix spamPivot: default “MMD”, alternative “RCM” in_coef default 0.1, coefficient value initial Cholesky decomposition “spam_update” type default “MC”, used method “moments”; alternatives “mult” “moments”, use trs missing, trW correct default TRUE, used method “moments” compute Smirnov/Anselin correction term trunc default TRUE, used method “moments” truncate Smirnov/Anselin correction term SE_method default “LU”, may “MC” nrho default 200, SE toolbox; size first stage lndet grid; may reduced example 40 interpn default 2000, SE toolbox; size second stage lndet grid small_asy default TRUE; method “eigen”, use asymmetric covariances rather numerical Hessian ones n <= small small default 1500; threshold number observations asymmetric covariances method “eigen” SElndet default NULL, may used pass pre-computed SE toolbox style matrix coefficients lndet values \"SE_classic\" \"SE_whichMin\" methods LU_order default FALSE; used “LU_prepermutate”, note warnings given lu method pre_eig default NULL; may used pass pre-computed vector eigenvalues return_impacts default TRUE; may set FALSE avoid problems calculating impacts aliased variables OrdVsign default 1; used set sign final component negative -1 (alpha times ((sigma squared) squared) Ord (1975) equation B.1). opt_method: default “nlminb”, may set “L-BFGS-B” use box-constrained optimisation optim opt_control: default list(), control list pass nlminb optim pars: default NULL, five trial starting values spanning lower/upper range tried best selected, starting values \\(\\rho\\) \\(\\lambda\\) npars default integer 4L, four trial points; default value, nine trial points pre_eig1, pre_eig2 default NULL; may used pass pre-computed vectors eigenvalues","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ML_models.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial simultaneous autoregressive model estimation by maximum likelihood — ML_models","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion; Ord, J. K. 1975 Estimation methods models spatial interaction, Journal American Statistical Association, 70, 120-126; Anselin, L. 1988 Spatial econometrics: methods models. (Dordrecht: Kluwer); Anselin, L. 1995 SpaceStat, software program analysis spatial data, version 1.80. Regional Research Institute, West Virginia University, Morgantown, WV; Anselin L, Bera AK (1998) Spatial dependence linear regression models introduction spatial econometrics. : Ullah , Giles DEA (eds) Handbook applied economic statistics. Marcel Dekker, New York, pp. 237-289; Nagelkerke NJD (1991) note general definition coefficient determination. Biometrika 78: 691-692; Cressie, N. . C. 1993 Statistics spatial data, Wiley, New York; LeSage J RK Pace (2009) Introduction Spatial Econometrics. CRC Press, Boca Raton. Roger Bivand, Gianfranco Piras (2015). Comparing Implementations Estimation Methods Spatial Econometrics. Journal Statistical Software, 63(18), 1-36. doi:10.18637/jss.v063.i18 . Bivand, R. S., Hauke, J., Kossowski, T. (2013). Computing Jacobian Gaussian spatial autoregressive models: illustrated comparison available methods. Geographical Analysis, 45(2), 150-179.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/ML_models.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial simultaneous autoregressive model estimation by maximum likelihood — ML_models","text":"Roger Bivand Roger.Bivand@nhh., thanks Andrew Bernat contributions asymptotic standard error code.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/ML_models.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial simultaneous autoregressive model estimation by maximum likelihood — ML_models","text":"","code":"data(oldcol, package=\"spdep\") listw <- spdep::nb2listw(COL.nb, style=\"W\") ev <- eigenw(listw) W <- as(listw, \"CsparseMatrix\") trMatc <- trW(W, type=\"mult\") COL.lag.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, listw=listw,  method=\"eigen\", quiet=FALSE, control=list(pre_eig=ev, OrdVsign=1)) #>  #> Spatial lag model #> Jacobian calculated using neighbourhood matrix eigenvalues #>  #> rho:\t -0.5674437 \tfunction value:\t -202.2909  #> rho:\t 0.03126655 \tfunction value:\t -186.749  #> rho:\t 0.4012898 \tfunction value:\t -182.419  #> rho:\t 0.6138418 \tfunction value:\t -183.5636  #> rho:\t 0.4157662 \tfunction value:\t -182.398  #> rho:\t 0.4295565 \tfunction value:\t -182.3905  #> rho:\t 0.4311288 \tfunction value:\t -182.3904  #> rho:\t 0.4310273 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  (x <- summary(COL.lag.eig, correlation=TRUE)) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     method = \"eigen\", quiet = FALSE, control = list(pre_eig = ev,  #>         OrdVsign = 1)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.68585  -5.35636   0.05421   6.02013  23.20555  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.079249   7.177346  6.2808 3.369e-10 #> INC         -1.031616   0.305143 -3.3808 0.0007229 #> HOVAL       -0.265926   0.088499 -3.0049 0.0026570 #>  #> Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588 #> Asymptotic standard error: 0.11768 #>     z-value: 3.6626, p-value: 0.00024962 #> Wald statistic: 13.415, p-value: 0.00024962 #>  #> Log likelihood: -182.3904 for lag model #> ML residual variance (sigma squared): 95.494, (sigma: 9.7721) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 374.78, (AIC for lm: 382.75) #> LM test for residual autocorrelation #> test value: 0.31954, p-value: 0.57188 #>  #>  Correlation of coefficients  #>             sigma rho   (Intercept) INC   #> rho         -0.14                         #> (Intercept)  0.12 -0.83                   #> INC         -0.05  0.35 -0.61             #> HOVAL       -0.01  0.08 -0.25       -0.44 #>  coef(x) #>               Estimate Std. Error   z value     Pr(>|z|) #> (Intercept) 45.0792493 7.17734647  6.280768 3.369043e-10 #> INC         -1.0316157 0.30514297 -3.380762 7.228519e-04 #> HOVAL       -0.2659263 0.08849862 -3.004863 2.657002e-03 # \\dontrun{ COL.lag.eig$fdHess #> [1] FALSE COL.lag.eig$resvar #>                    sigma           rho (Intercept)         INC         HOVAL #> sigma       379.77510023 -0.3236306420  16.3015085 -0.29590802 -0.0202478469 #> rho          -0.32363064  0.0138487528  -0.6975717  0.01266245  0.0008664428 #> (Intercept)  16.30150847 -0.6975716519  51.5143024 -1.32602702 -0.1616379845 #> INC          -0.29590802  0.0126624508  -1.3260270  0.09311223 -0.0117959714 #> HOVAL        -0.02024785  0.0008664428  -0.1616380 -0.01179597  0.0078320057 # using the apparent sign in Ord (1975, equation B.1)  COL.lag.eigb <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, listw=listw,  method=\"eigen\", control=list(pre_eig=ev, OrdVsign=-1)) summary(COL.lag.eigb) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     method = \"eigen\", control = list(pre_eig = ev, OrdVsign = -1)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.68585  -5.35636   0.05421   6.02013  23.20555  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.079249   9.617835  4.6870 2.772e-06 #> INC         -1.031616   0.326524 -3.1594  0.001581 #> HOVAL       -0.265926   0.088855 -2.9928  0.002764 #>  #> Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588 #> Asymptotic standard error: 0.17322 #>     z-value: 2.4884, p-value: 0.012833 #> Wald statistic: 6.1919, p-value: 0.012833 #>  #> Log likelihood: -182.3904 for lag model #> ML residual variance (sigma squared): 95.494, (sigma: 9.7721) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 374.78, (AIC for lm: 382.75) #> LM test for residual autocorrelation #> test value: -0.93825, p-value: 1 #>  COL.lag.eigb$fdHess #> [1] FALSE COL.lag.eigb$resvar #>                    sigma          rho (Intercept)         INC        HOVAL #> sigma       388.59742708 -0.701154300  35.3176470 -0.64109252 -0.043867493 #> rho          -0.70115430  0.030003687  -1.5113073  0.02743353  0.001877171 #> (Intercept)  35.31764699 -1.511307337  92.5027548 -2.07005706 -0.212549096 #> INC          -0.64109252  0.027433533  -2.0700571  0.10661800 -0.010871823 #> HOVAL        -0.04386749  0.001877171  -0.2125491 -0.01087182  0.007895242 # force numerical Hessian COL.lag.eig1 <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw=listw, method=\"Matrix\", control=list(small=25)) summary(COL.lag.eig1) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     method = \"Matrix\", control = list(small = 25)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.68585  -5.35636   0.05421   6.02013  23.20555  #>  #> Type: lag  #> Coefficients: (numerical Hessian approximate standard errors)  #>             Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.07925    7.87142   5.727 1.022e-08 #> INC         -1.03162    0.32843  -3.141  0.001683 #> HOVAL       -0.26593    0.08823  -3.014  0.002578 #>  #> Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588 #> Approximate (numerical Hessian) standard error: 0.12363 #>     z-value: 3.4865, p-value: 0.00048934 #> Wald statistic: 12.156, p-value: 0.00048934 #>  #> Log likelihood: -182.3904 for lag model #> ML residual variance (sigma squared): 95.494, (sigma: 9.7721) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 374.78, (AIC for lm: 382.75) #>  COL.lag.eig1$fdHess #>                       rho (Intercept)         INC         HOVAL #> rho          0.0152832589  -0.8346578  0.02005909  0.0002832041 #> (Intercept) -0.8346577895  61.9591934 -1.78361966 -0.1334688151 #> INC          0.0200590872  -1.7836197  0.10786711 -0.0122201879 #> HOVAL        0.0002832041  -0.1334688 -0.01222019  0.0077846116 # force LeSage & Pace (2008, p. 57) approximation  COL.lag.eig1a <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw=listw, method=\"Matrix\", control=list(small=25), trs=trMatc) summary(COL.lag.eig1a) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     method = \"Matrix\", trs = trMatc, control = list(small = 25)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.68585  -5.35636   0.05421   6.02013  23.20555  #>  #> Type: lag  #> Coefficients: (numerical Hessian approximate standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.079249   7.937572  5.6792 1.353e-08 #> INC         -1.031616   0.329337 -3.1324  0.001734 #> HOVAL       -0.265926   0.088222 -3.0143  0.002576 #>  #> Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588 #> Approximate (numerical Hessian) standard error: 0.12503 #>     z-value: 3.4473, p-value: 0.00056624 #> Wald statistic: 11.884, p-value: 0.00056624 #>  #> Log likelihood: -182.3904 for lag model #> ML residual variance (sigma squared): 95.494, (sigma: 9.7721) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 374.78, (AIC for lm: 382.75) #>  COL.lag.eig1a$fdHess #>                    sigma2           rho (Intercept)         INC         HOVAL #> sigma2      380.749548407 -0.3653290756  19.9519208 -0.47947507 -0.0067851124 #> rho          -0.365329076  0.0156331058  -0.8537795  0.02051762  0.0002903475 #> (Intercept)  19.951920812 -0.8537795385  63.0050547 -1.80875071 -0.1338515483 #> INC          -0.479475072  0.0205176238  -1.8087507  0.10846276 -0.0122071279 #> HOVAL        -0.006785112  0.0002903475  -0.1338515 -0.01220713  0.0077831895 COL.lag.eig$resvar[2,2] #> [1] 0.01384875 # using the apparent sign in Ord (1975, equation B.1)  COL.lag.eigb$resvar[2,2] #> [1] 0.03000369 # force numerical Hessian COL.lag.eig1$fdHess[1,1] #> [1] 0.01528326 # force LeSage & Pace (2008, p. 57) approximation  COL.lag.eig1a$fdHess[2,2] #> [1] 0.01563311 # } system.time(COL.lag.M <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"Matrix\", quiet=FALSE)) #>  #> Spatial lag model #> Jacobian calculated using sparse matrix Cholesky decomposition #> rho:\t -0.2364499 \tfunction value:\t -192.9523  #> rho:\t 0.2354499 \tfunction value:\t -183.542  #> rho:\t 0.5271001 \tfunction value:\t -182.7039  #> rho:\t 0.4455543 \tfunction value:\t -182.3974  #> rho:\t 0.4267907 \tfunction value:\t -182.391  #> rho:\t 0.4311986 \tfunction value:\t -182.3904  #> rho:\t 0.4310114 \tfunction value:\t -182.3904  #> rho:\t 0.4310231 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> Computing eigenvalues ... #>  #>    user  system elapsed  #>   0.187   0.000   0.188  summary(COL.lag.M) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     method = \"Matrix\", quiet = FALSE) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.68585  -5.35636   0.05421   6.02013  23.20555  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.079249   7.177346  6.2808 3.369e-10 #> INC         -1.031616   0.305143 -3.3808 0.0007229 #> HOVAL       -0.265926   0.088499 -3.0049 0.0026570 #>  #> Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588 #> Asymptotic standard error: 0.11768 #>     z-value: 3.6626, p-value: 0.00024962 #> Wald statistic: 13.415, p-value: 0.00024962 #>  #> Log likelihood: -182.3904 for lag model #> ML residual variance (sigma squared): 95.494, (sigma: 9.7721) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 374.78, (AIC for lm: 382.75) #> LM test for residual autocorrelation #> test value: 0.31954, p-value: 0.57188 #>  impacts(COL.lag.M, listw=listw) #> Impact measures (lag, exact): #>           Direct   Indirect      Total #> INC   -1.0860220 -0.7270848 -1.8131068 #> HOVAL -0.2799509 -0.1874254 -0.4673763 # \\dontrun{ system.time(COL.lag.sp <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw=listw, method=\"spam\", quiet=FALSE)) #>  #> Spatial lag model #> Jacobian calculated using sparse matrix Cholesky decomposition #> rho:\t -0.2364499 \tfunction value:\t -192.9523  #> rho:\t 0.2354499 \tfunction value:\t -183.542  #> rho:\t 0.5271001 \tfunction value:\t -182.7039  #> rho:\t 0.4455543 \tfunction value:\t -182.3974  #> rho:\t 0.4267907 \tfunction value:\t -182.391  #> rho:\t 0.4311986 \tfunction value:\t -182.3904  #> rho:\t 0.4310114 \tfunction value:\t -182.3904  #> rho:\t 0.4310231 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> rho:\t 0.4310232 \tfunction value:\t -182.3904  #> Computing eigenvalues ... #>  #>    user  system elapsed  #>   0.449   0.003   0.454  summary(COL.lag.sp) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     method = \"spam\", quiet = FALSE) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.68585  -5.35636   0.05421   6.02013  23.20555  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.079250   7.177347  6.2808 3.369e-10 #> INC         -1.031616   0.305143 -3.3808 0.0007229 #> HOVAL       -0.265926   0.088499 -3.0049 0.0026570 #>  #> Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588 #> Asymptotic standard error: 0.11768 #>     z-value: 3.6626, p-value: 0.00024962 #> Wald statistic: 13.415, p-value: 0.00024962 #>  #> Log likelihood: -182.3904 for lag model #> ML residual variance (sigma squared): 95.494, (sigma: 9.7721) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 374.78, (AIC for lm: 382.75) #> LM test for residual autocorrelation #> test value: 0.31954, p-value: 0.57188 #>  COL.lag.B <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  spdep::nb2listw(COL.nb, style=\"B\"), control=list(pre_eig=ev)) summary(COL.lag.B) #>  #> Call: #> lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"B\"), control = list(pre_eig = ev)) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -33.6620  -4.8615  -1.3576   5.1567  25.7563  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 51.604815   6.075285  8.4942 < 2.2e-16 #> INC         -1.154463   0.301808 -3.8252 0.0001307 #> HOVAL       -0.251633   0.087612 -2.8721 0.0040773 #>  #> Rho: 0.054543, LR test value: 13.453, p-value: 0.00024461 #> Asymptotic standard error: 0.014836 #>     z-value: 3.6763, p-value: 0.00023662 #> Wald statistic: 13.515, p-value: 0.00023662 #>  #> Log likelihood: -180.6507 for lag model #> ML residual variance (sigma squared): 93.22, (sigma: 9.655) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 371.3, (AIC for lm: 382.75) #> LM test for residual autocorrelation #> test value: 0.006827, p-value: 0.93415 #>  COL.mixed.B <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  spdep::nb2listw(COL.nb, style=\"B\"), type=\"mixed\", tol.solve=1e-9,  control=list(pre_eig=ev)) summary(COL.mixed.B) #>  #> Call: #> lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"B\"), type = \"mixed\", tol.solve = 1e-09, control = list(pre_eig = ev)) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -34.8460  -4.2057  -0.1195   4.6525  21.6112  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>                    Estimate  Std. Error z value  Pr(>|z|) #> (Intercept)      5.4215e+01  5.6639e+00  9.5719 < 2.2e-16 #> INC             -8.2386e-01  3.1643e-01 -2.6036 0.0092262 #> HOVAL           -3.0085e-01  8.5629e-02 -3.5134 0.0004424 #> lag.(Intercept) -7.5493e+00  1.7307e+00 -4.3620 1.289e-05 #> lag.INC          2.1531e-05  1.2216e-01  0.0002 0.9998594 #> lag.HOVAL        7.2458e-02  3.9007e-02  1.8576 0.0632281 #>  #> Rho: 0.15212, LR test value: 7.435, p-value: 0.0063967 #> Asymptotic standard error: 0.015565 #>     z-value: 9.7735, p-value: < 2.22e-16 #> Wald statistic: 95.522, p-value: < 2.22e-16 #>  #> Log likelihood: -177.7722 for mixed model #> ML residual variance (sigma squared): 82.502, (sigma: 9.0831) #> Number of observations: 49  #> Number of parameters estimated: 8  #> AIC: 371.54, (AIC for lm: 376.98) #> LM test for residual autocorrelation #> test value: -26.79, p-value: 1 #>  COL.mixed.W <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, type=\"mixed\", control=list(pre_eig=ev)) summary(COL.mixed.W) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     type = \"mixed\", control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.47829  -6.46731  -0.33835   6.05200  22.62969  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 42.822414  12.667204  3.3806 0.0007233 #> INC         -0.914223   0.331094 -2.7612 0.0057586 #> HOVAL       -0.293738   0.089212 -3.2926 0.0009927 #> lag.INC     -0.520284   0.565129 -0.9206 0.3572355 #> lag.HOVAL    0.245640   0.178917  1.3729 0.1697756 #>  #> Rho: 0.42634, LR test value: 5.3693, p-value: 0.020494 #> Asymptotic standard error: 0.15623 #>     z-value: 2.7288, p-value: 0.0063561 #> Wald statistic: 7.4465, p-value: 0.0063561 #>  #> Log likelihood: -181.3935 for mixed model #> ML residual variance (sigma squared): 91.791, (sigma: 9.5808) #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 376.79, (AIC for lm: 380.16) #> LM test for residual autocorrelation #> test value: 0.28919, p-value: 0.59074 #>  COL.mixed.D00 <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, Durbin=TRUE, control=list(pre_eig=ev)) summary(COL.mixed.D00) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     Durbin = TRUE, control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.47829  -6.46731  -0.33835   6.05200  22.62969  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 42.822414  12.667204  3.3806 0.0007233 #> INC         -0.914223   0.331094 -2.7612 0.0057586 #> HOVAL       -0.293738   0.089212 -3.2926 0.0009927 #> lag.INC     -0.520284   0.565129 -0.9206 0.3572355 #> lag.HOVAL    0.245640   0.178917  1.3729 0.1697756 #>  #> Rho: 0.42634, LR test value: 5.3693, p-value: 0.020494 #> Asymptotic standard error: 0.15623 #>     z-value: 2.7288, p-value: 0.0063561 #> Wald statistic: 7.4465, p-value: 0.0063561 #>  #> Log likelihood: -181.3935 for mixed model #> ML residual variance (sigma squared): 91.791, (sigma: 9.5808) #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 376.79, (AIC for lm: 380.16) #> LM test for residual autocorrelation #> test value: 0.28919, p-value: 0.59074 #>  COL.mixed.D01 <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, Durbin=FALSE, control=list(pre_eig=ev)) summary(COL.mixed.D01) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     Durbin = FALSE, control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.68585  -5.35636   0.05421   6.02013  23.20555  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.079249   7.177346  6.2808 3.369e-10 #> INC         -1.031616   0.305143 -3.3808 0.0007229 #> HOVAL       -0.265926   0.088499 -3.0049 0.0026570 #>  #> Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588 #> Asymptotic standard error: 0.11768 #>     z-value: 3.6626, p-value: 0.00024962 #> Wald statistic: 13.415, p-value: 0.00024962 #>  #> Log likelihood: -182.3904 for lag model #> ML residual variance (sigma squared): 95.494, (sigma: 9.7721) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 374.78, (AIC for lm: 382.75) #> LM test for residual autocorrelation #> test value: 0.31954, p-value: 0.57188 #>  COL.mixed.D1 <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, Durbin= ~ INC + HOVAL, control=list(pre_eig=ev)) summary(COL.mixed.D1) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     Durbin = ~INC + HOVAL, control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.47829  -6.46731  -0.33835   6.05200  22.62969  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 42.822414  12.667204  3.3806 0.0007233 #> INC         -0.914223   0.331094 -2.7612 0.0057586 #> HOVAL       -0.293738   0.089212 -3.2926 0.0009927 #> lag.INC     -0.520284   0.565129 -0.9206 0.3572355 #> lag.HOVAL    0.245640   0.178917  1.3729 0.1697756 #>  #> Rho: 0.42634, LR test value: 5.3693, p-value: 0.020494 #> Asymptotic standard error: 0.15623 #>     z-value: 2.7288, p-value: 0.0063561 #> Wald statistic: 7.4465, p-value: 0.0063561 #>  #> Log likelihood: -181.3935 for mixed model #> ML residual variance (sigma squared): 91.791, (sigma: 9.5808) #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 376.79, (AIC for lm: 380.16) #> LM test for residual autocorrelation #> test value: 0.28919, p-value: 0.59074 #>  f <- CRIME ~ INC + HOVAL COL.mixed.D2 <- lagsarlm(f, data=COL.OLD, listw,  Durbin=as.formula(delete.response(terms(f))),  control=list(pre_eig=ev)) summary(COL.mixed.D2) #>  #> Call: #> lagsarlm(formula = f, data = COL.OLD, listw = listw, Durbin = as.formula(delete.response(terms(f))),  #>     control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.47829  -6.46731  -0.33835   6.05200  22.62969  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 42.822414  12.667204  3.3806 0.0007233 #> INC         -0.914223   0.331094 -2.7612 0.0057586 #> HOVAL       -0.293738   0.089212 -3.2926 0.0009927 #> lag.INC     -0.520284   0.565129 -0.9206 0.3572355 #> lag.HOVAL    0.245640   0.178917  1.3729 0.1697756 #>  #> Rho: 0.42634, LR test value: 5.3693, p-value: 0.020494 #> Asymptotic standard error: 0.15623 #>     z-value: 2.7288, p-value: 0.0063561 #> Wald statistic: 7.4465, p-value: 0.0063561 #>  #> Log likelihood: -181.3935 for mixed model #> ML residual variance (sigma squared): 91.791, (sigma: 9.5808) #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 376.79, (AIC for lm: 380.16) #> LM test for residual autocorrelation #> test value: 0.28919, p-value: 0.59074 #>  COL.mixed.D1a <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, Durbin= ~ INC, control=list(pre_eig=ev)) summary(COL.mixed.D1a) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     Durbin = ~INC, control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.82800  -5.85207   0.12047   6.00137  23.19963  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 48.814687  12.198232  4.0018 6.287e-05 #> INC         -1.006620   0.330641 -3.0445  0.002331 #> HOVAL       -0.265514   0.088768 -2.9911  0.002780 #> lag.INC     -0.186684   0.530550 -0.3519  0.724936 #>  #> Rho: 0.39229, LR test value: 4.5007, p-value: 0.033881 #> Asymptotic standard error: 0.1561 #>     z-value: 2.513, p-value: 0.011971 #> Wald statistic: 6.3151, p-value: 0.011971 #>  #> Log likelihood: -182.3328 for mixed model #> ML residual variance (sigma squared): 96.122, (sigma: 9.8042) #> Number of observations: 49  #> Number of parameters estimated: 6  #> AIC: 376.67, (AIC for lm: 379.17) #> LM test for residual autocorrelation #> test value: 2.6134, p-value: 0.10596 #>  try(COL.mixed.D1 <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, Durbin= ~ inc + HOVAL, control=list(pre_eig=ev))) #> Error in eval(predvars, data, env) : object 'inc' not found try(COL.mixed.D1 <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, Durbin= ~ DISCBD + HOVAL, control=list(pre_eig=ev))) #> Error in lagsarlm(CRIME ~ INC + HOVAL, data = COL.OLD, listw, Durbin = ~DISCBD +  :  #>   WX variables not in X: DISCBD NA.COL.OLD <- COL.OLD NA.COL.OLD$CRIME[20:25] <- NA COL.lag.NA <- lagsarlm(CRIME ~ INC + HOVAL, data=NA.COL.OLD,  listw, na.action=na.exclude) COL.lag.NA$na.action #> 1020 1021 1022 1023 1024 1025  #>   20   21   22   23   24   25  #> attr(,\"class\") #> [1] \"exclude\" COL.lag.NA #>  #> Call: #> lagsarlm(formula = CRIME ~ INC + HOVAL, data = NA.COL.OLD, listw = listw,  #>     na.action = na.exclude) #> Type: lag  #>  #> Coefficients: #>         rho (Intercept)         INC       HOVAL  #>   0.4537820  43.1054975  -0.9267352  -0.2715541  #>  #> Log likelihood: -160.8867  resid(COL.lag.NA) #>        1001        1002        1003        1004        1005        1006  #>  -4.4352945 -13.2750948  -2.9233555 -37.3067542   1.3568011  -3.8828027  #>        1007        1008        1009        1010        1011        1012  #>   5.9980436 -12.8113318  -4.0482558  18.1813323   5.9714203   1.0035599  #>        1013        1014        1015        1016        1017        1018  #>  -1.7490666  -1.7490651   5.8456328  10.1074158  -4.3706895   3.3713771  #>        1019        1020        1021        1022        1023        1024  #>  -4.0823022          NA          NA          NA          NA          NA  #>        1025        1026        1027        1028        1029        1030  #>          NA  -6.0553296 -11.5813311  -8.0011389  -1.9047478   3.9744243  #>        1031        1032        1033        1034        1035        1036  #>   4.8148614   6.0673483  10.2059847  22.7419913  -2.0830998   0.1422777  #>        1037        1038        1039        1040        1041        1042  #>   8.6436388   8.8150864   6.4974685  15.4121789   9.4182148   5.6427603  #>        1043        1044        1045        1046        1047        1048  #>  -7.5727123  -7.5983733  -9.7792620 -10.0870764  -3.1242393   3.4921796  #>        1049  #>   0.7173251  COL.lag.NA1 <- lagsarlm(CRIME ~ INC + HOVAL, data=NA.COL.OLD,  listw, Durbin=~INC) # https://github.com/r-spatial/spatialreg/issues/10 COL.lag.NA1$na.action #> 1020 1021 1022 1023 1024 1025  #>   20   21   22   23   24   25  #> attr(,\"class\") #> [1] \"omit\" COL.lag.NA2 <- lagsarlm(CRIME ~ INC + HOVAL, data=NA.COL.OLD,  listw, Durbin=~INC, na.action=na.exclude) COL.lag.NA2$na.action #> 1020 1021 1022 1023 1024 1025  #>   20   21   22   23   24   25  #> attr(,\"class\") #> [1] \"exclude\" # https://github.com/r-spatial/spatialreg/issues/11 COL.lag.NA3 <- lagsarlm(CRIME ~ INC + HOVAL, data=NA.COL.OLD,  listw, control=list(pre_eig=ev)) #> Warning: NAs found, precomputed eigenvalues ignored COL.lag.NA3$na.action #> 1020 1021 1022 1023 1024 1025  #>   20   21   22   23   24   25  #> attr(,\"class\") #> [1] \"omit\" # }  # \\dontrun{ data(boston, package=\"spData\") gp2mM <- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  I(RM^2) +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),  data=boston.c, spdep::nb2listw(boston.soi), type=\"mixed\", method=\"Matrix\") summary(gp2mM) #>  #> Call:lagsarlm(formula = log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  #>     I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B +  #>     log(LSTAT), data = boston.c, listw = spdep::nb2listw(boston.soi),  #>     type = \"mixed\", method = \"Matrix\") #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -0.6316833 -0.0629790 -0.0090776  0.0682421  0.6991072  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>                   Estimate  Std. Error  z value  Pr(>|z|) #> (Intercept)     1.89816225  0.22759605   8.3400 < 2.2e-16 #> CRIM           -0.00571021  0.00093504  -6.1069 1.016e-09 #> ZN              0.00069091  0.00051869   1.3320  0.182851 #> INDUS          -0.00111343  0.00307354  -0.3623  0.717155 #> CHAS1          -0.04163225  0.02739364  -1.5198  0.128567 #> I(NOX^2)       -0.01034950  0.19360214  -0.0535  0.957367 #> I(RM^2)         0.00794979  0.00102063   7.7891 6.661e-15 #> AGE            -0.00128789  0.00048920  -2.6326  0.008473 #> log(DIS)       -0.12404108  0.09510940  -1.3042  0.192168 #> log(RAD)        0.05863502  0.02257078   2.5978  0.009382 #> TAX            -0.00049084  0.00012145  -4.0416 5.308e-05 #> PTRATIO        -0.01319853  0.00595352  -2.2169  0.026628 #> B               0.00056383  0.00011089   5.0847 3.682e-07 #> log(LSTAT)     -0.24724454  0.02262033 -10.9302 < 2.2e-16 #> lag.CRIM       -0.00464215  0.00172935  -2.6843  0.007267 #> lag.ZN         -0.00037937  0.00070584  -0.5375  0.590940 #> lag.INDUS       0.00025064  0.00385901   0.0649  0.948215 #> lag.CHAS1       0.12518252  0.04071559   3.0746  0.002108 #> lag.I(NOX^2)   -0.38640403  0.22157523  -1.7439  0.081177 #> lag.I(RM^2)    -0.00451252  0.00153180  -2.9459  0.003220 #> lag.AGE         0.00149678  0.00068418   2.1877  0.028693 #> lag.log(DIS)   -0.00453785  0.10046478  -0.0452  0.963973 #> lag.log(RAD)   -0.00940702  0.03104930  -0.3030  0.761912 #> lag.TAX         0.00041083  0.00017867   2.2994  0.021481 #> lag.PTRATIO     0.00060355  0.00788837   0.0765  0.939012 #> lag.B          -0.00050781  0.00014155  -3.5874  0.000334 #> lag.log(LSTAT)  0.09846781  0.03399423   2.8966  0.003772 #>  #> Rho: 0.59578, LR test value: 181.68, p-value: < 2.22e-16 #> Asymptotic standard error: 0.038445 #>     z-value: 15.497, p-value: < 2.22e-16 #> Wald statistic: 240.16, p-value: < 2.22e-16 #>  #> Log likelihood: 300.6131 for mixed model #> ML residual variance (sigma squared): 0.016011, (sigma: 0.12654) #> Number of observations: 506  #> Number of parameters estimated: 29  #> AIC: -543.23, (AIC for lm: -363.55) #> LM test for residual autocorrelation #> test value: 29.772, p-value: 4.8604e-08 #>  W <- as(spdep::nb2listw(boston.soi), \"CsparseMatrix\") trMatb <- trW(W, type=\"mult\") gp2mMi <- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  I(RM^2) +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),  data=boston.c, spdep::nb2listw(boston.soi), type=\"mixed\", method=\"Matrix\",  trs=trMatb) summary(gp2mMi) #>  #> Call:lagsarlm(formula = log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  #>     I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B +  #>     log(LSTAT), data = boston.c, listw = spdep::nb2listw(boston.soi),  #>     type = \"mixed\", method = \"Matrix\", trs = trMatb) #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -0.6316833 -0.0629790 -0.0090776  0.0682421  0.6991072  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>                   Estimate  Std. Error  z value  Pr(>|z|) #> (Intercept)     1.89816225  0.22759605   8.3400 < 2.2e-16 #> CRIM           -0.00571021  0.00093504  -6.1069 1.016e-09 #> ZN              0.00069091  0.00051869   1.3320  0.182851 #> INDUS          -0.00111343  0.00307354  -0.3623  0.717155 #> CHAS1          -0.04163225  0.02739364  -1.5198  0.128567 #> I(NOX^2)       -0.01034950  0.19360214  -0.0535  0.957367 #> I(RM^2)         0.00794979  0.00102063   7.7891 6.661e-15 #> AGE            -0.00128789  0.00048920  -2.6326  0.008473 #> log(DIS)       -0.12404108  0.09510940  -1.3042  0.192168 #> log(RAD)        0.05863502  0.02257078   2.5978  0.009382 #> TAX            -0.00049084  0.00012145  -4.0416 5.308e-05 #> PTRATIO        -0.01319853  0.00595352  -2.2169  0.026628 #> B               0.00056383  0.00011089   5.0847 3.682e-07 #> log(LSTAT)     -0.24724454  0.02262033 -10.9302 < 2.2e-16 #> lag.CRIM       -0.00464215  0.00172935  -2.6843  0.007267 #> lag.ZN         -0.00037937  0.00070584  -0.5375  0.590940 #> lag.INDUS       0.00025064  0.00385901   0.0649  0.948215 #> lag.CHAS1       0.12518252  0.04071559   3.0746  0.002108 #> lag.I(NOX^2)   -0.38640403  0.22157523  -1.7439  0.081177 #> lag.I(RM^2)    -0.00451252  0.00153180  -2.9459  0.003220 #> lag.AGE         0.00149678  0.00068418   2.1877  0.028693 #> lag.log(DIS)   -0.00453785  0.10046478  -0.0452  0.963973 #> lag.log(RAD)   -0.00940702  0.03104930  -0.3030  0.761912 #> lag.TAX         0.00041083  0.00017867   2.2994  0.021481 #> lag.PTRATIO     0.00060355  0.00788837   0.0765  0.939012 #> lag.B          -0.00050781  0.00014155  -3.5874  0.000334 #> lag.log(LSTAT)  0.09846781  0.03399423   2.8966  0.003772 #>  #> Rho: 0.59578, LR test value: 181.68, p-value: < 2.22e-16 #> Asymptotic standard error: 0.038445 #>     z-value: 15.497, p-value: < 2.22e-16 #> Wald statistic: 240.16, p-value: < 2.22e-16 #>  #> Log likelihood: 300.6131 for mixed model #> ML residual variance (sigma squared): 0.016011, (sigma: 0.12654) #> Number of observations: 506  #> Number of parameters estimated: 29  #> AIC: -543.23, (AIC for lm: -363.55) #> LM test for residual autocorrelation #> test value: 29.772, p-value: 4.8604e-08 #>  # } COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, quiet=FALSE, control=list(pre_eig=ev)) #>  #> Spatial autoregressive error model #>  #> Jacobian calculated using neighbourhood matrix eigenvalues #>  #> lambda: -0.5674437  function: -195.8051  Jacobian: -1.636549  SSE: 7936.201  #> lambda: 0.03126655  function: -187.0219  Jacobian: -0.005318373  SSE: 5927.009  #> lambda: 0.4012898  function: -183.8422  Jacobian: -0.9953987  SSE: 4999.419  #> lambda: 0.6299767  function: -183.4895  Jacobian: -2.818134  SSE: 4574.641  #> lambda: 0.5811116  function: -183.3887  Jacobian: -2.314073  SSE: 4650.566  #> lambda: 0.554104  function: -183.3817  Jacobian: -2.066354  SSE: 4696.49  #> lambda: 0.5621834  function: -183.3805  Jacobian: -2.138326  SSE: 4682.474  #> lambda: 0.5617028  function: -183.3805  Jacobian: -2.133995  SSE: 4683.301  #> lambda: 0.5617888  function: -183.3805  Jacobian: -2.134769  SSE: 4683.153  #> lambda: 0.5617902  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151  #> lambda: 0.5617903  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151  #> lambda: 0.5617902  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151  #> lambda: 0.5617902  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151  summary(COL.errW.eig) #>  #> Call:errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     quiet = FALSE, control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -34.81174  -6.44031  -0.72142   7.61476  23.33626  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 59.893220   5.366162 11.1613 < 2.2e-16 #> INC         -0.941312   0.330569 -2.8476 0.0044057 #> HOVAL       -0.302250   0.090476 -3.3407 0.0008358 #>  #> Lambda: 0.56179, LR test value: 7.9935, p-value: 0.0046945 #> Asymptotic standard error: 0.13387 #>     z-value: 4.1966, p-value: 2.7098e-05 #> Wald statistic: 17.611, p-value: 2.7098e-05 #>  #> Log likelihood: -183.3805 for error model #> ML residual variance (sigma squared): 95.575, (sigma: 9.7762) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 376.76, (AIC for lm: 382.75) #>  COL.errW.eig_ev <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, control=list(pre_eig=ev)) all.equal(coefficients(COL.errW.eig), coefficients(COL.errW.eig_ev)) #> [1] TRUE COL.errB.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  spdep::nb2listw(COL.nb, style=\"B\")) summary(COL.errB.eig) #>  #> Call: #> errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"B\")) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -32.19010  -5.22646  -0.69952   7.92588  24.23511  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 55.383119   5.449775 10.1625 < 2.2e-16 #> INC         -0.936595   0.319355 -2.9328 0.0033596 #> HOVAL       -0.299857   0.088678 -3.3814 0.0007212 #>  #> Lambda: 0.12686, LR test value: 10.654, p-value: 0.0010983 #> Asymptotic standard error: 0.021745 #>     z-value: 5.8342, p-value: 5.4044e-09 #> Wald statistic: 34.038, p-value: 5.4044e-09 #>  #> Log likelihood: -182.0502 for error model #> ML residual variance (sigma squared): 88.744, (sigma: 9.4204) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 374.1, (AIC for lm: 382.75) #>  COL.errW.M <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"Matrix\", quiet=FALSE, trs=trMatc) #>  #> Spatial autoregressive error model #>  #> Jacobian calculated using sparse matrix Cholesky decomposition #> lambda: -0.2364499  function: -190.4287  Jacobian: -0.2899343  SSE: 6732.556  #> lambda: 0.2354499  function: -185.0024  Jacobian: -0.3201148  SSE: 5388.346  #> lambda: 0.5271001  function: -183.4053  Jacobian: -1.838306  SSE: 4744.975  #> lambda: 0.728364  function: -184.1244  Jacobian: -4.106761  SSE: 4454.203  #> lambda: 0.5304163  function: -183.4009  Jacobian: -1.865308  SSE: 4738.889  #> lambda: 0.5557478  function: -183.3812  Jacobian: -2.080853  SSE: 4693.62  #> lambda: 0.6216813  function: -183.4637  Jacobian: -2.727084  SSE: 4586.84  #> lambda: 0.5627129  function: -183.3805  Jacobian: -2.143105  SSE: 4681.563  #> lambda: 0.5618852  function: -183.3805  Jacobian: -2.135638  SSE: 4682.987  #> lambda: 0.5617866  function: -183.3805  Jacobian: -2.134749  SSE: 4683.157  #> lambda: 0.5617903  function: -183.3805  Jacobian: -2.134783  SSE: 4683.15  #> lambda: 0.5617903  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151  #> lambda: 0.5617903  function: -183.3805  Jacobian: -2.134782  SSE: 4683.151  #> lambda: 0.5617903  function: -183.3805  Jacobian: -2.134783  SSE: 4683.151  #> lambda: 0.5617903  function: -183.3805  Jacobian: -2.134783  SSE: 4683.151  #> lambda: 0.5617903  function: -183.3805  Jacobian: -2.134783  SSE: 4683.151  summary(COL.errW.M) #>  #> Call:errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     method = \"Matrix\", quiet = FALSE, trs = trMatc) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -34.81174  -6.44031  -0.72142   7.61476  23.33626  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 59.893219   5.366163 11.1613 < 2.2e-16 #> INC         -0.941312   0.330569 -2.8476 0.0044057 #> HOVAL       -0.302250   0.090476 -3.3407 0.0008358 #>  #> Lambda: 0.56179, LR test value: 7.9935, p-value: 0.0046945 #> Asymptotic standard error: 0.13387 #>     z-value: 4.1966, p-value: 2.7098e-05 #> Wald statistic: 17.611, p-value: 2.7098e-05 #>  #> Log likelihood: -183.3805 for error model #> ML residual variance (sigma squared): 95.575, (sigma: 9.7762) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 376.76, (AIC for lm: 382.75) #>  COL.SDEM.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, etype=\"emixed\", control=list(pre_eig=ev)) summary(COL.SDEM.eig) #>  #> Call:errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     etype = \"emixed\", control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.31635  -6.54376  -0.22212   6.44591  23.15801  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 73.545133   8.783543  8.3731 < 2.2e-16 #> INC         -1.051673   0.319514 -3.2915 0.0009966 #> HOVAL       -0.275608   0.091151 -3.0236 0.0024976 #> lag.INC     -1.156711   0.578629 -1.9991 0.0456024 #> lag.HOVAL    0.111691   0.198993  0.5613 0.5746048 #>  #> Lambda: 0.4254, LR test value: 4.9871, p-value: 0.025537 #> Asymptotic standard error: 0.15842 #>     z-value: 2.6852, p-value: 0.0072485 #> Wald statistic: 7.2103, p-value: 0.0072485 #>  #> Log likelihood: -181.5846 for error model #> ML residual variance (sigma squared): 92.531, (sigma: 9.6193) #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 377.17, (AIC for lm: 380.16) #>  # \\dontrun{ COL.SDEM.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, Durbin=TRUE, control=list(pre_eig=ev)) summary(COL.SDEM.eig) #>  #> Call:errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     Durbin = TRUE, control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.31635  -6.54376  -0.22212   6.44591  23.15801  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 73.545133   8.783543  8.3731 < 2.2e-16 #> INC         -1.051673   0.319514 -3.2915 0.0009966 #> HOVAL       -0.275608   0.091151 -3.0236 0.0024976 #> lag.INC     -1.156711   0.578629 -1.9991 0.0456024 #> lag.HOVAL    0.111691   0.198993  0.5613 0.5746048 #>  #> Lambda: 0.4254, LR test value: 4.9871, p-value: 0.025537 #> Asymptotic standard error: 0.15842 #>     z-value: 2.6852, p-value: 0.0072485 #> Wald statistic: 7.2103, p-value: 0.0072485 #>  #> Log likelihood: -181.5846 for error model #> ML residual variance (sigma squared): 92.531, (sigma: 9.6193) #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 377.17, (AIC for lm: 380.16) #>  COL.SDEM.eig <- errorsarlm(CRIME ~ DISCBD + INC + HOVAL, data=COL.OLD,  listw, Durbin=~INC, control=list(pre_eig=ev)) summary(COL.SDEM.eig) #>  #> Call:errorsarlm(formula = CRIME ~ DISCBD + INC + HOVAL, data = COL.OLD,  #>     listw = listw, Durbin = ~INC, control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -34.61867  -7.31993   0.82879   5.92877  17.82211  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 68.961912   6.985784  9.8717 < 2.2e-16 #> DISCBD      -5.412936   2.009281 -2.6940  0.007061 #> INC         -0.899425   0.315174 -2.8537  0.004321 #> HOVAL       -0.202846   0.090125 -2.2507  0.024403 #> lag.INC      0.161858   0.603859  0.2680  0.788669 #>  #> Lambda: 0.24524, LR test value: 1.2719, p-value: 0.25942 #> Asymptotic standard error: 0.18393 #>     z-value: 1.3334, p-value: 0.18241 #> Wald statistic: 1.7778, p-value: 0.18241 #>  #> Log likelihood: -178.9895 for error model #> ML residual variance (sigma squared): 85.935, (sigma: 9.2701) #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 371.98, (AIC for lm: 371.25) #>  summary(impacts(COL.SDEM.eig)) #> Impact measures (SDEM, glht, n): #>            Direct  Indirect      Total #> DISCBD -5.4129365        NA -5.4129365 #> INC    -0.8994251 0.1618581 -0.7375670 #> HOVAL  -0.2028457        NA -0.2028457 #> ======================================================== #> Standard errors: #>            Direct  Indirect      Total #> DISCBD 2.00928140        NA 2.00928140 #> INC    0.31517363 0.6038588 0.67559401 #> HOVAL  0.09012493        NA 0.09012493 #> ======================================================== #> Z-values: #>           Direct  Indirect     Total #> DISCBD -2.693966        NA -2.693966 #> INC    -2.853745 0.2680396 -1.091731 #> HOVAL  -2.250717        NA -2.250717 #>  #> p-values: #>        Direct    Indirect Total     #> DISCBD 0.0070607 NA       0.0070607 #> INC    0.0043207 0.78867  0.2749513 #> HOVAL  0.0244035 NA       0.0244035 #>  NA.COL.OLD <- COL.OLD NA.COL.OLD$CRIME[20:25] <- NA COL.err.NA <- errorsarlm(CRIME ~ INC + HOVAL, data=NA.COL.OLD,  listw, na.action=na.exclude) COL.err.NA$na.action #> 1020 1021 1022 1023 1024 1025  #>   20   21   22   23   24   25  #> attr(,\"class\") #> [1] \"exclude\" COL.err.NA #>  #> Call: #> errorsarlm(formula = CRIME ~ INC + HOVAL, data = NA.COL.OLD,  #>     listw = listw, na.action = na.exclude) #> Type: error  #>  #> Coefficients: #>      lambda (Intercept)         INC       HOVAL  #>   0.5748430  58.2460528  -0.8473028  -0.3024909  #>  #> Log likelihood: -161.8763  resid(COL.err.NA) #>         1001         1002         1003         1004         1005         1006  #>  -4.18270830 -11.44133843   0.31874928 -34.47163074   2.42244758  -4.32095072  #>         1007         1008         1009         1010         1011         1012  #>   8.66744165 -13.38669934  -1.92276585  17.85753950  -1.11484596  -2.30434792  #>         1013         1014         1015         1016         1017         1018  #>  -8.16935116  -5.80500231   0.14973721   5.93191445  -7.03028271   2.39112829  #>         1019         1020         1021         1022         1023         1024  #>  -8.95099917           NA           NA           NA           NA           NA  #>         1025         1026         1027         1028         1029         1030  #>           NA  -2.52940712  -9.60025384  -6.95635586  -0.43630579   5.98493664  #>         1031         1032         1033         1034         1035         1036  #>   6.25882669   7.75527032  10.83413236  23.23927250  -0.05594957   1.43808573  #>         1037         1038         1039         1040         1041         1042  #>   9.51995266  12.18295373   8.31031724  17.06834503   7.04418393   7.50088924  #>         1043         1044         1045         1046         1047         1048  #>  -7.78485976  -6.79207447  -7.94977534 -11.25362117  -5.68994630   5.04837399  #>         1049  #>   2.22497381  print(system.time(ev <- eigenw(similar.listw(listw)))) #>    user  system elapsed  #>   0.001   0.000   0.001  print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"eigen\", control=list(pre_eig=ev)))) #>    user  system elapsed  #>   0.165   0.000   0.166  ocoef <- coefficients(COL.errW.eig) print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"eigen\", control=list(pre_eig=ev, LAPACK=FALSE)))) #>    user  system elapsed  #>   0.161   0.000   0.161  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"eigen\", control=list(pre_eig=ev, compiled_sse=TRUE)))) #>    user  system elapsed  #>   0.160   0.000   0.161  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"Matrix_J\", control=list(super=TRUE)))) #> Warning: the default value of argument 'sqrt' of method 'determinant(<CHMfactor>, <logical>)' may change from TRUE to FALSE as soon as the next release of Matrix; set 'sqrt' when programming #>    user  system elapsed  #>   0.185   0.000   0.186  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"Matrix_J\", control=list(super=FALSE)))) #>    user  system elapsed  #>   0.177   0.000   0.178  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"Matrix_J\", control=list(super=as.logical(NA))))) #>    user  system elapsed  #>   0.178   0.000   0.178  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"Matrix\", control=list(super=TRUE)))) #>    user  system elapsed  #>   0.169   0.000   0.169  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"Matrix\", control=list(super=FALSE)))) #>    user  system elapsed  #>   0.164   0.000   0.165  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"Matrix\", control=list(super=as.logical(NA))))) #>    user  system elapsed  #>   0.165   0.000   0.166  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"spam\", control=list(spamPivot=\"MMD\")))) #>    user  system elapsed  #>   0.175   0.001   0.176  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"spam\", control=list(spamPivot=\"RCM\")))) #>    user  system elapsed  #>   0.184   0.000   0.184  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"spam_update\", control=list(spamPivot=\"MMD\")))) #>    user  system elapsed  #>   0.216   0.000   0.216  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE print(system.time(COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, method=\"spam_update\", control=list(spamPivot=\"RCM\")))) #>    user  system elapsed  #>   0.182   0.000   0.183  print(all.equal(ocoef, coefficients(COL.errW.eig))) #> [1] TRUE # } COL.sacW.eig <- sacsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, listw,  control=list(pre_eig1=ev, pre_eig2=ev)) summary(COL.sacW.eig) #>  #> Call:sacsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     control = list(pre_eig1 = ev, pre_eig2 = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.32081  -5.33662  -0.20219   6.59672  23.25604  #>  #> Type: sac  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 47.783766   9.902659  4.8253 1.398e-06 #> INC         -1.025894   0.326326 -3.1438  0.001668 #> HOVAL       -0.281651   0.090033 -3.1283  0.001758 #>  #> Rho: 0.36807 #> Asymptotic standard error: 0.19668 #>     z-value: 1.8714, p-value: 0.061285 #> Lambda: 0.16668 #> Asymptotic standard error: 0.29661 #>     z-value: 0.56196, p-value: 0.57415 #>  #> LR test value: 10.285, p-value: 0.0058432 #>  #> Log likelihood: -182.2348 for sac model #> ML residual variance (sigma squared): 95.604, (sigma: 9.7777) #> Number of observations: 49  #> Number of parameters estimated: 6  #> AIC: 376.47, (AIC for lm: 382.75) #>  set.seed(1) summary(impacts(COL.sacW.eig, tr=trMatc, R=2000), zstats=TRUE, short=TRUE) #> Impact measures (sac, trace): #>           Direct   Indirect      Total #> INC   -1.0632723 -0.5601501 -1.6234223 #> HOVAL -0.2919129 -0.1537847 -0.4456977 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3200735 0.8453130 0.9606199 #> HOVAL 0.0947660 0.2823186 0.3278763 #>  #> Simulated z-values: #>          Direct   Indirect     Total #> INC   -3.376570 -0.8371024 -1.861677 #> HOVAL -3.159909 -0.7431009 -1.553156 #>  #> Simulated p-values: #>       Direct     Indirect Total    #> INC   0.00073396 0.40254  0.062649 #> HOVAL 0.00157818 0.45742  0.120386 COL.msacW.eig <- sacsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, listw,  type=\"sacmixed\", control=list(pre_eig1=ev, pre_eig2=ev)) summary(COL.msacW.eig) #>  #> Call:sacsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     type = \"sacmixed\", control = list(pre_eig1 = ev, pre_eig2 = ev)) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -37.8045  -6.5244  -0.2207   5.9944  22.8691  #>  #> Type: sacmixed  #> Coefficients: (asymptotic standard errors)  #>             Estimate Std. Error z value Pr(>|z|) #> (Intercept) 50.92026   68.25722  0.7460 0.455664 #> INC         -0.95072    0.44033 -2.1591 0.030841 #> HOVAL       -0.28650    0.09994 -2.8667 0.004148 #> lag.INC     -0.69261    1.69113 -0.4096 0.682132 #> lag.HOVAL    0.20852    0.28702  0.7265 0.467546 #>  #> Rho: 0.31557 #> Asymptotic standard error: 0.94581 #>     z-value: 0.33365, p-value: 0.73864 #> Lambda: 0.15415 #> Asymptotic standard error: 1.0643 #>     z-value: 0.14484, p-value: 0.88484 #>  #> LR test value: 12.07, p-value: 0.016837 #>  #> Log likelihood: -181.3422 for sacmixed model #> ML residual variance (sigma squared): 93.149, (sigma: 9.6514) #> Number of observations: 49  #> Number of parameters estimated: 8  #> AIC: 378.68, (AIC for lm: 382.75) #>  set.seed(1) summary(impacts(COL.msacW.eig, tr=trMatc, R=2000), zstats=TRUE, short=TRUE) #> Impact measures (sacmixed, trace): #>           Direct   Indirect      Total #> INC   -1.0317003 -1.3693141 -2.4010144 #> HOVAL -0.2768608  0.1629265 -0.1139344 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct Indirect     Total #> INC   0.3799971 2.356727 2.5113549 #> HOVAL 0.1091241 0.761200 0.8220231 #>  #> Simulated z-values: #>          Direct   Indirect       Total #> INC   -2.706969 -0.6434228 -1.01340192 #> HOVAL -2.478740  0.2512075 -0.09643407 #>  #> Simulated p-values: #>       Direct    Indirect Total   #> INC   0.0067901 0.51995  0.31087 #> HOVAL 0.0131847 0.80165  0.92318 COL.msacW1.eig <- sacsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, listw,  Durbin=TRUE, control=list(pre_eig1=ev, pre_eig2=ev)) summary(COL.msacW1.eig) #>  #> Call:sacsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     Durbin = TRUE, control = list(pre_eig1 = ev, pre_eig2 = ev)) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -37.8045  -6.5244  -0.2207   5.9944  22.8691  #>  #> Type: sacmixed  #> Coefficients: (asymptotic standard errors)  #>             Estimate Std. Error z value Pr(>|z|) #> (Intercept) 50.92026   68.25722  0.7460 0.455664 #> INC         -0.95072    0.44033 -2.1591 0.030841 #> HOVAL       -0.28650    0.09994 -2.8667 0.004148 #> lag.INC     -0.69261    1.69113 -0.4096 0.682132 #> lag.HOVAL    0.20852    0.28702  0.7265 0.467546 #>  #> Rho: 0.31557 #> Asymptotic standard error: 0.94581 #>     z-value: 0.33365, p-value: 0.73864 #> Lambda: 0.15415 #> Asymptotic standard error: 1.0643 #>     z-value: 0.14484, p-value: 0.88484 #>  #> LR test value: 12.07, p-value: 0.016837 #>  #> Log likelihood: -181.3422 for sacmixed model #> ML residual variance (sigma squared): 93.149, (sigma: 9.6514) #> Number of observations: 49  #> Number of parameters estimated: 8  #> AIC: 378.68, (AIC for lm: 382.75) #>  set.seed(1) summary(impacts(COL.msacW1.eig, tr=trMatc, R=2000), zstats=TRUE, short=TRUE) #> Impact measures (sacmixed, trace): #>           Direct   Indirect      Total #> INC   -1.0317003 -1.3693141 -2.4010144 #> HOVAL -0.2768608  0.1629265 -0.1139344 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct Indirect     Total #> INC   0.3799971 2.356727 2.5113549 #> HOVAL 0.1091241 0.761200 0.8220231 #>  #> Simulated z-values: #>          Direct   Indirect       Total #> INC   -2.706969 -0.6434228 -1.01340192 #> HOVAL -2.478740  0.2512075 -0.09643407 #>  #> Simulated p-values: #>       Direct    Indirect Total   #> INC   0.0067901 0.51995  0.31087 #> HOVAL 0.0131847 0.80165  0.92318 COL.msacW2.eig <- sacsarlm(CRIME ~ DISCBD + INC + HOVAL, data=COL.OLD,   listw, Durbin= ~ INC, control=list(pre_eig1=ev, pre_eig2=ev)) summary(COL.msacW2.eig) #>  #> Call:sacsarlm(formula = CRIME ~ DISCBD + INC + HOVAL, data = COL.OLD,  #>     listw = listw, Durbin = ~INC, control = list(pre_eig1 = ev,  #>         pre_eig2 = ev)) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -34.2794  -7.0786   1.0543   6.0019  17.8891  #>  #> Type: sacmixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value Pr(>|z|) #> (Intercept) 74.064502  37.738940  1.9625 0.049699 #> DISCBD      -5.707678   3.248629 -1.7569 0.078926 #> INC         -0.900975   0.314996 -2.8603 0.004233 #> HOVAL       -0.203399   0.092982 -2.1875 0.028705 #> lag.INC      0.061568   0.926947  0.0664 0.947043 #>  #> Rho: -0.077599 #> Asymptotic standard error: 0.57955 #>     z-value: -0.1339, p-value: 0.89348 #> Lambda: 0.29646 #> Asymptotic standard error: 0.51021 #>     z-value: 0.58104, p-value: 0.56121 #>  #> LR test value: 1.4982, p-value: 0.68269 #>  #> Log likelihood: -178.963 for sacmixed model #> ML residual variance (sigma squared): 85.135, (sigma: 9.2269) #> Number of observations: 49  #> Number of parameters estimated: 8  #> AIC: 373.93, (AIC for lm: 369.42) #>  summary(impacts(COL.msacW2.eig, tr=trMatc, R=2000), zstats=TRUE, short=TRUE) #> Impact measures (sacmixed, trace): #>            Direct   Indirect      Total #> DISCBD -5.7150799 0.41841671 -5.2966632 #> INC    -0.9031729 0.12421198 -0.7789609 #> HOVAL  -0.2036631 0.01491074 -0.1887524 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>           Direct  Indirect    Total #> DISCBD 3.1446963 5.7201657 5.757459 #> INC    0.3621137 1.7150155 1.876353 #> HOVAL  0.1090172 0.6360488 0.698836 #>  #> Simulated z-values: #>           Direct   Indirect      Total #> DISCBD -1.852002  0.0280018 -0.9837341 #> INC    -2.461864  0.1861184 -0.3049951 #> HOVAL  -2.021743 -0.1841543 -0.4829973 #>  #> Simulated p-values: #>        Direct   Indirect Total   #> DISCBD 0.064026 0.97766  0.32525 #> INC    0.013822 0.85235  0.76037 #> HOVAL  0.043203 0.85389  0.62910 # \\dontrun{ COL.mix.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, type=\"mixed\", method=\"eigen\") summary(COL.mix.eig, correlation=TRUE, Nagelkerke=TRUE) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     type = \"mixed\", method = \"eigen\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.47829  -6.46731  -0.33835   6.05200  22.62969  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 42.822413  12.667204  3.3806 0.0007233 #> INC         -0.914223   0.331094 -2.7612 0.0057586 #> HOVAL       -0.293738   0.089212 -3.2926 0.0009927 #> lag.INC     -0.520283   0.565129 -0.9206 0.3572355 #> lag.HOVAL    0.245640   0.178917  1.3729 0.1697756 #>  #> Rho: 0.42634, LR test value: 5.3693, p-value: 0.020494 #> Asymptotic standard error: 0.15623 #>     z-value: 2.7288, p-value: 0.0063561 #> Wald statistic: 7.4465, p-value: 0.0063561 #>  #> Log likelihood: -181.3935 for mixed model #> ML residual variance (sigma squared): 91.791, (sigma: 9.5808) #> Nagelkerke pseudo-R-squared: 0.6494  #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 376.79, (AIC for lm: 380.16) #> LM test for residual autocorrelation #> test value: 0.28919, p-value: 0.59074 #>  #>  Correlation of coefficients  #>             sigma rho   (Intercept) INC   HOVAL lag.INC #> rho         -0.18                                       #> (Intercept)  0.16 -0.89                                 #> INC         -0.03  0.14 -0.19                           #> HOVAL        0.02 -0.09  0.03       -0.45               #> lag.INC     -0.09  0.49 -0.53       -0.36  0.05         #> lag.HOVAL   -0.04  0.19 -0.36        0.19 -0.24 -0.41   #>  COL.mix.M <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  listw, type=\"mixed\", method=\"Matrix\") summary(COL.mix.M, correlation=TRUE, Nagelkerke=TRUE) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = listw,  #>     type = \"mixed\", method = \"Matrix\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.47829  -6.46731  -0.33835   6.05200  22.62969  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 42.822416  12.667205  3.3806 0.0007233 #> INC         -0.914223   0.331094 -2.7612 0.0057586 #> HOVAL       -0.293738   0.089212 -3.2926 0.0009927 #> lag.INC     -0.520284   0.565129 -0.9206 0.3572354 #> lag.HOVAL    0.245640   0.178917  1.3729 0.1697756 #>  #> Rho: 0.42634, LR test value: 5.3693, p-value: 0.020494 #> Asymptotic standard error: 0.15623 #>     z-value: 2.7288, p-value: 0.0063561 #> Wald statistic: 7.4465, p-value: 0.0063561 #>  #> Log likelihood: -181.3935 for mixed model #> ML residual variance (sigma squared): 91.791, (sigma: 9.5808) #> Nagelkerke pseudo-R-squared: 0.6494  #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 376.79, (AIC for lm: 380.16) #> LM test for residual autocorrelation #> test value: 0.28919, p-value: 0.59074 #>  #>  Correlation of coefficients  #>             sigma rho   (Intercept) INC   HOVAL lag.INC #> rho         -0.18                                       #> (Intercept)  0.16 -0.89                                 #> INC         -0.03  0.14 -0.19                           #> HOVAL        0.02 -0.09  0.03       -0.45               #> lag.INC     -0.09  0.49 -0.53       -0.36  0.05         #> lag.HOVAL   -0.04  0.19 -0.36        0.19 -0.24 -0.41   #>  COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,   spdep::nb2listw(COL.nb, style=\"W\"), method=\"eigen\") summary(COL.errW.eig, correlation=TRUE, Nagelkerke=TRUE, Hausman=TRUE) #>  #> Call: #> errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"W\"), method = \"eigen\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -34.81174  -6.44031  -0.72142   7.61476  23.33626  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 59.893219   5.366163 11.1613 < 2.2e-16 #> INC         -0.941312   0.330569 -2.8476 0.0044057 #> HOVAL       -0.302250   0.090476 -3.3407 0.0008358 #>  #> Lambda: 0.56179, LR test value: 7.9935, p-value: 0.0046945 #> Asymptotic standard error: 0.13387 #>     z-value: 4.1966, p-value: 2.7098e-05 #> Wald statistic: 17.611, p-value: 2.7098e-05 #>  #> Log likelihood: -183.3805 for error model #> ML residual variance (sigma squared): 95.575, (sigma: 9.7762) #> Nagelkerke pseudo-R-squared: 0.61978  #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 376.76, (AIC for lm: 382.75) #> Hausman test: 4.902, df: 3, p-value: 0.17911 #>  #>  Correlation of coefficients  #>             sigma lambda (Intercept) INC   #> lambda      -0.24                          #> (Intercept)  0.00  0.00                    #> INC          0.00  0.00  -0.56             #> HOVAL        0.00  0.00  -0.26       -0.45 #>  # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/SET_MCMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian MCMC spatial simultaneous autoregressive model estimation — spBreg_lag","title":"Bayesian MCMC spatial simultaneous autoregressive model estimation — spBreg_lag","text":"spBreg_lag function early-release version Matlab Spatial Econometrics Toolbox function sar_g.m, using drawing inversion, accommodating heteroskedastic disturbances.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SET_MCMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian MCMC spatial simultaneous autoregressive model estimation — spBreg_lag","text":"","code":"spBreg_lag(formula, data = list(), listw, na.action, Durbin, type,     zero.policy=NULL, control=list()) spBreg_sac(formula, data = list(), listw, listw2=NULL, na.action,      Durbin, type, zero.policy=NULL, control=list()) spBreg_err(formula, data = list(), listw, na.action, Durbin, etype,     zero.policy=NULL, control=list()) # S3 method for class 'MCMC_sar_G' impacts(obj, ..., tr=NULL, listw=NULL, evalues=NULL, Q=NULL) # S3 method for class 'MCMC_sem_G' impacts(obj, ..., tr=NULL, listw=NULL, evalues=NULL, Q=NULL) # S3 method for class 'MCMC_sac_G' impacts(obj, ..., tr=NULL, listw=NULL, evalues=NULL, Q=NULL)"},{"path":"https://r-spatial.github.io/spatialreg/reference/SET_MCMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian MCMC spatial simultaneous autoregressive model estimation — spBreg_lag","text":"formula symbolic description model fit. details model specification given lm() data optional data frame containing variables model. default variables taken environment function called. listw, listw2 listw object created example nb2listw na.action function (default options(\"na.action\")), can also na.omit na.exclude consequences residuals fitted values - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. Durbin default FALSE (spatial lag model); TRUE, full spatial Durbin model; formula object, subset explanatory variables lag type, etype (use ‘Durbin=’ argument - retained backwards compatibility ) default \"lag\", may set \"mixed\"; \"mixed\", lagged intercept dropped spatial weights style \"W\", row-standardised weights, otherwise included; “Durbin” may used instead “mixed” zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE (default) assign NA control list extra control arguments - see section obj spatial regression object ... Arguments passed methods coda package tr vector traces powers spatial weights matrix created using trW, approximate impact measures; given, listw must given exact measures (small moderate spatial weights matrices); traces must spatial weights used fitting spatial regression, must row-standardised evalues vector eigenvalues spatial weights matrix impacts calculations Q default NULL, else integer number cumulative power series impacts calculate tr given","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SET_MCMC.html","id":"control-arguments","dir":"Reference","previous_headings":"","what":"Control arguments","title":"Bayesian MCMC spatial simultaneous autoregressive model estimation — spBreg_lag","text":"tol.opt: desired accuracy optimization - passed optimize() (default=square root double precision machine tolerance, larger root may used needed, see help(boston) example) fdHess: default NULL, set (method != \"eigen\") internally; use fdHess compute approximate Hessian using finite differences using sparse matrix methods; used make coefficient covariance matrix number observations large; may turned save resources need optimHess: default FALSE, use fdHess nlme, TRUE, use optim calculate Hessian optimum optimHessMethod: default “optimHess”, may “nlm” one optim methods compiled_sse: default FALSE; logical value used log likelihood function choose compiled code computing SSE Imult: default 2; used preparing Cholesky decompositions updating Jacobian function super: NULL (default), set FALSE use simplicial decomposition sparse Cholesky decomposition method “Matrix_J”, set  .logical(NA) method “Matrix”, TRUE, use supernodal decomposition cheb_q: default 5; highest power approximating polynomial Chebyshev approximation MC_p: default 16; number random variates MC_m: default 30; number products random variates matrix spatial weights matrix spamPivot: default “MMD”, alternative “RCM” in_coef default 0.1, coefficient value initial Cholesky decomposition “spam_update” type default “MC”, used method “moments”; alternatives “mult” “moments”, use trs missing, trW correct default TRUE, used method “moments” compute Smirnov/Anselin correction term trunc default TRUE, used method “moments” truncate Smirnov/Anselin correction term SE_method default “LU”, may “MC” nrho default 200, SE toolbox; size first stage lndet grid; may reduced example 40 interpn default 2000, SE toolbox; size second stage lndet grid small_asy default TRUE; method “eigen”, use asymmetric covariances rather numerical Hessian ones n <= small small default 1500; threshold number observations asymmetric covariances method “eigen” SElndet default NULL, may used pass pre-computed SE toolbox style matrix coefficients lndet values \"SE_classic\" \"SE_whichMin\" methods LU_order default FALSE; used “LU_prepermutate”, note warnings given lu method pre_eig default NULL; may used pass pre-computed vector eigenvalues OrdVsign default 1; used set sign final component negative -1 (alpha times ((sigma squared) squared) Ord (1975) equation B.1).","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SET_MCMC.html","id":"extra-bayesian-control-arguments","dir":"Reference","previous_headings":"","what":"Extra Bayesian control arguments","title":"Bayesian MCMC spatial simultaneous autoregressive model estimation — spBreg_lag","text":"ldet_method default “SE_classic”; equivalent method argument lagsarlm interval default c(-1, 1); used unmodified set internally jacobianSetup ndraw default 2500L; integer total number draws nomit default 500L; integer total number omitted burn-draws thin default 1L; integer thinning proportion verbose default FALSE; inverse quiet argument lagsarlm detval default NULL; yet use, precomputed matrix log determinants prior list following components: rhoMH, lambdaMH default FALSE; use Metropolis griddy Gibbs Tbeta default NULL; values betas variance-covariance matrix, set diag(k)*1e+12 NULL c_beta default NULL; values betas set 0 NULL rho default 0.5; value autoregressive coefficient sige default 1; value residual variance nu default 0; informative Gamma(nu,d0) prior sige d0 default 0; informative Gamma(nu,d0) prior sige a1 default 1.01; parameter beta(a1,a2) prior rho a2 default 1.01; parameter beta(a1,a2) prior rho cc default 0.2; initial tuning parameter M-H sampling gG_sige default TRUE; include sige lambda griddy Gibbs update cc1 default 0.2; initial tuning parameter M-H sampling cc2 default 0.2; initial tuning parameter M-H sampling","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SET_MCMC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bayesian MCMC spatial simultaneous autoregressive model estimation — spBreg_lag","text":"LeSage J RK Pace (2009) Introduction Spatial Econometrics. CRC Press, Boca Raton.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SET_MCMC.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bayesian MCMC spatial simultaneous autoregressive model estimation — spBreg_lag","text":"Roger Bivand Roger.Bivand@nhh., thanks Abhirup Mallik Virgilio Gómez-Rubio initial coding GSoC 2011","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SET_MCMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian MCMC spatial simultaneous autoregressive model estimation — spBreg_lag","text":"","code":"#require(\"spdep\", quietly=TRUE) data(oldcol, package=\"spdep\") lw <- spdep::nb2listw(COL.nb, style=\"W\") require(\"coda\", quietly=TRUE) set.seed(1) COL.err.Bayes <- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw) print(summary(COL.err.Bayes)) #>  #> Iterations = 501:2500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 2000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean       SD Naive SE Time-series SE #> (Intercept)  59.6663  6.99423 0.156396       0.156396 #> INC          -0.9421  0.39894 0.008921       0.008921 #> HOVAL        -0.3011  0.09984 0.002233       0.002233 #> lambda        0.5664  0.15362 0.003435       0.003435 #> sige        115.0482 25.96435 0.580581       0.622638 #>  #> 2. Quantiles for each variable: #>  #>                2.5%     25%      50%      75%    97.5% #> (Intercept) 45.6439 55.3852  60.1164  64.5665  72.1349 #> INC         -1.7360 -1.2047  -0.9445  -0.6803  -0.1379 #> HOVAL       -0.4977 -0.3683  -0.3010  -0.2346  -0.1070 #> lambda       0.2335  0.4717   0.5773   0.6758   0.8309 #> sige        74.4245 96.7013 111.9152 129.2463 176.8133 #>  print(raftery.diag(COL.err.Bayes, r=0.01)) #>  #> Quantile (q) = 0.025 #> Accuracy (r) = +/- 0.01 #> Probability (s) = 0.95  #>                                                     #>              Burn-in  Total Lower bound  Dependence #>              (M)      (N)   (Nmin)       factor (I) #>  (Intercept) 3        1052  937          1.120      #>  INC         2        969   937          1.030      #>  HOVAL       3        1052  937          1.120      #>  lambda      3        1010  937          1.080      #>  sige        2        930   937          0.993      #>  # \\dontrun{ ev <- eigenw(lw) W <- as(lw, \"CsparseMatrix\") trMatc <- trW(W, type=\"mult\") set.seed(1) COL.err.Bayes <- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,  control=list(prior=list(lambdaMH=TRUE))) print(summary(COL.err.Bayes)) #>  #> Iterations = 501:2500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 2000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean      SD Naive SE Time-series SE #> (Intercept)  59.5304  8.9916 0.201059       0.275885 #> INC          -0.9142  0.3969 0.008874       0.011266 #> HOVAL        -0.3027  0.1021 0.002282       0.002282 #> lambda        0.6011  0.1502 0.003358       0.007723 #> sige        116.6773 27.9707 0.625443       0.660902 #>  #> 2. Quantiles for each variable: #>  #>                2.5%    25%      50%      75%    97.5% #> (Intercept) 44.0607 54.802  59.6796  64.2473  72.9189 #> INC         -1.6866 -1.184  -0.9177  -0.6422  -0.1429 #> HOVAL       -0.5102 -0.370  -0.3005  -0.2359  -0.1019 #> lambda       0.2826  0.511   0.6135   0.7023   0.8676 #> sige        74.1788 97.167 113.2955 130.2498 182.6024 #>  print(raftery.diag(COL.err.Bayes, r=0.01)) #>  #> Quantile (q) = 0.025 #> Accuracy (r) = +/- 0.01 #> Probability (s) = 0.95  #>                                                     #>              Burn-in  Total Lower bound  Dependence #>              (M)      (N)   (Nmin)       factor (I) #>  (Intercept) 3        1143  937          1.220      #>  INC         2        969   937          1.030      #>  HOVAL       2        892   937          0.952      #>  lambda      17       4454  937          4.750      #>  sige        2        930   937          0.993      #>  set.seed(1) COL.err.Bayes <- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,  Durbin=TRUE) print(summary(COL.err.Bayes)) #>  #> Iterations = 501:2500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 2000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                  Mean      SD Naive SE Time-series SE #> (Intercept)  72.66146 11.7776 0.263354       0.263354 #> INC          -1.01262  0.3770 0.008430       0.008430 #> HOVAL        -0.28032  0.1057 0.002363       0.002363 #> lag.INC      -1.07754  0.7304 0.016333       0.016333 #> lag.HOVAL     0.09151  0.2395 0.005356       0.005702 #> lambda        0.48878  0.1732 0.003873       0.003873 #> sige        114.61924 26.8321 0.599984       0.653970 #>  #> 2. Quantiles for each variable: #>  #>                2.5%      25%       50%      75%     97.5% #> (Intercept) 48.2063 65.55434  73.00434  80.0130  95.69254 #> INC         -1.7385 -1.27266  -1.01806  -0.7591  -0.25126 #> HOVAL       -0.4883 -0.35221  -0.27730  -0.2111  -0.07194 #> lag.INC     -2.4291 -1.54241  -1.09764  -0.6156   0.38091 #> lag.HOVAL   -0.3892 -0.06269   0.09028   0.2468   0.55625 #> lambda       0.1165  0.37669   0.49775   0.6118   0.79690 #> sige        73.4822 95.76803 110.90096 128.2633 177.00970 #>  print(summary(impacts(COL.err.Bayes))) #> Impact measures (SDEM, MCMC, n): #>           Direct    Indirect     Total #> INC   -1.0126232 -1.07753574 -2.090159 #> HOVAL -0.2803178  0.09150584 -0.188812 #> ======================================================== #> Standard errors: #>          Direct  Indirect     Total #> INC   0.3572678 0.6921465 0.8161704 #> HOVAL 0.1001564 0.2269602 0.2729228 #> ======================================================== #> Z-values: #>          Direct   Indirect      Total #> INC   -2.834354 -1.5568031 -2.5609345 #> HOVAL -2.798799  0.4031801 -0.6918146 #>  #> p-values: #>       Direct    Indirect Total    #> INC   0.0045918 0.11952  0.010439 #> HOVAL 0.0051293 0.68682  0.489054 #>  print(raftery.diag(COL.err.Bayes, r=0.01)) #>  #> Quantile (q) = 0.025 #> Accuracy (r) = +/- 0.01 #> Probability (s) = 0.95  #>                                                     #>              Burn-in  Total Lower bound  Dependence #>              (M)      (N)   (Nmin)       factor (I) #>  (Intercept) 2        930   937          0.993      #>  INC         3        1096  937          1.170      #>  HOVAL       3        1052  937          1.120      #>  lag.INC     2        892   937          0.952      #>  lag.HOVAL   2        930   937          0.993      #>  lambda      2        930   937          0.993      #>  sige        2        930   937          0.993      #>  set.seed(1) COL.err.Bayes <- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,  Durbin=TRUE, control=list(prior=list(lambdaMH=TRUE))) print(summary(COL.err.Bayes)) #>  #> Iterations = 501:2500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 2000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                  Mean      SD Naive SE Time-series SE #> (Intercept)  71.32778 18.0269 0.403094       0.382389 #> INC          -0.99169  0.3978 0.008896       0.008896 #> HOVAL        -0.27840  0.1115 0.002494       0.002494 #> lag.INC      -0.95360  0.8293 0.018543       0.021986 #> lag.HOVAL     0.06812  0.2557 0.005717       0.005904 #> lambda        0.58149  0.1895 0.004238       0.010821 #> sige        119.53101 28.0026 0.626158       0.839390 #>  #> 2. Quantiles for each variable: #>  #>                2.5%      25%       50%      75%     97.5% #> (Intercept) 37.9514 62.67210  72.07446  80.4143  99.84194 #> INC         -1.7844 -1.24565  -0.99600  -0.7380  -0.21146 #> HOVAL       -0.4977 -0.35256  -0.27741  -0.2077  -0.05449 #> lag.INC     -2.4414 -1.50144  -0.99500  -0.4736   0.79318 #> lag.HOVAL   -0.4571 -0.09065   0.07663   0.2398   0.55644 #> lambda       0.1781  0.45916   0.59241   0.7231   0.90210 #> sige        75.6501 99.39723 116.16515 135.1114 184.61449 #>  print(summary(impacts(COL.err.Bayes))) #> Impact measures (SDEM, MCMC, n): #>           Direct    Indirect     Total #> INC   -0.9916937 -0.95359651 -1.945290 #> HOVAL -0.2784029  0.06812087 -0.210282 #> ======================================================== #> Standard errors: #>          Direct  Indirect     Total #> INC   0.3770053 0.7858279 0.9655825 #> HOVAL 0.1056706 0.2422841 0.2998021 #> ======================================================== #> Z-values: #>         Direct   Indirect      Total #> INC   -2.63045 -1.2134929 -2.0146288 #> HOVAL -2.63463  0.2811611 -0.7014028 #>  #> p-values: #>       Direct    Indirect Total    #> INC   0.0085272 0.22494  0.043944 #> HOVAL 0.0084229 0.77859  0.483052 #>  print(raftery.diag(COL.err.Bayes, r=0.01)) #>  #> Quantile (q) = 0.025 #> Accuracy (r) = +/- 0.01 #> Probability (s) = 0.95  #>                                                     #>              Burn-in  Total Lower bound  Dependence #>              (M)      (N)   (Nmin)       factor (I) #>  (Intercept) 4        1192  937          1.270      #>  INC         2        930   937          0.993      #>  HOVAL       2        930   937          0.993      #>  lag.INC     3        1013  937          1.080      #>  lag.HOVAL   2        969   937          1.030      #>  lambda      17       4647  937          4.960      #>  sige        3        1052  937          1.120      #>  set.seed(1) COL.err.Bayes <- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,  Durbin=~INC) print(summary(COL.err.Bayes)) #>  #> Iterations = 501:2500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 2000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean       SD Naive SE Time-series SE #> (Intercept)  74.5397 10.99197 0.245788       0.245788 #> INC          -1.0322  0.38342 0.008574       0.008574 #> HOVAL        -0.2861  0.09986 0.002233       0.002233 #> lag.INC      -0.9210  0.59074 0.013209       0.012745 #> lambda        0.4879  0.17196 0.003845       0.003672 #> sige        112.0817 25.47154 0.569561       0.568218 #>  #> 2. Quantiles for each variable: #>  #>                2.5%     25%      50%      75%     97.5% #> (Intercept) 52.0865 67.8131  74.9358  81.6887  95.01447 #> INC         -1.7848 -1.2893  -1.0382  -0.7802  -0.24806 #> HOVAL       -0.4794 -0.3497  -0.2860  -0.2203  -0.08916 #> lag.INC     -2.0803 -1.3131  -0.9206  -0.5438   0.27869 #> lambda       0.1355  0.3737   0.4987   0.6088   0.80100 #> sige        73.0279 94.1912 108.3141 125.5058 173.13320 #>  print(summary(impacts(COL.err.Bayes))) #> Impact measures (SDEM, MCMC, n): #>           Direct   Indirect      Total #> INC   -1.0321950 -0.9210334 -1.9532284 #> HOVAL -0.2860547         NA -0.2860547 #> ======================================================== #> Standard errors: #>           Direct  Indirect      Total #> INC   0.36744116 0.5661167 0.69838314 #> HOVAL 0.09570117        NA 0.09570117 #> ======================================================== #> Z-values: #>          Direct  Indirect     Total #> INC   -2.809144 -1.626932 -2.796786 #> HOVAL -2.989041        NA -2.989041 #>  #> p-values: #>       Direct    Indirect Total     #> INC   0.0049673 0.10375  0.0051614 #> HOVAL 0.0027985 NA       0.0027985 #>  print(raftery.diag(COL.err.Bayes, r=0.01)) #>  #> Quantile (q) = 0.025 #> Accuracy (r) = +/- 0.01 #> Probability (s) = 0.95  #>                                                     #>              Burn-in  Total Lower bound  Dependence #>              (M)      (N)   (Nmin)       factor (I) #>  (Intercept) 3        1010  937          1.080      #>  INC         2        930   937          0.993      #>  HOVAL       2        930   937          0.993      #>  lag.INC     2        930   937          0.993      #>  lambda      2        892   937          0.952      #>  sige        3        1010  937          1.080      #>  set.seed(1) COL.err.Bayes <- spBreg_err(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,  Durbin=~INC, control=list(prior=list(lambdaMH=TRUE))) print(summary(COL.err.Bayes)) #>  #> Iterations = 501:2500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 2000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean       SD Naive SE Time-series SE #> (Intercept)  72.7704 14.13707 0.316114       0.351470 #> INC          -0.9865  0.39508 0.008834       0.008834 #> HOVAL        -0.2904  0.09878 0.002209       0.002209 #> lag.INC      -0.8506  0.67466 0.015086       0.016187 #> lambda        0.5688  0.17577 0.003930       0.009250 #> sige        116.1069 27.61223 0.617428       0.789579 #>  #> 2. Quantiles for each variable: #>  #>                2.5%     25%      50%      75%     97.5% #> (Intercept) 40.6365 65.4333  73.7510  81.2815  97.03388 #> INC         -1.7216 -1.2471  -1.0006  -0.7335  -0.15124 #> HOVAL       -0.4820 -0.3577  -0.2903  -0.2257  -0.09267 #> lag.INC     -2.0923 -1.2942  -0.8863  -0.4615   0.58595 #> lambda       0.2251  0.4389   0.5731   0.6982   0.89484 #> sige        74.0162 96.6611 112.0106 130.7735 181.83168 #>  print(summary(impacts(COL.err.Bayes))) #> Impact measures (SDEM, MCMC, n): #>           Direct   Indirect      Total #> INC   -0.9865093 -0.8506053 -1.8371146 #> HOVAL -0.2904128         NA -0.2904128 #> ======================================================== #> Standard errors: #>           Direct  Indirect      Total #> INC   0.37860903 0.6465345 0.82479429 #> HOVAL 0.09466321        NA 0.09466321 #> ======================================================== #> Z-values: #>          Direct  Indirect     Total #> INC   -2.605615 -1.315638 -2.227361 #> HOVAL -3.067853        NA -3.067853 #>  #> p-values: #>       Direct   Indirect Total    #> INC   0.009171 0.1883   0.025923 #> HOVAL 0.002156 NA       0.002156 #>  print(raftery.diag(COL.err.Bayes, r=0.01)) #>  #> Quantile (q) = 0.025 #> Accuracy (r) = +/- 0.01 #> Probability (s) = 0.95  #>                                                     #>              Burn-in  Total Lower bound  Dependence #>              (M)      (N)   (Nmin)       factor (I) #>  (Intercept) 10       3436  937          3.670      #>  INC         2        930   937          0.993      #>  HOVAL       2        892   937          0.952      #>  lag.INC     3        1143  937          1.220      #>  lambda      13       3579  937          3.820      #>  sige        3        1096  937          1.170      #>  set.seed(1) COL.sacW.B0 <- spBreg_sac(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,  Durbin=FALSE, control=list(ndraw=1500L, nomit=500L)) print(summary(COL.sacW.B0)) #>  #> Iterations = 501:1500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 1000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean       SD Naive SE Time-series SE #> (Intercept)  49.3672  9.23725 0.292108       0.847100 #> INC          -0.9925  0.35777 0.011314       0.012624 #> HOVAL        -0.2847  0.09798 0.003099       0.003307 #> rho           0.3117  0.19633 0.006208       0.020392 #> lambda        0.1927  0.27130 0.008579       0.027162 #> sige        105.0462 23.96805 0.757936       0.757936 #>  #> 2. Quantiles for each variable: #>  #>                2.5%      25%      50%      75%    97.5% #> (Intercept) 31.8783 43.12583  48.9398  55.3573  68.1858 #> INC         -1.6817 -1.24459  -0.9872  -0.7516  -0.3168 #> HOVAL       -0.4952 -0.34433  -0.2827  -0.2201  -0.1028 #> rho         -0.1548  0.21285   0.3406   0.4438   0.6176 #> lambda      -0.3788  0.01455   0.2171   0.3794   0.6988 #> sige        68.5025 88.13909 101.6888 118.2545 160.2792 #>  print(summary(impacts(COL.sacW.B0, tr=trMatc), zstats=TRUE, short=TRUE)) #> Impact measures (sac, trace): #>          Direct   Indirect      Total #> INC   -1.017325 -0.4246675 -1.4419930 #> HOVAL -0.291816 -0.1218143 -0.4136303 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3668822 0.4180525 0.6533395 #> HOVAL 0.1016518 0.1341689 0.1983041 #>  #> Simulated z-values: #>          Direct  Indirect     Total #> INC   -2.808257 -1.219897 -2.357550 #> HOVAL -2.910868 -1.106171 -2.240542 #>  #> Simulated p-values: #>       Direct    Indirect Total    #> INC   0.0049810 0.22250  0.018396 #> HOVAL 0.0036043 0.26865  0.025056 set.seed(1) COL.sacW.B1 <- spBreg_sac(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw,  Durbin=TRUE, control=list(ndraw=1500L, nomit=500L)) print(summary(COL.sacW.B1)) #>  #> Iterations = 501:1500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 1000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean       SD Naive SE Time-series SE #> (Intercept)  60.1834 24.14830 0.763636       3.169805 #> INC          -0.9888  0.36234 0.011458       0.016240 #> HOVAL        -0.2861  0.09785 0.003094       0.003094 #> lag.INC      -0.8734  0.77381 0.024470       0.060097 #> lag.HOVAL     0.1735  0.21943 0.006939       0.013468 #> rho           0.1808  0.32007 0.010121       0.044327 #> lambda        0.2106  0.32071 0.010142       0.041657 #> sige        100.9463 24.32264 0.769149       0.946662 #>  #> 2. Quantiles for each variable: #>  #>                2.5%       25%     50%      75%    97.5% #> (Intercept) 22.2042 42.280965 56.1010  76.4887 113.5316 #> INC         -1.6963 -1.228821 -0.9813  -0.7271  -0.3299 #> HOVAL       -0.4747 -0.350819 -0.2877  -0.2214  -0.1097 #> lag.INC     -2.5274 -1.342333 -0.8558  -0.3281   0.5407 #> lag.HOVAL   -0.2876  0.037091  0.1824   0.3249   0.5910 #> rho         -0.5076 -0.021227  0.2386   0.4320   0.6655 #> lambda      -0.5106 -0.007594  0.2129   0.4482   0.7389 #> sige        64.6867 84.395156 96.9599 114.4101 159.7252 #>  print(summary(impacts(COL.sacW.B1, tr=trMatc), zstats=TRUE, short=TRUE)) #> Impact measures (sacmixed, trace): #>           Direct   Indirect      Total #> INC   -1.0341008 -1.2391410 -2.2732417 #> HOVAL -0.2808381  0.1434285 -0.1374096 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3510018 0.9466895 1.0370366 #> HOVAL 0.1010491 0.2773738 0.3171738 #>  #> Simulated z-values: #>          Direct   Indirect      Total #> INC   -2.966104 -1.4250264 -2.3048033 #> HOVAL -2.775326  0.5576145 -0.3965541 #>  #> Simulated p-values: #>       Direct    Indirect Total    #> INC   0.0030160 0.15415  0.021178 #> HOVAL 0.0055146 0.57711  0.691696 set.seed(1) COL.lag.Bayes <- spBreg_lag(CRIME ~ INC + HOVAL, data=COL.OLD,  listw=lw) print(summary(COL.lag.Bayes)) #>  #> Iterations = 501:2500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 2000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean       SD Naive SE Time-series SE #> (Intercept)  45.8256  8.04911 0.179984       0.179984 #> INC          -1.0459  0.34746 0.007770       0.007770 #> HOVAL        -0.2662  0.09366 0.002094       0.002094 #> rho           0.4146  0.12434 0.002780       0.002780 #> sige        107.8827 23.75095 0.531087       0.561152 #>  #> 2. Quantiles for each variable: #>  #>                2.5%     25%      50%      75%     97.5% #> (Intercept) 30.3334 40.3140  45.9376  51.0903  61.51008 #> INC         -1.7252 -1.2774  -1.0477  -0.8158  -0.35423 #> HOVAL       -0.4533 -0.3312  -0.2686  -0.2019  -0.08107 #> rho          0.1645  0.3327   0.4157   0.5008   0.64982 #> sige        70.5778 90.6316 104.8556 120.4706 164.75421 #>  print(summary(impacts(COL.lag.Bayes, tr=trMatc), short=TRUE, zstats=TRUE)) #> Impact measures (lag, trace): #>           Direct   Indirect      Total #> INC   -1.0962113 -0.6903627 -1.7865741 #> HOVAL -0.2790451 -0.1757347 -0.4547797 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3680189 0.4927553 0.7674941 #> HOVAL 0.1002735 0.1393959 0.2171077 #>  #> Simulated z-values: #>          Direct  Indirect     Total #> INC   -3.003178 -1.554252 -2.437925 #> HOVAL -2.809370 -1.425055 -2.212507 #>  #> Simulated p-values: #>       Direct    Indirect Total    #> INC   0.0026718 0.12012  0.014772 #> HOVAL 0.0049639 0.15414  0.026932 print(summary(impacts(COL.lag.Bayes, evalues=ev), short=TRUE, zstats=TRUE)) #> Impact measures (lag, evalues): #>           Direct   Indirect      Total #> INC   -1.0962113 -0.6903627 -1.7865741 #> HOVAL -0.2790451 -0.1757347 -0.4547797 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3680193 0.4929524 0.7676307 #> HOVAL 0.1002746 0.1395496 0.2172252 #>  #> Simulated z-values: #>          Direct  Indirect     Total #> INC   -3.003178 -1.553686 -2.437527 #> HOVAL -2.809345 -1.423571 -2.211367 #>  #> Simulated p-values: #>       Direct    Indirect Total    #> INC   0.0026718 0.12026  0.014788 #> HOVAL 0.0049642 0.15457  0.027010 set.seed(1) COL.D0.Bayes <- spBreg_lag(CRIME ~ INC + HOVAL, data=COL.OLD,  listw=lw, Durbin=TRUE) print(summary(COL.D0.Bayes)) #>  #> Iterations = 501:2500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 2000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean       SD Naive SE Time-series SE #> (Intercept)  45.3105 13.74662 0.307384       0.307384 #> INC          -0.9246  0.36837 0.008237       0.008237 #> HOVAL        -0.2959  0.09778 0.002187       0.002126 #> lag.INC      -0.5917  0.63940 0.014297       0.014297 #> lag.HOVAL     0.2443  0.18959 0.004239       0.004239 #> rho           0.3932  0.16296 0.003644       0.003644 #> sige        109.7428 24.97328 0.558419       0.607251 #>  #> 2. Quantiles for each variable: #>  #>                 2.5%     25%      50%      75%    97.5% #> (Intercept) 19.18483 35.9928  45.0377  54.5246  72.8590 #> INC         -1.62602 -1.1728  -0.9198  -0.6633  -0.2117 #> HOVAL       -0.48546 -0.3597  -0.2944  -0.2310  -0.1012 #> lag.INC     -1.83696 -1.0334  -0.5786  -0.1739   0.6326 #> lag.HOVAL   -0.13032  0.1164   0.2417   0.3715   0.6133 #> rho          0.06053  0.2826   0.3977   0.5078   0.6949 #> sige        71.19421 91.4872 106.1690 123.7826 170.9503 #>  print(summary(impacts(COL.D0.Bayes, tr=trMatc), short=TRUE, zstats=TRUE)) #> Impact measures (mixed, trace): #>           Direct  Indirect       Total #> INC   -1.0277896 -1.471320 -2.49911007 #> HOVAL -0.2820493  0.197023 -0.08502627 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3831777 1.3179822 1.4600855 #> HOVAL 0.1017455 0.3302926 0.3686927 #>  #> Simulated z-values: #>          Direct   Indirect      Total #> INC   -2.735660 -1.2618796 -1.8570000 #> HOVAL -2.785094  0.5880284 -0.2417988 #>  #> Simulated p-values: #>       Direct    Indirect Total    #> INC   0.0062255 0.20699  0.063311 #> HOVAL 0.0053512 0.55651  0.808936 set.seed(1) COL.D1.Bayes <- spBreg_lag(CRIME ~ DISCBD + INC + HOVAL, data=COL.OLD,  listw=lw, Durbin= ~ INC) print(summary(COL.D1.Bayes)) #>  #> Iterations = 501:2500 #> Thinning interval = 1  #> Number of chains = 1  #> Sample size per chain = 2000  #>  #> 1. Empirical mean and standard deviation for each variable, #>    plus standard error of the mean: #>  #>                 Mean       SD Naive SE Time-series SE #> (Intercept)  56.4193 13.40915 0.299838       0.299838 #> DISCBD       -4.7794  2.14113 0.047877       0.047877 #> INC          -0.9422  0.34677 0.007754       0.007754 #> HOVAL        -0.1806  0.09837 0.002200       0.002200 #> lag.INC       0.4213  0.63243 0.014141       0.014141 #> rho           0.1873  0.18174 0.004064       0.004064 #> sige        103.8701 23.29384 0.520866       0.566802 #>  #> 2. Quantiles for each variable: #>  #>                2.5%       25%      50%      75%      97.5% #> (Intercept) 30.6341 47.656256  56.4238  65.0877  84.808823 #> DISCBD      -9.2565 -6.160525  -4.7536  -3.3735  -0.714089 #> INC         -1.6336 -1.174123  -0.9427  -0.7090  -0.263713 #> HOVAL       -0.3719 -0.247402  -0.1791  -0.1148   0.006329 #> lag.INC     -0.8379 -0.005461   0.4129   0.8399   1.648619 #> rho         -0.2116  0.072536   0.1836   0.3067   0.535793 #> sige        67.8946 87.054945 100.9815 116.4528 161.258258 #>  print(summary(impacts(COL.D1.Bayes, tr=trMatc), short=TRUE, zstats=TRUE)) #> Impact measures (mixed, trace): #>            Direct    Indirect      Total #> DISCBD -4.8194767 -1.06169757 -5.8811743 #> INC    -0.9312352  0.29032298 -0.6409122 #> HOVAL  -0.1821150 -0.04011868 -0.2222336 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>           Direct   Indirect     Total #> DISCBD 2.1896626 1.82105239 3.3751922 #> INC    0.3494541 0.81612759 0.8914013 #> HOVAL  0.1001927 0.06787487 0.1430090 #>  #> Simulated z-values: #>           Direct   Indirect      Total #> DISCBD -2.224202 -0.7454394 -1.8451502 #> INC    -2.683306  0.3286082 -0.7510717 #> HOVAL  -1.835800 -0.7422472 -1.6384544 #>  #> Simulated p-values: #>        Direct    Indirect Total    #> DISCBD 0.0261348 0.45601  0.065016 #> INC    0.0072898 0.74245  0.452610 #> HOVAL  0.0663872 0.45794  0.101327 #data(elect80, package=\"spData\") #lw <- spdep::nb2listw(e80_queen, zero.policy=TRUE) #el_ml <- lagsarlm(log(pc_turnout) ~ log(pc_college) + log(pc_homeownership) # + log(pc_income), data=elect80, listw=lw, zero.policy=TRUE, method=\"LU\") #print(summary(el_ml)) #set.seed(1) #el_B <- spBreg_lag(log(pc_turnout) ~ log(pc_college) + log(pc_homeownership) # + log(pc_income), data=elect80, listw=lw, zero.policy=TRUE) #print(summary(el_B)) #print(el_ml$timings) #print(attr(el_B, \"timings\")) # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/SLX.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial Durbin linear (SLX, spatially lagged X) model — lmSLX","title":"Spatial Durbin linear (SLX, spatially lagged X) model — lmSLX","text":"lmSLX fits lm model augmented spatially lagged RHS variables, including lagged intercept spatial weights row-standardised. create_WX creates spatially lagged RHS variables, exposed use model fitting functions.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SLX.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial Durbin linear (SLX, spatially lagged X) model — lmSLX","text":"","code":"lmSLX(formula, data = list(), listw, na.action, weights=NULL, Durbin=TRUE,  zero.policy=NULL, return_impacts=TRUE) # S3 method for class 'SlX' print(x, digits = max(3L, getOption(\"digits\") - 3L), ...) # S3 method for class 'SlX' summary(object, correlation = FALSE, symbolic.cor = FALSE, ...) # S3 method for class 'summary.SlX' print(x, digits = max(3L, getOption(\"digits\") - 3L),  symbolic.cor = x$symbolic.cor, signif.stars = getOption(\"show.signif.stars\"), ...) # S3 method for class 'SlX' impacts(obj, ...) # S3 method for class 'WXimpact' print(x, ...) # S3 method for class 'WXimpact' summary(object, ..., adjust_k=(attr(object, \"type\") == \"SDEM\")) # S3 method for class 'SlX' predict(object, newdata, listw, zero.policy=NULL, ...) create_WX(x, listw, zero.policy=NULL, prefix=\"\")"},{"path":"https://r-spatial.github.io/spatialreg/reference/SLX.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial Durbin linear (SLX, spatially lagged X) model — lmSLX","text":"formula symbolic description model fit. details model specification given lm() data optional data frame containing variables model. default variables taken environment function called. listw listw object created example nb2listw na.action function (default options(\"na.action\")), can also na.omit na.exclude consequences residuals fitted values - cases spatial weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. weights optional vector weights used fitting process. Non-NULL weights can used indicate different observations different variances (values weights inversely proportional variances); equivalently, elements weights positive integers w_i, response y_i mean w_i unit-weight observations (including case w_i observations equal y_i data summarized) - lm Durbin default TRUE lmSLX (Durbin model including WX); TRUE, full spatial Durbin model; formula object, subset explanatory variables lag zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA return_impacts default TRUE; may set FALSE avoid problems calculating impacts aliased variables digits number significant digits use printing correlation logical; TRUE, correlation matrix estimated parameters returned printed symbolic.cor logical. TRUE, print correlations symbolic form (see 'symnum') rather numbers signif.stars logical. TRUE, 'significance stars' printed coefficient obj spatial regression object created lmSLX ... Arguments passed prefix default empty string, may “lag” cases x, object model matrix lagged; lagImpact objects created impacts methods adjust_k default TRUE SDEM else FALSE, adjust internal OLS SDEM standard errors dividing n rather (n-k) (default changed bug fixed 0.7-8; standard errors now ML SDEM summary impacts summary identical - SLX use FALSE) newdata data frame predict — NULL, predictions data model fitted. row names corresponding region.id. row names exactly ones used training, uses -sample predictors forecast.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SLX.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial Durbin linear (SLX, spatially lagged X) model — lmSLX","text":"lmSLX function returns “lm” object “mixedImps” list three impact matrixes (impacts standard errors) direct, indirect total impacts; total impacts calculated using simplified local copy estimable function gmodels package.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/SLX.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial Durbin linear (SLX, spatially lagged X) model — lmSLX","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SLX.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial Durbin linear (SLX, spatially lagged X) model — lmSLX","text":"","code":"data(oldcol, package=\"spdep\") lw <- spdep::nb2listw(COL.nb, style=\"W\") COL.SLX <- lmSLX(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw) summary(COL.SLX) #>  #> Call: #> lm(formula = formula(paste(\"y ~ \", paste(colnames(x)[-1], collapse = \"+\"))),  #>     data = as.data.frame(x), weights = weights) #>  #> Coefficients: #>              Estimate    Std. Error  t value     Pr(>|t|)   #> (Intercept)   7.503e+01   6.626e+00   1.132e+01   1.261e-14 #> INC          -1.109e+00   3.738e-01  -2.967e+00   4.854e-03 #> HOVAL        -2.897e-01   1.014e-01  -2.858e+00   6.486e-03 #> lag.INC      -1.371e+00   5.613e-01  -2.443e+00   1.867e-02 #> lag.HOVAL     1.918e-01   2.003e-01   9.572e-01   3.437e-01 #>  summary(impacts(COL.SLX)) #> Impact measures (SlX, glht, n-k): #>           Direct   Indirect       Total #> INC   -1.1089293 -1.3709725 -2.47990173 #> HOVAL -0.2897283  0.1917608 -0.09796753 #> ======================================================== #> Standard errors: #>          Direct  Indirect     Total #> INC   0.3738129 0.5612771 0.4965456 #> HOVAL 0.1013673 0.2003335 0.2028016 #> ======================================================== #> Z-values: #>          Direct   Indirect      Total #> INC   -2.966535 -2.4425945 -4.9943086 #> HOVAL -2.858202  0.9572079 -0.4830709 #>  #> p-values: #>       Direct    Indirect Total      #> INC   0.0030118 0.014582 5.9047e-07 #> HOVAL 0.0042605 0.338462 0.62905    #>  COL.SLX <- lmSLX(CRIME ~ INC + HOVAL + I(HOVAL^2), data=COL.OLD, listw=lw, Durbin=TRUE) summary(impacts(COL.SLX)) #> Impact measures (SlX, glht, n-k): #>                  Direct     Indirect       Total #> INC        -0.947594274 -1.275338647 -2.22293292 #> HOVAL      -0.777427839 -0.355048446 -1.13247628 #> I(HOVAL^2)  0.004639919  0.005608104  0.01024802 #> ======================================================== #> Standard errors: #>                 Direct   Indirect      Total #> INC        0.398832844 0.59687399 0.56325440 #> HOVAL      0.464456540 0.98213200 1.07348981 #> I(HOVAL^2) 0.004226259 0.00908385 0.01025212 #> ======================================================== #> Z-values: #>               Direct   Indirect      Total #> INC        -2.375918 -2.1366966 -3.9465877 #> HOVAL      -1.673844 -0.3615079 -1.0549483 #> I(HOVAL^2)  1.097879  0.6173709  0.9996008 #>  #> p-values: #>            Direct   Indirect Total      #> INC        0.017505 0.032623 7.9273e-05 #> HOVAL      0.094161 0.717720 0.29145    #> I(HOVAL^2) 0.272258 0.536990 0.31750    #>  summary(COL.SLX) #>  #> Call: #> lm(formula = formula(paste(\"y ~ \", paste(colnames(x)[-1], collapse = \"+\"))),  #>     data = as.data.frame(x), weights = weights) #>  #> Coefficients: #>                 Estimate    Std. Error  t value     Pr(>|t|)   #> (Intercept)      9.246e+01   1.928e+01   4.796e+00   2.058e-05 #> INC             -9.476e-01   3.988e-01  -2.376e+00   2.214e-02 #> HOVAL           -7.774e-01   4.645e-01  -1.674e+00   1.016e-01 #> I.HOVAL.2.       4.640e-03   4.226e-03   1.098e+00   2.785e-01 #> lag.INC         -1.275e+00   5.969e-01  -2.137e+00   3.849e-02 #> lag.HOVAL       -3.550e-01   9.821e-01  -3.615e-01   7.195e-01 #> lag.I.HOVAL.2.   5.608e-03   9.084e-03   6.174e-01   5.403e-01 #>  COL.SLX <- lmSLX(CRIME ~ INC + HOVAL + I(HOVAL^2), data=COL.OLD, listw=lw, Durbin=~INC) summary(impacts(COL.SLX)) #> Impact measures (SlX, glht, n-k): #>                  Direct  Indirect        Total #> INC        -1.079064628 -1.010896 -2.089960575 #> HOVAL      -0.634518755        NA -0.634518755 #> I(HOVAL^2)  0.003455273        NA  0.003455273 #> ======================================================== #> Standard errors: #>                Direct  Indirect      Total #> INC        0.38471071 0.4552667 0.44650193 #> HOVAL      0.44760078        NA 0.44760078 #> I(HOVAL^2) 0.00411036        NA 0.00411036 #> ======================================================== #> Z-values: #>                Direct  Indirect      Total #> INC        -2.8048728 -2.220448 -4.6807425 #> HOVAL      -1.4175997        NA -1.4175997 #> I(HOVAL^2)  0.8406254        NA  0.8406254 #>  #> p-values: #>            Direct    Indirect Total      #> INC        0.0050336 0.026388 2.8584e-06 #> HOVAL      0.1563077 NA       0.15631    #> I(HOVAL^2) 0.4005579 NA       0.40056    #>  summary(COL.SLX) #>  #> Call: #> lm(formula = formula(paste(\"y ~ \", paste(colnames(x)[-1], collapse = \"+\"))),  #>     data = as.data.frame(x), weights = weights) #>  #> Coefficients: #>              Estimate    Std. Error  t value     Pr(>|t|)   #> (Intercept)   8.368e+01   9.265e+00   9.032e+00   1.401e-11 #> INC          -1.079e+00   3.847e-01  -2.805e+00   7.466e-03 #> HOVAL        -6.345e-01   4.476e-01  -1.418e+00   1.634e-01 #> I.HOVAL.2.    3.455e-03   4.110e-03   8.406e-01   4.051e-01 #> lag.INC      -1.011e+00   4.553e-01  -2.220e+00   3.159e-02 #>  COL.SLX <- lmSLX(CRIME ~ INC, data=COL.OLD, listw=lw) summary(COL.SLX) #>  #> Call: #> lm(formula = formula(paste(\"y ~ \", paste(colnames(x)[-1], collapse = \"+\"))),  #>     data = as.data.frame(x), weights = weights) #>  #> Coefficients: #>              Estimate    Std. Error  t value     Pr(>|t|)   #> (Intercept)   7.398e+01   6.208e+00   1.192e+01   1.155e-15 #> INC          -1.589e+00   3.564e-01  -4.458e+00   5.276e-05 #> lag.INC      -1.086e+00   4.812e-01  -2.257e+00   2.882e-02 #>  summary(impacts(COL.SLX)) #> Impact measures (SlX, glht, n-k): #>        Direct  Indirect     Total #> INC -1.588901 -1.085867 -2.674768 #> ======================================================== #> Standard errors: #>        Direct  Indirect    Total #> INC 0.3564039 0.4811809 0.407313 #> ======================================================== #> Z-values: #>        Direct  Indirect     Total #> INC -4.458147 -2.256671 -6.566861 #>  #> p-values: #>     Direct     Indirect Total      #> INC 8.2671e-06 0.024029 5.1387e-11 #>  # \\dontrun{ crds <- cbind(COL.OLD$X, COL.OLD$Y) mdist <- sqrt(sum(diff(apply(crds, 2, range))^2)) dnb <- spdep::dnearneigh(crds, 0, mdist) dists <- spdep::nbdists(dnb, crds) f <- function(x, form, data, dnb, dists, verbose) {   glst <- lapply(dists, function(d) 1/(d^x))   lw <- spdep::nb2listw(dnb, glist=glst, style=\"B\")   res <- logLik(lmSLX(form=form, data=data, listw=lw))   if (verbose) cat(\"power:\", x, \"logLik:\", res, \"\\n\")   res } opt <- optimize(f, interval=c(0.1, 4), form=CRIME ~ INC + HOVAL,  data=COL.OLD, dnb=dnb, dists=dists, verbose=TRUE, maximum=TRUE) #> power: 1.589667 logLik: -172.6864  #> power: 2.510333 logLik: -177.741  #> power: 1.020665 logLik: -171.5379  #> power: 0.8721475 logLik: -171.7979  #> power: 1.11302 logLik: -171.4973  #> power: 1.107329 logLik: -171.497  #> power: 1.105705 logLik: -171.497  #> power: 1.105746 logLik: -171.497  #> power: 1.105664 logLik: -171.497  #> power: 1.105705 logLik: -171.497  glst <- lapply(dists, function(d) 1/(d^opt$maximum)) lw <- spdep::nb2listw(dnb, glist=glst, style=\"B\") SLX <- lmSLX(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw) summary(SLX) #>  #> Call: #> lm(formula = formula(paste(\"y ~ \", paste(colnames(x)[-1], collapse = \"+\"))),  #>     data = as.data.frame(x), weights = weights) #>  #> Coefficients: #>                  Estimate  Std. Error  t value   Pr(>|t|) #> (Intercept)      18.78498  11.23795     1.67157   0.10187 #> INC              -0.65428   0.29463    -2.22064   0.03169 #> HOVAL            -0.18244   0.08138    -2.24174   0.03019 #> lag..Intercept.   6.27790   4.44284     1.41304   0.16484 #> lag.INC          -0.12958   0.28794    -0.45002   0.65496 #> lag.HOVAL         0.02668   0.11273     0.23664   0.81406 #>  summary(impacts(SLX)) #> Impact measures (SlX, glht, n-k): #>           Direct    Indirect      Total #> INC   -0.6542760 -0.12957739 -0.7838534 #> HOVAL -0.1824383  0.02667561 -0.1557627 #> ======================================================== #> Standard errors: #>           Direct  Indirect     Total #> INC   0.29463342 0.2879383 0.3742251 #> HOVAL 0.08138257 0.1127279 0.1404591 #> ======================================================== #> Z-values: #>          Direct   Indirect     Total #> INC   -2.220644 -0.4500179 -2.094604 #> HOVAL -2.241736  0.2366371 -1.108954 #>  #> p-values: #>       Direct   Indirect Total    #> INC   0.026375 0.65270  0.036206 #> HOVAL 0.024978 0.81294  0.267450 #>  # } COL.SLX <- lmSLX(CRIME ~ INC + HOVAL, data=COL.OLD, listw=lw) pslx0 <- predict(COL.SLX) pslx1 <- predict(COL.SLX, newdata=COL.OLD, listw=lw) #> Error in predict.SlX(COL.SLX, newdata = COL.OLD, listw = lw): mismatch between newdata and spatial weights. newdata should have region.id as row.names all.equal(pslx0, pslx1) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'current' in selecting a method for function 'all.equal': object 'pslx1' not found COL.OLD1 <- COL.OLD COL.OLD1$INC <- COL.OLD1$INC + 1 pslx2 <- predict(COL.SLX, newdata=COL.OLD1, listw=lw) #> Error in predict.SlX(COL.SLX, newdata = COL.OLD1, listw = lw): mismatch between newdata and spatial weights. newdata should have region.id as row.names sum(coef(COL.SLX)[c(2,4)]) #> [1] 5.623621 mean(pslx2-pslx1) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'mean': object 'pslx2' not found"},{"path":"https://r-spatial.github.io/spatialreg/reference/SpatialFiltering.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-parametric spatial filtering — SpatialFiltering","title":"Semi-parametric spatial filtering — SpatialFiltering","text":"function selects eigenvectors semi-parametric spatial filtering approach removing spatial dependence linear models. Selection brute force finding single eigenvector reducing standard variate Moran's regression residuals , continuing candidate eigenvector reduces value tol. returns summary table selection process matrix selected eigenvectors specified model.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SpatialFiltering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-parametric spatial filtering — SpatialFiltering","text":"","code":"SpatialFiltering(formula, lagformula=NULL, data=list(), na.action=na.fail,  nb=NULL, glist = NULL,  style = \"C\", zero.policy = NULL, tol = 0.1, zerovalue = 1e-04,  ExactEV = FALSE, symmetric = TRUE, alpha=NULL, alternative=\"two.sided\",  verbose=NULL)"},{"path":"https://r-spatial.github.io/spatialreg/reference/SpatialFiltering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-parametric spatial filtering — SpatialFiltering","text":"formula symbolic description model fit, assuming spatial error representation; lagformula given, include response intercept term lagformula extra one-sided formula used spatial lag representation desired; intercept excluded within function present part formula argument, excluding explicitly lagformula argument presence factors generates collinear model matrix data optional data frame containing variables model nb object class nb glist list general weights corresponding neighbours style style can take values W, B, C, U, S na.action function (default options(\"na.action\")), can also na.omit na.exclude consequences residuals fitted values - cases spatial weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors tol tolerance value convergence spatial filtering zerovalue eigenvectors eigenvalues absolute value smaller zerovalue excluded eigenvector search ExactEV Set ExactEV=TRUE use exact expectations variances rather expectation variance Moran's previous iteration, default FALSE symmetric spatial weights matrix forced symmetry, default TRUE alpha NULL, used instead tol= argument stopping rule choose eigenvectors including one probability value exceeding alpha. alternative character string specifying alternative hypothesis, must one greater, less two.sided (default). verbose default NULL, use global option value; TRUE report eigenvectors selected","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SpatialFiltering.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-parametric spatial filtering — SpatialFiltering","text":"SfResult object, : selection matrix summarising selection eigenvectors inclusion, columns: Step Step counter selection procedure SelEvec number selected eigenvector (sorted descending) Eval associated eigenvalue MinMi value Moran's residual autocorrelation ZMinMi standardized value Moran's assuming normal approximation pr(ZI) probability value permutation-based standardized deviate given value alternative argument R2 R^2 model including exogenous variables eigenvectors gamma regression coefficient selected eigenvector fit first row value start search dataset matrix selected eigenvectors order selection","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SpatialFiltering.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Semi-parametric spatial filtering — SpatialFiltering","text":"Tiefelsdorf M, Griffith DA. (2007) Semiparametric Filtering Spatial Autocorrelation: Eigenvector Approach. Environment Planning , 39 (5) 1193 - 1221.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/SpatialFiltering.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Semi-parametric spatial filtering — SpatialFiltering","text":"Yongwan Chun, Michael Tiefelsdorf, Roger Bivand","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/SpatialFiltering.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-parametric spatial filtering — SpatialFiltering","text":"","code":"require(\"sf\", quietly=TRUE) columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) #require(\"spdep\", quietly=TRUE) col.gal.nb <- spdep::read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) lmbase <- lm(CRIME ~ INC + HOVAL, data=columbus) sarcol <- SpatialFiltering(CRIME ~ INC + HOVAL, data=columbus,  nb=col.gal.nb, style=\"W\", ExactEV=TRUE) sarcol #>   Step SelEvec      Eval        MinMi      ZMinMi      Pr(ZI)        R2 #> 0    0       0 0.0000000  0.212374153  2.68100025 0.007340246 0.5524040 #> 1    1       5 0.7148326  0.121528166  1.89037770 0.058707464 0.6209393 #> 2    2       3 0.8408661  0.065848648  1.54064108 0.123404165 0.6481722 #> 3    3       1 1.0206316 -0.005424824  1.08514557 0.277857187 0.6726114 #> 4    4      10 0.3658588 -0.039356232  0.80357070 0.421644951 0.7000258 #> 5    5      14 0.1831325 -0.072949543  0.47790213 0.632719864 0.7393770 #> 6    6      11 0.3144120 -0.108332631  0.18566599 0.852706701 0.7611907 #> 7    7       2 0.9157325 -0.153675621 -0.03464097 0.972366030 0.7713163 #>       gamma #> 0   0.00000 #> 1  30.34786 #> 2  19.13010 #> 3 -18.12234 #> 4 -19.19379 #> 5 -22.99586 #> 6  17.12127 #> 7  11.66487 lmsar <- lm(CRIME ~ INC + HOVAL + fitted(sarcol), data=columbus) (x <- summary(lmsar)) #>  #> Call: #> lm(formula = CRIME ~ INC + HOVAL + fitted(sarcol), data = columbus) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -27.6527  -5.3084   0.0804   5.6844  15.6912  #>  #> Coefficients: #>                      Estimate Std. Error t value Pr(>|t|)     #> (Intercept)          68.61896    3.67609  18.666  < 2e-16 *** #> INC                  -1.59731    0.25938  -6.158 3.12e-07 *** #> HOVAL                -0.27393    0.08011  -3.419  0.00148 **  #> fitted(sarcol)vec5   30.34786    8.87679   3.419  0.00149 **  #> fitted(sarcol)vec3   19.13010    8.87679   2.155  0.03739 *   #> fitted(sarcol)vec1  -18.12234    8.87679  -2.042  0.04800 *   #> fitted(sarcol)vec10 -19.19379    8.87679  -2.162  0.03679 *   #> fitted(sarcol)vec14 -22.99586    8.87679  -2.591  0.01341 *   #> fitted(sarcol)vec11  17.12127    8.87679   1.929  0.06106 .   #> fitted(sarcol)vec2   11.66487    8.87679   1.314  0.19649     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 8.877 on 39 degrees of freedom #> Multiple R-squared:  0.7713,\tAdjusted R-squared:  0.7185  #> F-statistic: 14.62 on 9 and 39 DF,  p-value: 5.579e-10 #>  coef(x) #>                        Estimate Std. Error   t value     Pr(>|t|) #> (Intercept)          68.6189611 3.67608656 18.666307 4.802352e-21 #> INC                  -1.5973108 0.25938068 -6.158172 3.122801e-07 #> HOVAL                -0.2739315 0.08011158 -3.419374 1.483698e-03 #> fitted(sarcol)vec5   30.3478552 8.87679493  3.418785 1.486164e-03 #> fitted(sarcol)vec3   19.1300996 8.87679493  2.155068 3.738943e-02 #> fitted(sarcol)vec1  -18.1223409 8.87679493 -2.041541 4.800339e-02 #> fitted(sarcol)vec10 -19.1937947 8.87679493 -2.162244 3.679422e-02 #> fitted(sarcol)vec14 -22.9958588 8.87679493 -2.590559 1.340783e-02 #> fitted(sarcol)vec11  17.1212741 8.87679493  1.928768 6.106079e-02 #> fitted(sarcol)vec2   11.6648669 8.87679493  1.314085 1.964945e-01 anova(lmbase, lmsar) #> Analysis of Variance Table #>  #> Model 1: CRIME ~ INC + HOVAL #> Model 2: CRIME ~ INC + HOVAL + fitted(sarcol) #>   Res.Df    RSS Df Sum of Sq      F    Pr(>F)     #> 1     46 6014.9                                   #> 2     39 3073.1  7    2941.8 5.3334 0.0002445 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 spdep::lm.morantest(lmsar, spdep::nb2listw(col.gal.nb)) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = CRIME ~ INC + HOVAL + fitted(sarcol), data = #> columbus) #> weights: spdep::nb2listw(col.gal.nb) #>  #> Moran I statistic standard deviate = -0.034641, p-value = 0.5138 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>     -0.153675621     -0.150918131      0.006336477  #>  lagcol <- SpatialFiltering(CRIME ~ 1, ~ INC + HOVAL - 1, data=columbus,  nb=col.gal.nb, style=\"W\") lagcol #>    Step SelEvec      Eval       MinMi      ZMinMi      Pr(ZI)        R2 #> 0     0       0 0.0000000  0.21237415  2.68100025 0.007340246 0.5524040 #> 1     1       6 0.7161123  0.11782248  1.84511963 0.065020139 0.6038801 #> 2     2       4 0.8682938  0.06242664  1.49482111 0.134961136 0.6531288 #> 3     3       1 1.0310063 -0.02066604  0.88134183 0.378132834 0.6924845 #> 4     4       5 0.7905397 -0.04619973  0.84746904 0.396733736 0.7136578 #> 5     5      15 0.1753342 -0.07609524  0.55233191 0.580720971 0.7558543 #> 6     6       9 0.5501433 -0.10190889  0.43919419 0.660520837 0.7626784 #> 7     7       8 0.5721041 -0.12232942  0.41846803 0.675604953 0.7757314 #> 8     8       3 0.9026222 -0.14991822  0.38315383 0.701605709 0.7908693 #> 9     9       2 0.9649166 -0.21756342 -0.28556733 0.775209527 0.8078727 #> 10   10       7 0.6219404 -0.22017920 -0.04856547 0.961265592 0.8082842 #>         gamma #> 0    0.000000 #> 1   19.848854 #> 2   35.542595 #> 3  -30.697851 #> 4  -24.540372 #> 5   25.227798 #> 6    7.590082 #> 7  -16.933168 #> 8  -20.556931 #> 9  -18.434534 #> 10  -2.597572 lmlag <- lm(CRIME ~ INC + HOVAL + fitted(lagcol), data=columbus) lmlag #>  #> Call: #> lm(formula = CRIME ~ INC + HOVAL + fitted(lagcol), data = columbus) #>  #> Coefficients: #>         (Intercept)                  INC                HOVAL   #>             56.7977              -0.4857              -0.3821   #>  fitted(lagcol)vec6   fitted(lagcol)vec4   fitted(lagcol)vec1   #>             19.8489              35.5426             -30.6979   #>  fitted(lagcol)vec5  fitted(lagcol)vec15   fitted(lagcol)vec9   #>            -24.5404              25.2278               7.5901   #>  fitted(lagcol)vec8   fitted(lagcol)vec3   fitted(lagcol)vec2   #>            -16.9332             -20.5569             -18.4345   #>  fitted(lagcol)vec7   #>             -2.5976   #>  anova(lmbase, lmlag) #> Analysis of Variance Table #>  #> Model 1: CRIME ~ INC + HOVAL #> Model 2: CRIME ~ INC + HOVAL + fitted(lagcol) #>   Res.Df    RSS Df Sum of Sq      F    Pr(>F)     #> 1     46 6014.9                                   #> 2     36 2576.3 10    3438.6 4.8049 0.0002165 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 spdep::lm.morantest(lmlag, spdep::nb2listw(col.gal.nb)) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = CRIME ~ INC + HOVAL + fitted(lagcol), data = #> columbus) #> weights: spdep::nb2listw(col.gal.nb) #>  #> Moran I statistic standard deviate = -0.048565, p-value = 0.5194 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>     -0.220179195     -0.217083975      0.004061888  #>  NA.columbus <- columbus NA.columbus$CRIME[20:25] <- NA COL.SF.NA <- SpatialFiltering(CRIME ~ INC + HOVAL, data=NA.columbus,  nb=col.gal.nb, style=\"W\", na.action=na.exclude) #> Warning: subsetting caused increase in subgraph count COL.SF.NA$na.action #> 20 21 22 23 24 25  #> 20 21 22 23 24 25  #> attr(,\"class\") #> [1] \"exclude\" summary(lm(CRIME ~ INC + HOVAL + fitted(COL.SF.NA), data=NA.columbus,  na.action=na.exclude)) #>  #> Call: #> lm(formula = CRIME ~ INC + HOVAL + fitted(COL.SF.NA), data = NA.columbus,  #>     na.action = na.exclude) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -23.6712  -4.7984   0.1761   6.7460  11.3353  #>  #> Coefficients: #>                     Estimate Std. Error t value Pr(>|t|)     #> (Intercept)         69.04674    3.91643  17.630  < 2e-16 *** #> INC                 -1.60115    0.26017  -6.154 3.88e-07 *** #> HOVAL               -0.28742    0.07716  -3.725 0.000649 *** #> fitted(COL.SF.NA)1 -39.91305    8.23597  -4.846 2.27e-05 *** #> fitted(COL.SF.NA)2  19.81805    8.23597   2.406 0.021226 *   #> fitted(COL.SF.NA)3 -35.07336    8.23597  -4.259 0.000135 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 8.236 on 37 degrees of freedom #>   (6 observations deleted due to missingness) #> Multiple R-squared:  0.7772,\tAdjusted R-squared:  0.7471  #> F-statistic: 25.81 on 5 and 37 DF,  p-value: 3.996e-11 #>"},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate profile-likelihood estimator (APLE) — aple","title":"Approximate profile-likelihood estimator (APLE) — aple","text":"Approximate profile-likelihood estimator (APLE) simultaneous autoregressive model's spatial dependence parameter introduced Li et al. (2007). employs correction term using eigenvalues spatial weights matrix, consequently used large numbers observations. also requires variable mean zero, assumed detrended. spatial weights object assumed row-standardised, using default style=\"W\" nb2listw.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate profile-likelihood estimator (APLE) — aple","text":"","code":"aple(x, listw, override_similarity_check=FALSE, useTrace=TRUE)"},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate profile-likelihood estimator (APLE) — aple","text":"x zero-mean detrended continuous variable listw listw object example spdep::nb2listw override_similarity_check default FALSE, TRUE - typically row-standardised weights asymmetric underlying general weights - similarity checked useTrace default TRUE, use trace sparse matrix W %*% W (Li et al. (2010)), FALSE, use crossproduct eigenvalues W Li et al. (2007)","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Approximate profile-likelihood estimator (APLE) — aple","text":"implementation checked Hongfei Li's implementation using data; help valuable.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate profile-likelihood estimator (APLE) — aple","text":"scalar APLE value.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Approximate profile-likelihood estimator (APLE) — aple","text":"Li, H, Calder, C. . Cressie N. . C. (2007) Beyond Moran's : testing spatial dependence based spatial autoregressive model. Geographical Analysis 39, 357-375; Li, H, Calder, C. . Cressie N. . C. (2012) One-step estimation spatial dependence parameters: Properties extensions APLE statistic, Journal Multivariate Analysis 105, 68-84.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Approximate profile-likelihood estimator (APLE) — aple","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate profile-likelihood estimator (APLE) — aple","text":"","code":"wheat <- st_read(system.file(\"shapes/wheat.gpkg\", package=\"spData\")[1], quiet=TRUE) library(spdep) #>  #> Attaching package: ‘spdep’ #> The following objects are masked from ‘package:spatialreg’: #>  #>     get.ClusterOption, get.VerboseOption, get.ZeroPolicyOption, #>     get.coresOption, get.mcOption, set.ClusterOption, #>     set.VerboseOption, set.ZeroPolicyOption, set.coresOption, #>     set.mcOption nbr1 <- spdep::poly2nb(wheat, queen=FALSE) nbrl <- spdep::nblag(nbr1, 2) #> Warning: lag 2 neighbour object has 2 sub-graphs nbr12 <- spdep::nblag_cumul(nbrl) cms0 <- with(as.data.frame(wheat), tapply(yield, c, median)) cms1 <- c(model.matrix(~ factor(c) -1, data=wheat) %*% cms0) wheat$yield_detrend <- wheat$yield - cms1 isTRUE(all.equal(c(with(as.data.frame(wheat),  tapply(yield_detrend, c, median))), rep(0.0, 25),  check.attributes=FALSE)) #> [1] TRUE spdep::moran.test(wheat$yield_detrend, spdep::nb2listw(nbr12, style=\"W\")) #>  #> \tMoran I test under randomisation #>  #> data:  wheat$yield_detrend   #> weights: spdep::nb2listw(nbr12, style = \"W\")     #>  #> Moran I statistic standard deviate = 10.305, p-value < 2.2e-16 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>      0.1935469610     -0.0020040080      0.0003600869  #>  aple(as.vector(scale(wheat$yield_detrend, scale=FALSE)), spdep::nb2listw(nbr12, style=\"W\")) #> [1] 0.6601805 # \\dontrun{ errorsarlm(yield_detrend ~ 1, wheat, spdep::nb2listw(nbr12, style=\"W\")) #>  #> Call: #> errorsarlm(formula = yield_detrend ~ 1, data = wheat, listw = spdep::nb2listw(nbr12,  #>     style = \"W\")) #> Type: error  #>  #> Coefficients: #>      lambda (Intercept)  #>  0.60189687 -0.00251772  #>  #> Log likelihood: -192.9519  # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate profile-likelihood estimator (APLE) permutation test — aple.mc","title":"Approximate profile-likelihood estimator (APLE) permutation test — aple.mc","text":"permutation bootstrap test approximate profile-likelihood estimator (APLE).","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate profile-likelihood estimator (APLE) permutation test — aple.mc","text":"","code":"aple.mc(x, listw, nsim, override_similarity_check=FALSE, useTrace=TRUE)"},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate profile-likelihood estimator (APLE) permutation test — aple.mc","text":"x zero-mean detrended continuous variable listw listw object example spdep::nb2listw nsim number simulations override_similarity_check default FALSE, TRUE - typically row-standardised weights asymmetric underlying general weights - similarity checked useTrace default TRUE, use trace sparse matrix W %*% W (Li et al. (2010)), FALSE, use crossproduct eigenvalues W Li et al. (2007)","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate profile-likelihood estimator (APLE) permutation test — aple.mc","text":"boot object returned boot function.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.mc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Approximate profile-likelihood estimator (APLE) permutation test — aple.mc","text":"Li, H, Calder, C. . Cressie N. . C. (2007) Beyond Moran's : testing spatial dependence based spatial autoregressive model. Geographical Analysis 39, 357-375; Li, H, Calder, C. . Cressie N. . C. (2012) One-step estimation spatial dependence parameters: Properties extensions APLE statistic, Journal Multivariate Analysis 105, 68-84.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.mc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Approximate profile-likelihood estimator (APLE) permutation test — aple.mc","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate profile-likelihood estimator (APLE) permutation test — aple.mc","text":"","code":"# \\dontrun{ wheat <- st_read(system.file(\"shapes/wheat.gpkg\", package=\"spData\")[1], quiet=TRUE) nbr1 <- spdep::poly2nb(wheat, queen=FALSE) nbrl <- spdep::nblag(nbr1, 2) #> Warning: lag 2 neighbour object has 2 sub-graphs nbr12 <- spdep::nblag_cumul(nbrl) wheat_g <- wheat st_geometry(wheat_g) <- NULL cms0 <- with(wheat_g, tapply(yield, c, median)) cms1 <- c(model.matrix(~ factor(c) -1, data=wheat) %*% cms0) wheat$yield_detrend <- wheat$yield - cms1 oldRNG <- RNGkind() RNGkind(\"L'Ecuyer-CMRG\") set.seed(1L) boot_out_ser <- aple.mc(as.vector(scale(wheat$yield_detrend, scale=FALSE)),  spdep::nb2listw(nbr12, style=\"W\"), nsim=500) plot(boot_out_ser)  boot_out_ser #>  #> DATA PERMUTATION #>  #>  #> Call: #> boot(data = x, statistic = aple.boot, R = nsim, sim = \"permutation\",  #>     pre = pre, parallel = parallel, ncpus = ncpus, cl = cl) #>  #>  #> Bootstrap Statistics : #>      original     bias    std. error #> t1* 0.6601805 -0.6708415   0.1092922 library(parallel) oldCores <- set.coresOption(NULL) nc <- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L # set nc to 1L here if (nc > 1L) nc <- 1L invisible(set.coresOption(nc)) set.seed(1L) if (!get.mcOption()) {   cl <- makeCluster(nc)   set.ClusterOption(cl) } else{   mc.reset.stream() } boot_out_par <- aple.mc(as.vector(scale(wheat$yield_detrend, scale=FALSE)),     spdep::nb2listw(nbr12, style=\"W\"), nsim=500) if (!get.mcOption()) {   set.ClusterOption(NULL)   stopCluster(cl) } boot_out_par #>  #> DATA PERMUTATION #>  #>  #> Call: #> boot(data = x, statistic = aple.boot, R = nsim, sim = \"permutation\",  #>     pre = pre, parallel = parallel, ncpus = ncpus, cl = cl) #>  #>  #> Bootstrap Statistics : #>      original     bias    std. error #> t1* 0.6601805 -0.6708415   0.1092922 invisible(set.coresOption(oldCores)) RNGkind(oldRNG[1], oldRNG[2]) # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate profile-likelihood estimator (APLE) scatterplot — aple.plot","title":"Approximate profile-likelihood estimator (APLE) scatterplot — aple.plot","text":"scatterplot decomposition approximate profile-likelihood estimator, local APLE based list vectors returned scatterplot function.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate profile-likelihood estimator (APLE) scatterplot — aple.plot","text":"","code":"aple.plot(x, listw, override_similarity_check=FALSE, useTrace=TRUE, do.plot=TRUE, ...) localAple(x, listw, override_similarity_check=FALSE, useTrace=TRUE)"},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate profile-likelihood estimator (APLE) scatterplot — aple.plot","text":"x zero-mean detrended continuous variable listw listw object example spdep::nb2listw override_similarity_check default FALSE, TRUE - typically row-standardised weights asymmetric underlying general weights - similarity checked useTrace default TRUE, use trace sparse matrix W %*% W (Li et al. (2010)), FALSE, use crossproduct eigenvalues W Li et al. (2007) .plot default TRUE: scatterplot drawn ... arguments passed plot","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Approximate profile-likelihood estimator (APLE) scatterplot — aple.plot","text":"function solves secondary eigenproblem size n internally, constructing values scatterplot quite compute memory intensive, suitable large n.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate profile-likelihood estimator (APLE) scatterplot — aple.plot","text":"aple.plot returns list components: X vector described Li et al. (2007), p. 366. Y vector described Li et al. (2007), p. 367. localAple returns vector local APLE values.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.plot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Approximate profile-likelihood estimator (APLE) scatterplot — aple.plot","text":"Li, H, Calder, C. . Cressie N. . C. (2007) Beyond Moran's : testing spatial dependence based spatial autoregressive model. Geographical Analysis 39, pp. 357-375; Li, H, Calder, C. . Cressie N. . C. (2012) One-step estimation spatial dependence parameters: Properties extensions APLE statistic, Journal Multivariate Analysis 105, 68-84.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.plot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Approximate profile-likelihood estimator (APLE) scatterplot — aple.plot","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/aple.plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate profile-likelihood estimator (APLE) scatterplot — aple.plot","text":"","code":"# \\dontrun{ wheat <- st_read(system.file(\"shapes/wheat.gpkg\", package=\"spData\")[1], quiet=TRUE) nbr1 <- spdep::poly2nb(wheat, queen=FALSE) nbrl <- spdep::nblag(nbr1, 2) #> Warning: lag 2 neighbour object has 2 sub-graphs nbr12 <- spdep::nblag_cumul(nbrl) cms0 <- with(as.data.frame(wheat), tapply(yield, c, median)) cms1 <- c(model.matrix(~ factor(c) -1, data=wheat) %*% cms0) wheat$yield_detrend <- wheat$yield - cms1 plt_out <- aple.plot(as.vector(scale(wheat$yield_detrend, scale=FALSE)),  spdep::nb2listw(nbr12, style=\"W\"), cex=0.6) lm_obj <- lm(Y ~ X, plt_out) abline(lm_obj) abline(v=0, h=0, lty=2) zz <- summary(influence.measures(lm_obj)) #> Potentially influential observations of #> \t lm(formula = Y ~ X, data = plt_out) : #>  #>     dfb.1_ dfb.X dffit   cov.r   cook.d hat     #> 34  -0.12   0.01 -0.12    0.98_*  0.01   0.00   #> 50   0.10   0.01  0.11    0.98_*  0.01   0.00   #> 60   0.00   0.00  0.00    1.01_*  0.00   0.01   #> 118  0.01   0.01  0.02    1.01_*  0.00   0.01   #> 137 -0.10  -0.01 -0.10    0.98_*  0.01   0.00   #> 143 -0.02  -0.04 -0.05    1.01_*  0.00   0.01   #> 157 -0.10  -0.05 -0.11    0.99_*  0.01   0.00   #> 166  0.00   0.00  0.00    1.02_*  0.00   0.02_* #> 168  0.01   0.02  0.03    1.01_*  0.00   0.01   #> 176 -0.10   0.17 -0.20_*  0.99    0.02   0.01   #> 177  0.03  -0.07  0.08    1.01_*  0.00   0.01   #> 191  0.01   0.04  0.04    1.02_*  0.00   0.02_* #> 192  0.10   0.18  0.20_*  0.99    0.02   0.01   #> 201 -0.10   0.07 -0.12    0.99_*  0.01   0.00   #> 216  0.02   0.05  0.05    1.02_*  0.00   0.01_* #> 217  0.03   0.08  0.09    1.02_*  0.00   0.01_* #> 225 -0.11  -0.07 -0.13    0.98_*  0.01   0.00   #> 237 -0.10   0.02 -0.10    0.99_*  0.01   0.00   #> 242 -0.02  -0.04 -0.04    1.01_*  0.00   0.01   #> 287  0.14  -0.23  0.27_*  0.97_*  0.04   0.01   #> 290 -0.18  -0.35 -0.40_*  0.95_*  0.08   0.01   #> 295 -0.01  -0.01 -0.01    1.01_*  0.00   0.01   #> 322  0.00   0.00  0.00    1.01_*  0.00   0.01   #> 325 -0.10  -0.07 -0.12    0.99_*  0.01   0.00   #> 351  0.19  -0.04  0.20_*  0.94_*  0.02   0.00   #> 369  0.01  -0.03  0.03    1.01_*  0.00   0.01   #> 376 -0.05  -0.13 -0.14    1.02_*  0.01   0.02_* #> 392 -0.04   0.08 -0.09    1.01_*  0.00   0.01   #> 393 -0.03   0.06 -0.07    1.01_*  0.00   0.01   #> 394 -0.01   0.03 -0.03    1.01_*  0.00   0.01   #> 402  0.10   0.02  0.10    0.99_*  0.01   0.00   #> 429  0.13  -0.10  0.16    0.98_*  0.01   0.00   #> 430 -0.11  -0.23 -0.25_*  0.99    0.03   0.01   #> 438  0.00  -0.01 -0.01    1.01_*  0.00   0.01   #> 442 -0.01   0.04 -0.04    1.02_*  0.00   0.02_* #> 443 -0.01   0.02 -0.02    1.02_*  0.00   0.01_* #> 461  0.02   0.04  0.04    1.01_*  0.00   0.01   #> 462  0.01   0.03  0.03    1.03_*  0.00   0.02_* #> 466  0.01  -0.02  0.02    1.02_*  0.00   0.01_* #> 467 -0.03   0.08 -0.08    1.02_*  0.00   0.01_* #> 468  0.02  -0.04  0.04    1.01_*  0.00   0.01   #> 480  0.13   0.05  0.14    0.97_*  0.01   0.00   #> 488  0.16   0.09  0.18    0.96_*  0.02   0.00   #> 492 -0.13   0.12 -0.17    0.98_*  0.01   0.00   infl <- as.integer(rownames(zz)) points(plt_out$X[infl], plt_out$Y[infl], pch=3, cex=0.6, col=\"red\")  crossprod(plt_out$Y, plt_out$X)/crossprod(plt_out$X) #>           [,1] #> [1,] 0.6601805 wheat$localAple <- localAple(as.vector(scale(wheat$yield_detrend, scale=FALSE)),  spdep::nb2listw(nbr12, style=\"W\")) mean(wheat$localAple) #> [1] 0.6601805 hist(wheat$localAple)  opar <- par(no.readonly=TRUE) plot(wheat[,\"localAple\"], reset=FALSE) text(st_coordinates(st_centroid(st_geometry(wheat)))[infl,], labels=rep(\"*\", length(infl)))  par(opar) # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/do_ldet.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial regression model Jacobian computations — do_ldet","title":"Spatial regression model Jacobian computations — do_ldet","text":"functions made available package namespace developers, intended users. provide shared infrastructure setting data Jacobian computation, caclulating Jacobian, either exactly approximately, maximum likelihood fitting spatial regression models. techniques used exact eigenvalue, Cholesky decompositions (Matrix, spam), LU ones, Chebyshev Monte Carlo approximations; moments use methods due Martin Smirnov/Anselin.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/do_ldet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial regression model Jacobian computations — do_ldet","text":"","code":"do_ldet(coef, env, which=1) jacobianSetup(method, env, con, pre_eig=NULL, trs=NULL, interval=NULL, which=1) cheb_setup(env, q=5, which=1) mcdet_setup(env, p=16, m=30, which=1) eigen_setup(env, which=1) eigen_pre_setup(env, pre_eig, which=1) spam_setup(env, pivot=\"MMD\", which=1) spam_update_setup(env, in_coef=0.1, pivot=\"MMD\", which=1) Matrix_setup(env, Imult, super=as.logical(NA), which=1) Matrix_J_setup(env, super=FALSE, which=1) LU_setup(env, which=1) LU_prepermutate_setup(env, coef=0.1, order=FALSE, which=1) moments_setup(env, trs=NULL, m, p, type=\"MC\", correct=TRUE, trunc=TRUE, eq7=TRUE, which=1) SE_classic_setup(env, SE_method=\"LU\", p=16, m=30, nrho=200, interpn=2000,  interval=c(-1,0.999), SElndet=NULL, which=1) SE_whichMin_setup(env, SE_method=\"LU\", p=16, m=30, nrho=200, interpn=2000,  interval=c(-1,0.999), SElndet=NULL, which=1) SE_interp_setup(env, SE_method=\"LU\", p=16, m=30, nrho=200,  interval=c(-1,0.999), which=1) can.be.simmed(listw)"},{"path":"https://r-spatial.github.io/spatialreg/reference/do_ldet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial regression model Jacobian computations — do_ldet","text":"coef spatial coefficient value env environment containing pre-computed objects, fixed assignment setup functions default 1; 2, use second listw object method string value, used jacobianSetup choose method con control list passed model fitting function parsed jacobianSetup set environment variables method-specific setup pre_eig pre-computed eigenvalues length n q Chebyshev approximation order; default calling spdep functions 5, missing default p Monte Carlo approximation number random normal variables; default calling spdep functions 16, missing default m Monte Carlo approximation number series terms; default calling spdep functions 30, missing default; m serves purpose moments method pivot default “MMD”, may also “RCM” Cholesky decompisition using spam in_coef fill-initiation coefficient value, default 0.1 Imult see Cholesky; numeric scalar defaults zero. matrix decomposed +m*m value Imult identity matrix order ncol(). Default calling spdep functions 2, missing default, rescaled binary weights matrices proportion maximim row sum calling functions super see Cholesky; logical scalar indicating supernodal decomposition created.  alternative simplicial decomposition. Default calling spdep functions FALSE “Matrix_J” .logical(NA) “Matrix”.  Setting NA leaves choice CHOLMOD-internal heuristic order default FALSE; used LU_prepermutate, note warnings given lu method trs numeric vector m traces, trW type moments trace type, see trW correct default TRUE: use Smirnov correction term, see trW trunc default TRUE: truncate Smirnov correction term, see trW eq7 default TRUE; use equation 7 Smirnov Anselin (2009), FALSE unit root correction SE_method default “LU”, alternatively “MC”; underlying lndet method use generating SE toolbox emulation grid nrho default 200, number lndet values first stage SE toolbox emulation grid interval default c(-1,0.999) interval argument NULL, bounds SE toolbox emulation grid interpn default 2000, number lndet values interpolate second stage SE toolbox emulation grid SElndet default NULL, used pass pre-computed two-column matrix coefficient values corresponding interpolated lndet values listw spatial weights object","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/do_ldet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial regression model Jacobian computations — do_ldet","text":"Since environments containers R workspace passed reference rather value, useful passing objects functions called numerical optimisation, maximum likelihood estimation spatial regression models. technique can save little time function call, balanced need access objects environment inside function. environment contain family string object either “SAR”, “CAR” “SMA” (used do_ldet choose spatial moving average spautolm, specific objects calling set-functions: eigen Classical Ord eigenvalue computations - either: listw listw spatial weights object can.sim logical scalar: can spatial weights made symmetric similarity verbose logical scalar: legacy report print control, historical reasons : pre_eig pre-computed eigenvalues assigns environment: eig vector eigenvalues eig.range search interval spatial coefficient method string: “eigen” Matrix Sparse matrix pre-computed Cholesky decomposition fast updating: listw listw spatial weights object can.sim logical scalar: can spatial weights made symmetric similarity assigns environment: csrw sparse spatial weights matrix nW negative sparse spatial weights matrix pChol “CHMfactor” factorising csrw Cholesky nChol “CHMfactor” factorising nW Cholesky method string: “Matrix” Matrix_J Standard Cholesky decomposition without updating: listw listw spatial weights object can.sim logical scalar: can spatial weights made symmetric similarity n number spatial objects assigns environment: csrw sparse spatial weights matrix sparse identity matrix super value super argument method string: “Matrix_J” spam Standard Cholesky decomposition without updating: listw listw spatial weights object can.sim logical scalar: can spatial weights made symmetric similarity n number spatial objects assigns environment: csrw sparse spatial weights matrix sparse identity matrix pivot string — pivot method method string: “spam” spam_update Pre-computed Cholesky decomposition updating: listw listw spatial weights object can.sim logical scalar: can spatial weights made symmetric similarity n number spatial objects assigns environment: csrw sparse spatial weights matrix sparse identity matrix csrwchol Cholesky decomposition updating method string: “spam” LU Standard LU decomposition without updating: listw listw spatial weights object n number spatial objects assigns environment: W sparse spatial weights matrix sparse identity matrix method string: “LU” LU_prepermutate Standard LU decomposition updating (pre-computed fill-reducing permutation): listw listw spatial weights object n number spatial objects assigns environment: W sparse spatial weights matrix lu_order order argument lu pq 2-column matrix row column permutation fill-reduction sparse identity matrix method string: “LU” MC Monte Carlo approximation: listw listw spatial weights object assigns environment: clx list Monte Carlo approximation terms  (first two simulated traces replaced analytical equivalents) W sparse spatial weights matrix method string: “MC” cheb Chebyshev approximation: listw listw spatial weights object assigns environment: trT vector Chebyshev approximation terms W sparse spatial weights matrix method string: “Chebyshev” moments moments approximation: listw listw spatial weights object can.sim logical scalar: can spatial weights made symmetric similarity assigns environment: trs vector traces, possibly approximated q12 integer vector length 2, unit roots terms, ignored 0.5-52 eq7 logical scalar: use equation 7 correct logical scalar: use Smirnov correction term trunc logical scalar: truncate Smirnov correction term method string: “moments” SE_classic : listw listw spatial weights object n number spatial objects assigns environment: detval two column matrix lndet grid values method string: “SE_classic” SE_method string: “LU” “MC” SE_whichMin : listw listw spatial weights object n number spatial objects assigns environment: detval two column matrix lndet grid values method string: “SE_whichMin” SE_method string: “LU” “MC” SE_interp : listw listw spatial weights object n number spatial objects assigns environment: fit fitted spline object predict lndet values method string: “SE_interp” SE_method string: “LU” “MC” set-functions may also assign similar environment weights made symmetric similarity. Three set-functions emulate behaviour Spatial Econometrics toolbox (March 2010) maximum likelihood lndet grid performance. toolbox lndet functions compute smaller number lndet values grid coefficient values (spacing 0.01), interpolate finer grid values (spacing 0.001). “SE_classic”, implementation SE toolbox code, example f_sar.m, appears selected row grid matrix one correct row candidate coefficient value 0.005 0.01-fuzz, always rounding row index . possible alternative choose index closest candidate coefficient value (“SE_whichMin”). Another alternative fit spline model first stage coarser grid, pass fitted model log likelihood function make point prediction using candidate coefficient value, rather finding grid index (“SE_interp”).","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/do_ldet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial regression model Jacobian computations — do_ldet","text":"do_ldet returns value Jacobian calculation method recorded environment argument, Monte Carlo approximation, returns measure spread approximation “sd” attribute; remaining functions modify environment place side effect return nothing.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/do_ldet.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial regression model Jacobian computations — do_ldet","text":"LeSage J RK Pace (2009) Introduction Spatial Econometrics. CRC Press, Boca Raton, pp. 77–110. Bivand, R. S., Hauke, J., Kossowski, T. (2013). Computing Jacobian Gaussian spatial autoregressive models: illustrated comparison available methods. Geographical Analysis, 45(2), 150-179.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/do_ldet.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial regression model Jacobian computations — do_ldet","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/do_ldet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial regression model Jacobian computations — do_ldet","text":"","code":"data(boston, package=\"spData\") #require(\"spdep\", quietly=TRUE) lw <- spdep::nb2listw(boston.soi) can.sim <- can.be.simmed(lw) env <- new.env(parent=globalenv()) assign(\"listw\", lw, envir=env) assign(\"can.sim\", can.sim, envir=env) assign(\"similar\", FALSE, envir=env) assign(\"verbose\", FALSE, envir=env) assign(\"family\", \"SAR\", envir=env) eigen_setup(env) get(\"similar\", envir=env) #> [1] TRUE do_ldet(0.5, env) #> [1] -18.26702 rm(env) env <- new.env(parent=globalenv()) assign(\"listw\", lw, envir=env) assign(\"can.sim\", can.sim, envir=env) assign(\"similar\", FALSE, envir=env) assign(\"verbose\", FALSE, envir=env) assign(\"family\", \"SAR\", envir=env) assign(\"n\", length(boston.soi), envir=env) eigen_pre_setup(env, pre_eig=eigenw(similar.listw(lw))) do_ldet(0.5, env) #> [1] -18.26702 rm(env) env <- new.env(parent=globalenv()) assign(\"listw\", lw, envir=env) assign(\"can.sim\", can.sim, envir=env) assign(\"similar\", FALSE, envir=env) assign(\"family\", \"SAR\", envir=env) assign(\"n\", length(boston.soi), envir=env) Matrix_setup(env, Imult=2, super=FALSE) get(\"similar\", envir=env) #> [1] TRUE do_ldet(0.5, env) #> [1] -18.26702 rm(env) env <- new.env(parent=globalenv()) assign(\"listw\", lw, envir=env) assign(\"n\", length(boston.soi), envir=env) assign(\"can.sim\", can.sim, envir=env) assign(\"similar\", FALSE, envir=env) assign(\"family\", \"SAR\", envir=env) spam_setup(env) get(\"similar\", envir=env) #> [1] TRUE do_ldet(0.5, env) #> [1] -18.26702 #> attr(,\"logarithm\") #> [1] TRUE rm(env) env <- new.env(parent=globalenv()) assign(\"listw\", lw, envir=env) assign(\"n\", length(boston.soi), envir=env) assign(\"similar\", FALSE, envir=env) assign(\"family\", \"SAR\", envir=env) LU_setup(env) get(\"similar\", envir=env) #> [1] FALSE do_ldet(0.5, env) #> [1] -18.26702 rm(env) env <- new.env(parent=globalenv()) assign(\"listw\", lw, envir=env) assign(\"n\", length(boston.soi), envir=env) assign(\"similar\", FALSE, envir=env) assign(\"family\", \"SAR\", envir=env) LU_prepermutate_setup(env) get(\"similar\", envir=env) #> [1] FALSE do_ldet(0.5, env) #> [1] -18.26702 rm(env) env <- new.env(parent=globalenv()) assign(\"listw\", lw, envir=env) assign(\"similar\", FALSE, envir=env) assign(\"family\", \"SAR\", envir=env) cheb_setup(env, q=5) get(\"similar\", envir=env) #> [1] FALSE do_ldet(0.5, env) #> [1] -18.26176 rm(env) env <- new.env(parent=globalenv()) assign(\"listw\", lw, envir=env) assign(\"n\", length(boston.soi), envir=env) assign(\"similar\", FALSE, envir=env) assign(\"family\", \"SAR\", envir=env) set.seed(12345) mcdet_setup(env, p=16, m=30) get(\"similar\", envir=env) #> [1] FALSE do_ldet(0.5, env) #> [1] -18.38606 #> attr(,\"sd\") #> [1] 0.2045107 rm(env)"},{"path":"https://r-spatial.github.io/spatialreg/reference/eigenw.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial weights matrix eigenvalues — griffith_sone","title":"Spatial weights matrix eigenvalues — griffith_sone","text":"eigenw function returns numeric vector eigenvalues weights matrix generated spatial weights object listw. eigenvalues used speed computation Jacobian spatial model estimation: $$\\log(\\det[- \\rho W]) = \\sum_{=1}^{n}\\log(1 - \\rho \\lambda_i)$$ \\(W\\) n n spatial weights matrix, \\(\\lambda_i\\) eigenvalues \\(W\\).","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/eigenw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial weights matrix eigenvalues — griffith_sone","text":"","code":"eigenw(listw, quiet=NULL) griffith_sone(P, Q, type=\"rook\") subgraph_eigenw(nb, glist=NULL, style=\"W\", zero.policy=NULL, quiet=NULL)"},{"path":"https://r-spatial.github.io/spatialreg/reference/eigenw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial weights matrix eigenvalues — griffith_sone","text":"listw listw object created example nb2listw quiet default NULL, use global !verbose option value; set FALSE short summary P number columns grid (number units horizontal axis direction) Q number rows grid (number units vertical axis direction.) type “rook” “queen” nb object class nb glist list general weights corresponding neighbours style style can take values “W”, “B”, “C”, “U”, “minmax” “S” zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/eigenw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial weights matrix eigenvalues — griffith_sone","text":"griffith_sone function function may used, following Ord Gasim (references see Griffith Sone (1995)), calculate analytical eigenvalues binary rook queen contiguous neighbours data arranged regular P times Q grid. subgraph_eigenw function may used multiple graph components, largest may handled dense matrix. eigenvalues computed subgraph turn, catenated reconstruct complete set. functions may used provide pre-computed eigenvalues spatial regression functions.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/eigenw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial weights matrix eigenvalues — griffith_sone","text":"numeric complex vector eigenvalues weights matrix generated spatial weights object.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/eigenw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial weights matrix eigenvalues — griffith_sone","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 155; Ord, J. K. 1975 Estimation methods models spatial interaction, Journal American Statistical Association, 70, 120-126.; Griffith, D. . Sone, . (1995). Trade-offs associated normalizing constant computational simplifications estimating spatial statistical models. Journal Statistical Computation Simulation, 51, 165-183.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/eigenw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial weights matrix eigenvalues — griffith_sone","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/eigenw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial weights matrix eigenvalues — griffith_sone","text":"","code":"#require(spdep) data(oldcol, package=\"spdep\") W.eig <- eigenw(spdep::nb2listw(COL.nb, style=\"W\")) 1/range(W.eig) #> [1] -1.536177  1.000000 S.eig <- eigenw(spdep::nb2listw(COL.nb, style=\"S\")) 1/range(S.eig) #> [1] -1.7364189  0.8918997 B.eig <- eigenw(spdep::nb2listw(COL.nb, style=\"B\")) 1/range(B.eig) #> [1] -0.3229290  0.1692726 # cases for intrinsically asymmetric weights crds <- cbind(COL.OLD$X, COL.OLD$Y) k3 <- spdep::knn2nb(spdep::knearneigh(crds, k=3)) #> Warning: neighbour object has 2 sub-graphs spdep::is.symmetric.nb(k3) #> [1] FALSE k3eig <- eigenw(spdep::nb2listw(k3, style=\"W\")) is.complex(k3eig) #> [1] TRUE rho <- 0.5 Jc <- sum(log(1 - rho * k3eig)) # complex eigenvalue Jacobian Jc #> [1] -1.749705+0i # subgraphs nc <- attr(k3, \"ncomp\") if (is.null(nc)) nc <- spdep::n.comp.nb(k3) nc$nc #> [1] 2 table(nc$comp.id) #>  #>  1  2  #> 43  6  k3eigSG <- subgraph_eigenw(k3, style=\"W\") all.equal(sort(k3eig), k3eigSG) #> [1] TRUE W <- as(spdep::nb2listw(k3, style=\"W\"), \"CsparseMatrix\") I <- diag(length(k3)) Jl <- sum(log(abs(diag(slot(lu(I - rho * W), \"U\"))))) # LU Jacobian equals complex eigenvalue Jacobian Jl #> [1] -1.749705 all.equal(Re(Jc), Jl) #> [1] TRUE # wrong value if only real part used Jr <- sum(log(1 - rho * Re(k3eig))) Jr #> [1] -1.762734 all.equal(Jr, Jl) #> [1] \"Mean relative difference: 0.007391147\" # construction of Jacobian from complex conjugate pairs (Jan Hauke) Rev <- Re(k3eig)[which(Im(k3eig) == 0)] # real eigenvalues Cev <- k3eig[which(Im(k3eig) != 0)] pCev <- Cev[Im(Cev) > 0] # separate complex conjugate pairs RpCev <- Re(pCev) IpCev <- Im(pCev) # reassemble Jacobian Jc1 <- sum(log(1 - rho*Rev)) + sum(log((1 - rho * RpCev)^2 + (rho^2)*(IpCev^2))) all.equal(Re(Jc), Jc1) #> [1] TRUE # impact of omitted complex part term in real part only Jacobian Jc2 <- sum(log(1 - rho*Rev)) + sum(log((1 - rho * RpCev)^2)) all.equal(Jr, Jc2) #> [1] TRUE # trace of asymmetric (WW) and crossprod of complex eigenvalues for APLE sum(diag(W %*% W)) #> [1] 11.55556 crossprod(k3eig) #>             [,1] #> [1,] 11.55556+0i # analytical regular grid eigenvalues rg <- spdep::cell2nb(ncol=7, nrow=7, type=\"rook\") rg_eig <- eigenw(spdep::nb2listw(rg, style=\"B\")) rg_GS <- griffith_sone(P=7, Q=7, type=\"rook\") all.equal(rg_eig, rg_GS) #> [1] TRUE # \\dontrun{ run <- FALSE if (require(\"RSpectra\", quietly=TRUE)) run <- TRUE if (run) { B <- as(spdep::nb2listw(rg, style=\"B\"), \"CsparseMatrix\") res1 <- eigs(B, k=1, which=\"LR\")$values resn <- eigs(B, k=1, which=\"SR\")$values print(Re(c(resn, res1))) } #> [1] -3.695518  3.695518 if (run) { print(all.equal(range(Re(rg_eig)), c(resn, res1)))  } #> [1] TRUE if (run) { lw <- spdep::nb2listw(rg, style=\"W\") rg_eig <- eigenw(similar.listw(lw)) print(range(Re(rg_eig))) } #> [1] -1  1 if (run) { W  <- as(lw, \"CsparseMatrix\") print(Re(c(eigs(W, k=1, which=\"SR\")$values, eigs(W, k=1, which=\"LR\")$values))) }# } #> [1] -1  1"},{"path":"https://r-spatial.github.io/spatialreg/reference/gstsls.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial simultaneous autoregressive SAC model estimation by GMM — gstsls","title":"Spatial simultaneous autoregressive SAC model estimation by GMM — gstsls","text":"implementation Kelejian Prucha's generalised moments estimator autoregressive parameter spatial model   spatially lagged dependent variable.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/gstsls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial simultaneous autoregressive SAC model estimation by GMM — gstsls","text":"","code":"gstsls(formula, data = list(), listw, listw2 = NULL, na.action = na.fail,      zero.policy = attr(listw, \"zero.policy\"), pars=NULL, scaleU=FALSE, control = list(),      verbose=NULL, method=\"nlminb\", robust=FALSE, legacy=FALSE, W2X=TRUE, sig2n_k=FALSE)  # S3 method for class 'Gmsar' impacts(obj, ..., n = NULL, tr = NULL, R = NULL,  listw = NULL, evalues=NULL, tol = 1e-06, empirical = FALSE, Q=NULL)"},{"path":"https://r-spatial.github.io/spatialreg/reference/gstsls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial simultaneous autoregressive SAC model estimation by GMM — gstsls","text":"formula symbolic description model fit. details model specification given lm() data optional data frame containing variables model. default variables taken environment function called. listw listw object created example nb2listw listw2 listw object created example nb2listw, given, set spatial weights listw argument na.action function (default na.fail), can also na.omit na.exclude consequences residuals fitted values - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE (default) assign NA - causing GMerrorsar() terminate error pars starting values \\(\\lambda\\) \\(\\sigma^2\\) GMM optimisation,   missing (default), approximated initial 2sls model autocorrelation coefficient corrected weights style   model sigma squared scaleU Default FALSE: scale OLS residuals computing moment matrices; used pars argument missing control list control parameters. See details optim nlminb verbose default NULL, use global option value; TRUE, reports function values optimization. method default nlminb, optionally method passed optim use alternative optimizer robust see stsls legacy see stsls W2X see stsls sig2n_k see stsls obj spatial regression object created lagsarlm, lagmess lmSLX; HPDinterval.LagImpact, LagImpact object ... Arguments passed methods coda package tr vector traces powers spatial weights matrix created using trW, approximate impact measures; given, listw must given exact measures (small moderate spatial weights matrices); traces must spatial weights used fitting spatial regression, must row-standardised evalues vector eigenvalues spatial weights matrix impacts calculations R given, simulations used compute distributions impact measures, returned mcmc objects; objects used convenience output MCMC process tol Argument passed mvrnorm: tolerance (relative largest variance) numerical lack positive-definiteness coefficient covariance matrix empirical Argument passed mvrnorm (default FALSE): true, coefficients covariance matrix specify empirical population mean covariance matrix Q default NULL, else integer number cumulative power series impacts calculate tr given n defaults length(obj$residuals); method Gmsar objects may used panel settings compute impacts cross-sectional weights , suggested Angela Parenti","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/gstsls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial simultaneous autoregressive SAC model estimation by GMM — gstsls","text":"control list set care, function converge values close ML estimator   without requiring computation Jacobian, resource-intensive part ML estimation.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/gstsls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial simultaneous autoregressive SAC model estimation by GMM — gstsls","text":"list object class Gmsar lambda simultaneous autoregressive error coefficient coefficients GMM coefficient estimates (including spatial autocorrelation coefficient) rest.se GMM coefficient standard errors s2 GMM residual variance SSE sum squared GMM errors parameters number parameters estimated lm.model NULL call call used create object residuals GMM residuals lm.target NULL fitted.values Difference residuals response variable formula model formula aliased NULL zero.policy zero.policy model LL NULL vv list internal bigG litg components testing optimisation surface optres object returned optimizer pars start parameter values optimisation Hcov NULL na.action (possibly) named vector excluded omitted observations non-default na.action argument used","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/gstsls.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial simultaneous autoregressive SAC model estimation by GMM — gstsls","text":"Kelejian, H. H., Prucha, . R., 1999. Generalized Moments Estimator Autoregressive Parameter Spatial Model. International Economic Review, 40, pp. 509–533; Cressie, N. . C. 1993 Statistics spatial data, Wiley, New York. Roger Bivand, Gianfranco Piras (2015). Comparing Implementations Estimation Methods Spatial Econometrics. Journal Statistical Software, 63(18), 1-36. doi:10.18637/jss.v063.i18 .","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/gstsls.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial simultaneous autoregressive SAC model estimation by GMM — gstsls","text":"Gianfranco Piras Roger Bivand","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/gstsls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial simultaneous autoregressive SAC model estimation by GMM — gstsls","text":"","code":"#require(\"spdep\", quietly=TRUE)  data(oldcol, package=\"spdep\") COL.errW.GM <- gstsls(CRIME ~ INC + HOVAL, data=COL.OLD, spdep::nb2listw(COL.nb, style=\"W\")) summary(COL.errW.GM) #>  #> Call: #> gstsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"W\")) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.87710  -5.74981  -0.21447   6.19490  22.85527  #>  #> Type: GM SARAR estimator #> Coefficients: (GM standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> Rho_Wy       0.454171   0.177939  2.5524  0.010699 #> (Intercept) 43.782818  10.467857  4.1826 2.882e-05 #> INC         -0.994831   0.366818 -2.7121  0.006687 #> HOVAL       -0.267076   0.088149 -3.0298  0.002447 #>  #> Lambda: 0.016647 #> Residual variance (sigma squared): 94.921, (sigma: 9.7427) #> GM argmin sigma squared: 93.729 #> Number of observations: 49  #> Number of parameters estimated: 6  #>  aa <- GMargminImage(COL.errW.GM) levs <- quantile(aa$z, seq(0, 1, 1/12)) image(aa, breaks=levs, xlab=\"lambda\", ylab=\"s2\") points(COL.errW.GM$lambda, COL.errW.GM$s2, pch=3, lwd=2) contour(aa, levels=signif(levs, 4), add=TRUE)  COL.errW.GM <- gstsls(CRIME ~ INC + HOVAL, data=COL.OLD,  spdep::nb2listw(COL.nb, style=\"W\"), scaleU=TRUE) summary(COL.errW.GM) #>  #> Call: #> gstsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"W\"), scaleU = TRUE) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.87710  -5.74981  -0.21447   6.19490  22.85527  #>  #> Type: GM SARAR estimator #> Coefficients: (GM standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> Rho_Wy       0.454171   0.177939  2.5524  0.010699 #> (Intercept) 43.782818  10.467857  4.1826 2.882e-05 #> INC         -0.994831   0.366818 -2.7121  0.006687 #> HOVAL       -0.267076   0.088149 -3.0298  0.002447 #>  #> Lambda: 0.016647 #> Residual variance (sigma squared): 94.921, (sigma: 9.7427) #> (scaled) GM argmin sigma squared: 0.96653 #> Number of observations: 49  #> Number of parameters estimated: 6  #>  listw <- spdep::nb2listw(COL.nb) W <- as(listw, \"CsparseMatrix\") trMat <- trW(W, type=\"mult\") impacts(COL.errW.GM, tr=trMat) #> Impact measures (lag, trace): #>           Direct   Indirect      Total #> INC   -1.0543769 -0.7682309 -1.8226078 #> HOVAL -0.2830618 -0.2062420 -0.4893038"},{"path":"https://r-spatial.github.io/spatialreg/reference/impacts.html","id":null,"dir":"Reference","previous_headings":"","what":"Impacts in spatial lag models — impacts","title":"Impacts in spatial lag models — impacts","text":"calculation impacts spatial lag spatial Durbin models needed order interpret regression coefficients correctly, spillovers terms data generation processes (unlike spatial error model). Methods “SLX” Bayesian fitted models also provided, former need MC simulations, latter pass MCMC draws.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/impacts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impacts in spatial lag models — impacts","text":"","code":"#\\method{impacts}{sarlm}(obj, \\dots, tr, R = NULL, listw = NULL, evalues=NULL, # useHESS = NULL, tol = 1e-06, empirical = FALSE, Q=NULL) #\\method{impacts}{lagmess}(obj, ..., R=NULL, listw=NULL, tol=1e-6, # empirical=FALSE) #\\method{impacts}{SLX}(obj, ...) #\\method{impacts}{MCMC_sar_g}(obj, ..., tr=NULL, listw=NULL, evalues=NULL, Q=NULL) #\\method{impacts}{MCMC_sem_g}(obj, ..., tr=NULL, listw=NULL, evalues=NULL, Q=NULL) #\\method{impacts}{MCMC_sac_g}(obj, ..., tr=NULL, listw=NULL, evalues=NULL, Q=NULL) # S3 method for class 'LagImpact' plot(x, ..., choice=\"direct\", trace=FALSE, density=TRUE) # S3 method for class 'LagImpact' print(x, ..., reportQ=NULL) # S3 method for class 'LagImpact' summary(object, ..., zstats=FALSE, short=FALSE, reportQ=NULL) #\\method{print}{WXImpact}(x, ...) #\\method{summary}{WXImpact}(object, ..., adjust_k=(attr(object, \"type\") == \"SDEM\")) # S3 method for class 'LagImpact' HPDinterval(obj, prob = 0.95, ..., choice=\"direct\") intImpacts(rho, beta, P, n, mu, Sigma, irho, drop2beta, bnames, interval,  type, tr, R, listw, evalues, tol, empirical, Q, icept, iicept, p, mess=FALSE,  samples=NULL, zero_fill = NULL, dvars = NULL)"},{"path":"https://r-spatial.github.io/spatialreg/reference/impacts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impacts in spatial lag models — impacts","text":"obj spatial regression object created lagsarlm lmSLX; HPDinterval.LagImpact, LagImpact object ... Arguments passed methods coda package tr vector traces powers spatial weights matrix created using trW, approximate impact measures; given, listw must given exact measures (small moderate spatial weights matrices); traces must spatial weights used fitting spatial regression, must row-standardised listw tr given, spatial weights object created nb2listw; must spatial weights used fitting spatial regression, row-standardised evalues vector eigenvalues spatial weights matrix impacts calculations n defaults length(obj$residuals); method gmsar objects may used panel settings compute impacts cross-sectional weights , suggested Angela Parenti R given, simulations used compute distributions impact measures, returned mcmc objects; objects used convenience output MCMC process useHESS Use Hessian approximation (available) even asymptotic coefficient covariance matrix available; used comparing methods tol Argument passed mvrnorm: tolerance (relative largest variance) numerical lack positive-definiteness coefficient covariance matrix empirical Argument passed mvrnorm (default FALSE): true, coefficients covariance matrix specify empirical population mean covariance matrix Q default NULL, else integer number cumulative power series impacts calculate tr given reportQ default NULL; TRUE Q given argument impacts, report impact components x, object LagImpact objects created impacts methods zstats default FALSE, TRUE, also return z-values p-values impacts based simulations short default FALSE, TRUE passed print summary method omit printing mcmc summaries choice One three impacts: direct, indirect, total trace Argument passed plot.mcmc: plot trace plots density Argument passed plot.mcmc: plot density plots prob Argument passed HPDinterval.mcmc: numeric scalar interval (0,1) giving target probability content intervals adjust_k default TRUE SDEM else FALSE, adjust internal OLS SDEM standard errors dividing n rather (n-k) (default changed bug fixed 0.7-8; standard errors now ML SDEM summary impacts summary identical - SLX use FALSE) rho, beta, P, mu, Sigma, irho, drop2beta, bnames,     interval, type, icept, iicept, p, mess, samples, zero_fill, dvars internal arguments shared inside impacts methods","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/impacts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Impacts in spatial lag models — impacts","text":"called without R set, method returns direct, indirect total impacts variables model, variables tha spatial lag model case, variables spatial lags spatial Durbin (mixed) model case. spatial lag impact measures computed using eq. 2.46 (LeSage Pace, 2009, p. 38), either using exact dense matrix (listw given), traces powers weights matrix (tr given). traces created powering sparse matrices, exact trace methods give similar results, unless number powers used small, spatial coefficient close bounds. R given, simulations used create distributions impact measures, provided fitted model object contains coefficient covariance matrix. simulations made using mvrnorm coefficients covariance matrix fitted model. simulations stored mcmc objects defined coda package; objects used convenience output MCMC process. simulated values coefficients checked see spatial coefficient remains within valid interval — draws outside interval discarded. model fitted “Durbin=” set formula subsetting explanatory variables, impacts object returned reports Durbin impacts variables included formula lag impacts variables. Q tr given, addition impact component results provided step traces powers weights matrix including Q'th power. increases computing time output object substantially increased size proportion size Q. method gmsar objects type SARAR output gstsls, assume spatial error coefficient fixed, thus omitted coefficients covariance matrix used simulation.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/impacts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impacts in spatial lag models — impacts","text":"object class LagImpact. simulation carried , object returned list : direct numeric vector indirect numeric vector total numeric vector matching Qres list attribute Q given. simulation carried , object returned list : res list three components non-simulation case, matching Qres list attribute Q given sres list three mcmc matrices, direct, indirect total impacts matching Qmcmc list attribute Q given","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/impacts.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Impacts in spatial lag models — impacts","text":"LeSage J RK Pace (2009) Introduction Spatial Econometrics. CRC Press, Boca Raton, pp. 33–42, 114–115; LeSage J MM Fischer (2008) Spatial growth regressions: model specification, estimation interpretation. Spatial Economic Analysis 3 (3), pp. 275–304. Roger Bivand, Gianfranco Piras (2015). Comparing Implementations Estimation Methods Spatial Econometrics. Journal Statistical Software, 63(18), 1-36. doi:10.18637/jss.v063.i18 .","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/impacts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Impacts in spatial lag models — impacts","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/impacts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Impacts in spatial lag models — impacts","text":"","code":"require(\"sf\", quietly=TRUE) columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) #require(\"spdep\", quietly=TRUE) col.gal.nb <- spdep::read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) listw <- spdep::nb2listw(col.gal.nb) ev <- eigenw(listw) lobj <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw,  control=list(pre_eig=ev)) summary(lobj) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = columbus, listw = listw,  #>     control = list(pre_eig = ev)) #>  #> Residuals: #>         Min          1Q      Median          3Q         Max  #> -37.4497093  -5.4565567   0.0016387   6.7159553  24.7107978  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 46.851431   7.314754  6.4051 1.503e-10 #> INC         -1.073533   0.310872 -3.4533 0.0005538 #> HOVAL       -0.269997   0.090128 -2.9957 0.0027381 #>  #> Rho: 0.40389, LR test value: 8.4179, p-value: 0.0037154 #> Asymptotic standard error: 0.12071 #>     z-value: 3.3459, p-value: 0.00082027 #> Wald statistic: 11.195, p-value: 0.00082027 #>  #> Log likelihood: -183.1683 for lag model #> ML residual variance (sigma squared): 99.164, (sigma: 9.9581) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 376.34, (AIC for lm: 382.75) #> LM test for residual autocorrelation #> test value: 0.19184, p-value: 0.66139 #>  mobj <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw, Durbin=TRUE,  control=list(pre_eig=ev)) summary(mobj) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = columbus, listw = listw,  #>     Durbin = TRUE, control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.15904  -6.62594  -0.39823   6.57561  23.62757  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.592896  13.128680  3.4728 0.0005151 #> INC         -0.939088   0.338229 -2.7765 0.0054950 #> HOVAL       -0.299605   0.090843 -3.2980 0.0009736 #> lag.INC     -0.618375   0.577052 -1.0716 0.2838954 #> lag.HOVAL    0.266615   0.183971  1.4492 0.1472760 #>  #> Rho: 0.38251, LR test value: 4.1648, p-value: 0.041272 #> Asymptotic standard error: 0.16237 #>     z-value: 2.3557, p-value: 0.018488 #> Wald statistic: 5.5493, p-value: 0.018488 #>  #> Log likelihood: -182.0161 for mixed model #> ML residual variance (sigma squared): 95.051, (sigma: 9.7494) #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 378.03, (AIC for lm: 380.2) #> LM test for residual autocorrelation #> test value: 0.101, p-value: 0.75063 #>  mobj1 <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw, Durbin= ~ INC,  control=list(pre_eig=ev)) summary(mobj1) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = columbus, listw = listw,  #>     Durbin = ~INC, control = list(pre_eig = ev)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.62163  -6.13108   0.11211   6.70682  24.76777  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 51.951213  12.577339  4.1305 3.619e-05 #> INC         -1.038812   0.337656 -3.0765  0.002094 #> HOVAL       -0.269345   0.090406 -2.9793  0.002889 #> lag.INC     -0.254653   0.544298 -0.4679  0.639887 #>  #> Rho: 0.35028, LR test value: 3.4351, p-value: 0.063823 #> Asymptotic standard error: 0.1617 #>     z-value: 2.1662, p-value: 0.030293 #> Wald statistic: 4.6926, p-value: 0.030293 #>  #> Log likelihood: -183.065 for mixed model #> ML residual variance (sigma squared): 99.846, (sigma: 9.9923) #> Number of observations: 49  #> Number of parameters estimated: 6  #> AIC: 378.13, (AIC for lm: 379.57) #> LM test for residual autocorrelation #> test value: 2.5646, p-value: 0.10928 #>  W <- as(listw, \"CsparseMatrix\") trMatc <- trW(W, type=\"mult\") trMC <- trW(W, type=\"MC\") set.seed(1) impacts(lobj, listw=listw) #> Impact measures (lag, exact): #>           Direct   Indirect      Total #> INC   -1.1225156 -0.6783818 -1.8008973 #> HOVAL -0.2823163 -0.1706152 -0.4529315 impacts(lobj, tr=trMatc) #> Impact measures (lag, trace): #>           Direct   Indirect      Total #> INC   -1.1225156 -0.6783818 -1.8008973 #> HOVAL -0.2823163 -0.1706152 -0.4529315 impacts(lobj, tr=trMC) #> Impact measures (lag, trace): #>           Direct   Indirect      Total #> INC   -1.1247738 -0.6761235 -1.8008973 #> HOVAL -0.2828842 -0.1700472 -0.4529315 impacts(lobj, evalues=ev) #> Impact measures (lag, evalues): #>           Direct   Indirect      Total #> INC   -1.1225156 -0.6783818 -1.8008973 #> HOVAL -0.2823163 -0.1706152 -0.4529315 library(coda) lobjIQ5 <- impacts(lobj, tr=trMatc, R=200, Q=5) summary(lobjIQ5, zstats=TRUE, short=TRUE) #> Impact measures (lag, trace): #>           Direct   Indirect      Total #> INC   -1.1225156 -0.6783818 -1.8008973 #> HOVAL -0.2823163 -0.1706152 -0.4529315 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3298544 0.3834114 0.5945946 #> HOVAL 0.1014420 0.1261509 0.2033617 #>  #> Simulated z-values: #>          Direct  Indirect     Total #> INC   -3.417467 -1.886887 -3.112575 #> HOVAL -2.895853 -1.551116 -2.406724 #>  #> Simulated p-values: #>       Direct     Indirect Total     #> INC   0.00063207 0.059176 0.0018546 #> HOVAL 0.00378129 0.120874 0.0160963 summary(lobjIQ5, zstats=TRUE, short=TRUE, reportQ=TRUE) #> Impact measures (lag, trace): #>           Direct   Indirect      Total #> INC   -1.1225156 -0.6783818 -1.8008973 #> HOVAL -0.2823163 -0.1706152 -0.4529315 #> ================================= #> Impact components #> $direct #>             INC         HOVAL #> Q1 -1.073533466 -0.2699971236 #> Q2  0.000000000  0.0000000000 #> Q3 -0.038985415 -0.0098049573 #> Q4 -0.005269654 -0.0013253350 #> Q5 -0.003276079 -0.0008239444 #>  #> $indirect #>            INC        HOVAL #> Q1  0.00000000  0.000000000 #> Q2 -0.43358910 -0.109049054 #> Q3 -0.13613675 -0.034238831 #> Q4 -0.06546038 -0.016463497 #> Q5 -0.02529105 -0.006360781 #>  #> $total #>            INC        HOVAL #> Q1 -1.07353347 -0.269997124 #> Q2 -0.43358910 -0.109049054 #> Q3 -0.17512216 -0.044043788 #> Q4 -0.07073004 -0.017788832 #> Q5 -0.02856713 -0.007184726 #>  #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3298544 0.3834114 0.5945946 #> HOVAL 0.1014420 0.1261509 0.2033617 #>  #> Simulated z-values: #>          Direct  Indirect     Total #> INC   -3.417467 -1.886887 -3.112575 #> HOVAL -2.895853 -1.551116 -2.406724 #>  #> Simulated p-values: #>       Direct     Indirect Total     #> INC   0.00063207 0.059176 0.0018546 #> HOVAL 0.00378129 0.120874 0.0160963 #> ======================================================== #> Simulated impact components z-values: #> $Direct #>           INC      HOVAL #> Q1 -3.3247602 -2.9008692 #> Q2        NaN        NaN #> Q3 -1.7540115 -1.4638039 #> Q4 -1.2444388 -1.0830402 #> Q5 -0.9405222 -0.8474166 #>  #> $Indirect #>           INC      HOVAL #> Q1        NaN        NaN #> Q2 -2.6977076 -2.1475985 #> Q3 -1.7540115 -1.4638039 #> Q4 -1.2444388 -1.0830402 #> Q5 -0.9405222 -0.8474166 #>  #> $Total #>           INC      HOVAL #> Q1 -3.3247602 -2.9008692 #> Q2 -2.6977076 -2.1475985 #> Q3 -1.7540115 -1.4638039 #> Q4 -1.2444388 -1.0830402 #> Q5 -0.9405222 -0.8474166 #>  #>  #> Simulated impact components p-values: #> $Direct #>    INC        HOVAL     #> Q1 0.00088495 0.0037213 #> Q2 NA         NA        #> Q3 0.07942853 0.1432475 #> Q4 0.21333812 0.2787906 #> Q5 0.34694975 0.3967630 #>  #> $Indirect #>    INC       HOVAL    #> Q1 NA        NA       #> Q2 0.0069819 0.031746 #> Q3 0.0794285 0.143248 #> Q4 0.2133381 0.278791 #> Q5 0.3469497 0.396763 #>  #> $Total #>    INC        HOVAL     #> Q1 0.00088495 0.0037213 #> Q2 0.00698187 0.0317457 #> Q3 0.07942853 0.1432475 #> Q4 0.21333812 0.2787906 #> Q5 0.34694975 0.3967630 #>  impacts(mobj, listw=listw) #> Impact measures (mixed, exact): #>           Direct   Indirect       Total #> INC   -1.0418080 -1.4804246 -2.52223255 #> HOVAL -0.2836325  0.2302055 -0.05342697 impacts(mobj, tr=trMatc) #> Impact measures (mixed, trace): #>           Direct   Indirect       Total #> INC   -1.0418080 -1.4804246 -2.52223255 #> HOVAL -0.2836325  0.2302055 -0.05342697 impacts(mobj, tr=trMC) #> Impact measures (mixed, trace): #>           Direct   Indirect       Total #> INC   -1.0462717 -1.4759609 -2.52223255 #> HOVAL -0.2829384  0.2295114 -0.05342697 impacts(mobj1, tr=trMatc) #> Impact measures (mixed, trace): #>           Direct   Indirect      Total #> INC   -1.0968247 -0.8939687 -1.9907934 #> HOVAL -0.2781941 -0.1363596 -0.4145537 impacts(mobj1, listw=listw) #> Impact measures (mixed, exact): #>           Direct   Indirect      Total #> INC   -1.0968247 -0.8939687 -1.9907934 #> HOVAL -0.2781941 -0.1363596 -0.4145537 # \\dontrun{ try(impacts(mobj, evalues=ev), silent=TRUE) #> Impact measures (mixed, evalues): #>           Direct   Indirect       Total #> INC   -1.0418080 -1.4804246 -2.52223255 #> HOVAL -0.2836325  0.2302055 -0.05342697 # } summary(impacts(mobj, tr=trMatc, R=200), short=TRUE, zstats=TRUE) #> Impact measures (mixed, trace): #>           Direct   Indirect       Total #> INC   -1.0418080 -1.4804246 -2.52223255 #> HOVAL -0.2836325  0.2302055 -0.05342697 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3407851 0.8610832 0.9221567 #> HOVAL 0.0980867 0.3285062 0.3625254 #>  #> Simulated z-values: #>          Direct   Indirect      Total #> INC   -3.017200 -1.7533600 -2.7522499 #> HOVAL -2.931757  0.6507956 -0.2035056 #>  #> Simulated p-values: #>       Direct    Indirect Total     #> INC   0.0025512 0.07954  0.0059187 #> HOVAL 0.0033705 0.51518  0.8387399 summary(impacts(mobj1, tr=trMatc, R=200), short=TRUE, zstats=TRUE) #> Impact measures (mixed, trace): #>           Direct   Indirect      Total #> INC   -1.0968247 -0.8939687 -1.9907934 #> HOVAL -0.2781941 -0.1363596 -0.4145537 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3752297 0.6525338 0.7183806 #> HOVAL 0.1078220 0.1277117 0.1990840 #>  #> Simulated z-values: #>          Direct  Indirect     Total #> INC   -2.902700 -1.247249 -2.649084 #> HOVAL -2.637881 -1.168002 -2.177921 #>  #> Simulated p-values: #>       Direct    Indirect Total    #> INC   0.0036996 0.21231  0.008071 #> HOVAL 0.0083426 0.24281  0.029412 xobj <- lmSLX(CRIME ~ INC + HOVAL, columbus, listw) summary(impacts(xobj)) #> Impact measures (SlX, glht, n-k): #>           Direct   Indirect       Total #> INC   -1.1081273 -1.3834468 -2.49157410 #> HOVAL -0.2949095  0.2261538 -0.06875574 #> ======================================================== #> Standard errors: #>          Direct  Indirect     Total #> INC   0.3749956 0.5591789 0.4928197 #> HOVAL 0.1013524 0.2026169 0.2049626 #> ======================================================== #> Z-values: #>          Direct  Indirect      Total #> INC   -2.955041 -2.474068 -5.0557523 #> HOVAL -2.909744  1.116164 -0.3354551 #>  #> p-values: #>       Direct    Indirect Total     #> INC   0.0031263 0.013358 4.287e-07 #> HOVAL 0.0036172 0.264352 0.73728   #>  eobj <- errorsarlm(CRIME ~ INC + HOVAL, columbus, listw, etype=\"emixed\") summary(impacts(eobj), adjust_k=TRUE) #> Impact measures (SDEM, glht, n): #>           Direct   Indirect      Total #> INC   -1.0695301 -1.1967736 -2.2663036 #> HOVAL -0.2803441  0.1467585 -0.1335856 #> ======================================================== #> Standard errors: #>           Direct  Indirect     Total #> INC   0.32471853 0.5689676 0.6209448 #> HOVAL 0.09180929 0.2008722 0.2323518 #> ======================================================== #> Z-values: #>          Direct   Indirect      Total #> INC   -3.293714 -2.1034124 -3.6497665 #> HOVAL -3.053548  0.7306064 -0.5749284 #>  #> p-values: #>       Direct     Indirect Total      #> INC   0.00098873 0.03543  0.00026248 #> HOVAL 0.00226152 0.46502  0.56533971 #>  # \\dontrun{ mobj1 <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw, type=\"mixed\",  method=\"Matrix\", control=list(fdHess=TRUE)) summary(mobj1) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = columbus, listw = listw,  #>     type = \"mixed\", method = \"Matrix\", control = list(fdHess = TRUE)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.15904  -6.62594  -0.39823   6.57561  23.62757  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.592896  14.240041  3.2017 0.0013660 #> INC         -0.939088   0.343069 -2.7373 0.0061942 #> HOVAL       -0.299605   0.090393 -3.3145 0.0009182 #> lag.INC     -0.618375   0.607708 -1.0176 0.3088903 #> lag.HOVAL    0.266615   0.181524  1.4688 0.1418998 #>  #> Rho: 0.38251, LR test value: 4.1648, p-value: 0.041272 #> Asymptotic standard error: 0.17375 #>     z-value: 2.2015, p-value: 0.027702 #> Wald statistic: 4.8465, p-value: 0.027702 #>  #> Log likelihood: -182.0161 for mixed model #> ML residual variance (sigma squared): 95.051, (sigma: 9.7494) #> Number of observations: 49  #> Number of parameters estimated: 7  #> AIC: 378.03, (AIC for lm: 380.2) #> LM test for residual autocorrelation #> test value: 0.101, p-value: 0.75063 #>  set.seed(1) summary(impacts(mobj1, tr=trMatc, R=1000), zstats=TRUE, short=TRUE) #> Impact measures (mixed, trace): #>           Direct   Indirect       Total #> INC   -1.0418080 -1.4804246 -2.52223255 #> HOVAL -0.2836325  0.2302055 -0.05342697 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>           Direct  Indirect     Total #> INC   0.34686331 0.8324743 0.8959688 #> HOVAL 0.09085583 0.3131242 0.3483785 #>  #> Simulated z-values: #>          Direct   Indirect      Total #> INC   -3.023902 -1.8284275 -2.8695190 #> HOVAL -3.120537  0.7910739 -0.1028036 #>  #> Simulated p-values: #>       Direct    Indirect Total    #> INC   0.0024954 0.067485 0.004111 #> HOVAL 0.0018052 0.428901 0.918119 summary(impacts(mobj, tr=trMatc, R=1000), zstats=TRUE, short=TRUE) #> Impact measures (mixed, trace): #>           Direct   Indirect       Total #> INC   -1.0418080 -1.4804246 -2.52223255 #> HOVAL -0.2836325  0.2302055 -0.05342697 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3123750 0.8291512 0.8821167 #> HOVAL 0.0922758 0.2961092 0.3267773 #>  #> Simulated z-values: #>          Direct   Indirect      Total #> INC   -3.330304 -1.8060414 -2.8769263 #> HOVAL -3.099811  0.8140556 -0.1376722 #>  #> Simulated p-values: #>       Direct     Indirect Total     #> INC   0.00086751 0.070912 0.0040157 #> HOVAL 0.00193644 0.415613 0.8904995 mobj2 <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw, type=\"mixed\",  method=\"Matrix\", control=list(fdHess=TRUE, optimHess=TRUE)) summary(impacts(mobj2, tr=trMatc, R=1000), zstats=TRUE, short=TRUE) #> Impact measures (mixed, trace): #>           Direct   Indirect       Total #> INC   -1.0418080 -1.4804246 -2.52223255 #> HOVAL -0.2836325  0.2302055 -0.05342697 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>           Direct  Indirect     Total #> INC   0.32853332 0.8044059 0.8615603 #> HOVAL 0.09291975 0.3169361 0.3571304 #>  #> Simulated z-values: #>          Direct   Indirect      Total #> INC   -3.231204 -1.8690203 -2.9771674 #> HOVAL -3.026494  0.7323897 -0.1374858 #>  #> Simulated p-values: #>       Direct    Indirect Total     #> INC   0.0012327 0.06162  0.0029093 #> HOVAL 0.0024741 0.46393  0.8906468 mobj3 <- lagsarlm(CRIME ~ INC + HOVAL, columbus, listw, type=\"mixed\",  method=\"spam\", control=list(fdHess=TRUE)) summary(impacts(mobj3, tr=trMatc, R=1000), zstats=TRUE, short=TRUE) #> Impact measures (mixed, trace): #>           Direct   Indirect       Total #> INC   -1.0418080 -1.4804246 -2.52223255 #> HOVAL -0.2836325  0.2302055 -0.05342697 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>           Direct  Indirect     Total #> INC   0.32866009 0.8664620 0.9215792 #> HOVAL 0.09837849 0.3110899 0.3492674 #>  #> Simulated z-values: #>          Direct   Indirect     Total #> INC   -3.190433 -1.7325351 -2.766712 #> HOVAL -2.890221  0.7694814 -0.128720 #>  #> Simulated p-values: #>       Direct    Indirect Total     #> INC   0.0014206 0.083178 0.0056625 #> HOVAL 0.0038497 0.441608 0.8975792 # } # \\dontrun{ data(boston, package=\"spData\") Wb <- as(spdep::nb2listw(boston.soi), \"CsparseMatrix\") trMatb <- trW(Wb, type=\"mult\") gp2mMi <- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  I(RM^2) +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),  data=boston.c, spdep::nb2listw(boston.soi), type=\"mixed\", method=\"Matrix\",  control=list(fdHess=TRUE), trs=trMatb) summary(gp2mMi) #>  #> Call:lagsarlm(formula = log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  #>     I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B +  #>     log(LSTAT), data = boston.c, listw = spdep::nb2listw(boston.soi),  #>     type = \"mixed\", method = \"Matrix\", trs = trMatb, control = list(fdHess = TRUE)) #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -0.6316833 -0.0629790 -0.0090776  0.0682421  0.6991072  #>  #> Type: mixed  #> Coefficients: (asymptotic standard errors)  #>                   Estimate  Std. Error  z value  Pr(>|z|) #> (Intercept)     1.89816225  0.24400203   7.7793 7.327e-15 #> CRIM           -0.00571021  0.00093857  -6.0839 1.173e-09 #> ZN              0.00069091  0.00051874   1.3319 0.1828931 #> INDUS          -0.00111343  0.00307380  -0.3622 0.7171778 #> CHAS1          -0.04163225  0.02738839  -1.5201 0.1284937 #> I(NOX^2)       -0.01034950  0.19358633  -0.0535 0.9573639 #> I(RM^2)         0.00794979  0.00102109   7.7856 6.883e-15 #> AGE            -0.00128789  0.00048929  -2.6322 0.0084838 #> log(DIS)       -0.12404108  0.09510145  -1.3043 0.1921304 #> log(RAD)        0.05863502  0.02257529   2.5973 0.0093957 #> TAX            -0.00049084  0.00012146  -4.0412 5.317e-05 #> PTRATIO        -0.01319853  0.00595331  -2.2170 0.0266227 #> B               0.00056383  0.00011084   5.0867 3.643e-07 #> log(LSTAT)     -0.24724454  0.02265149 -10.9152 < 2.2e-16 #> lag.CRIM       -0.00464215  0.00173900  -2.6694 0.0075978 #> lag.ZN         -0.00037937  0.00070703  -0.5366 0.5915659 #> lag.INDUS       0.00025064  0.00385911   0.0649 0.9482165 #> lag.CHAS1       0.12518252  0.04083949   3.0652 0.0021750 #> lag.I(NOX^2)   -0.38640403  0.22253428  -1.7364 0.0824967 #> lag.I(RM^2)    -0.00451252  0.00148919  -3.0302 0.0024440 #> lag.AGE         0.00149678  0.00068470   2.1860 0.0288128 #> lag.log(DIS)   -0.00453785  0.10056961  -0.0451 0.9640104 #> lag.log(RAD)   -0.00940702  0.03127787  -0.3008 0.7636002 #> lag.TAX         0.00041083  0.00017859   2.3004 0.0214237 #> lag.PTRATIO     0.00060355  0.00789994   0.0764 0.9391011 #> lag.B          -0.00050781  0.00014107  -3.5996 0.0003187 #> lag.log(LSTAT)  0.09846781  0.03574183   2.7550 0.0058697 #>  #> Rho: 0.59578, LR test value: 181.68, p-value: < 2.22e-16 #> Asymptotic standard error: 0.037474 #>     z-value: 15.899, p-value: < 2.22e-16 #> Wald statistic: 252.76, p-value: < 2.22e-16 #>  #> Log likelihood: 300.6131 for mixed model #> ML residual variance (sigma squared): 0.016011, (sigma: 0.12654) #> Number of observations: 506  #> Number of parameters estimated: 29  #> AIC: -543.23, (AIC for lm: -363.55) #> LM test for residual autocorrelation #> test value: 29.772, p-value: 4.8604e-08 #>  summary(impacts(gp2mMi, tr=trMatb, R=1000), zstats=TRUE, short=TRUE) #> Impact measures (mixed, trace): #>                   Direct      Indirect         Total #> CRIM       -0.0074555753 -0.0181548470 -0.0256104223 #> ZN          0.0006979073  0.0000727985  0.0007707058 #> INDUS      -0.0012029822 -0.0009314672 -0.0021344494 #> CHAS1      -0.0198526431  0.2265453879  0.2066927447 #> I(NOX^2)   -0.0955268252 -0.8859909283 -0.9815177535 #> I(RM^2)     0.0079983430  0.0005050175  0.0085033605 #> AGE        -0.0011296134  0.0016463650  0.0005167515 #> log(DIS)   -0.1410601685 -0.1770277708 -0.3180879393 #> log(RAD)    0.0641735546  0.0576102594  0.1217838140 #> TAX        -0.0004651543  0.0002672119 -0.0001979424 #> PTRATIO    -0.0147737151 -0.0163846522 -0.0311583673 #> B           0.0005265343 -0.0003879424  0.0001385920 #> log(LSTAT) -0.2578403220 -0.1102143882 -0.3680547101 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>                  Direct     Indirect        Total #> CRIM       0.0010076566 0.0036285971 0.0040401747 #> ZN         0.0004896474 0.0012385892 0.0012617113 #> INDUS      0.0028820705 0.0060789543 0.0057788737 #> CHAS1      0.0271174416 0.0816948950 0.0902306553 #> I(NOX^2)   0.1798525319 0.2954129272 0.2426994629 #> I(RM^2)    0.0010995238 0.0031443424 0.0036252679 #> AGE        0.0004766510 0.0012848631 0.0013546129 #> log(DIS)   0.0884514383 0.1106832550 0.0757291955 #> log(RAD)   0.0197637995 0.0513249209 0.0502885515 #> TAX        0.0001172963 0.0003281755 0.0003385766 #> PTRATIO    0.0054150426 0.0127887825 0.0122251822 #> B          0.0001051363 0.0002388721 0.0002375770 #> log(LSTAT) 0.0224736420 0.0610706224 0.0660453166 #>  #> Simulated z-values: #>                 Direct    Indirect      Total #> CRIM        -7.4242633 -5.04782172 -6.3852730 #> ZN           1.4302178  0.09961643  0.6528326 #> INDUS       -0.4184439 -0.10883366 -0.3231737 #> CHAS1       -0.7260661  2.79074703  2.3085362 #> I(NOX^2)    -0.5230875 -3.05728030 -4.1089450 #> I(RM^2)      7.3426845  0.17905211  2.3822949 #> AGE         -2.4149822  1.25401260  0.3396769 #> log(DIS)    -1.5778895 -1.66514935 -4.2766960 #> log(RAD)     3.2376719  1.17611638  2.4727850 #> TAX         -3.9726814  0.78133925 -0.6189573 #> PTRATIO     -2.7323855 -1.29137856 -2.5612005 #> B            5.0000793 -1.62377140  0.5800914 #> log(LSTAT) -11.4429357 -1.77731839 -5.5372039 #>  #> Simulated p-values: #>            Direct     Indirect   Total      #> CRIM       1.1346e-13 4.4688e-07 1.7109e-10 #> ZN         0.1526545  0.9206489  0.513864   #> INDUS      0.6756226  0.9133344  0.746564   #> CHAS1      0.4677982  0.0052587  0.020969   #> I(NOX^2)   0.6009133  0.0022336  3.9747e-05 #> I(RM^2)    2.0939e-13 0.8578968  0.017205   #> AGE        0.0157360  0.2098374  0.734100   #> log(DIS)   0.1145910  0.0958830  1.8969e-05 #> log(RAD)   0.0012051  0.2395484  0.013406   #> TAX        7.1068e-05 0.4346030  0.535944   #> PTRATIO    0.0062878  0.1965724  0.010431   #> B          5.7307e-07 0.1044246  0.561853   #> log(LSTAT) < 2.22e-16 0.0755159  3.0734e-08 #data(house, package=\"spData\") #lw <- spdep::nb2listw(LO_nb) #form <- formula(log(price) ~ age + I(age^2) + I(age^3) + log(lotsize) + #   rooms + log(TLA) + beds + syear) #lobj <- lagsarlm(form, house, lw, method=\"Matrix\", # control=list(fdHess=TRUE), trs=trMat) #summary(lobj) #loobj <- impacts(lobj, tr=trMat, R=1000) #summary(loobj, zstats=TRUE, short=TRUE) #lobj1 <- stsls(form, house, lw) #loobj1 <- impacts(lobj1, tr=trMat, R=1000) #summary(loobj1, zstats=TRUE, short=TRUE) #mobj <- lagsarlm(form, house, lw, type=\"mixed\", # method=\"Matrix\", control=list(fdHess=TRUE), trs=trMat) #summary(mobj) #moobj <- impacts(mobj, tr=trMat, R=1000) #summary(moobj, zstats=TRUE, short=TRUE) # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/invIrM.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute SAR generating operator — invIrM","title":"Compute SAR generating operator — invIrM","text":"Computes matrix used generating simultaneous autoregressive random variables, given value rho, neighbours list object matrix, chosen coding scheme style, optionally list general weights corresponding neighbours.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/invIrM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute SAR generating operator — invIrM","text":"","code":"invIrM(neighbours, rho, glist=NULL, style=\"W\", method=\"solve\",  feasible=NULL) invIrW(x, rho, method=\"solve\", feasible=NULL)"},{"path":"https://r-spatial.github.io/spatialreg/reference/invIrM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute SAR generating operator — invIrM","text":"neighbours object class nb rho autoregressive parameter glist list general weights corresponding neighbours style style can take values W, B, C, S method default solve, can also take value chol feasible NULL, given value rho checked see lies within feasible range, TRUE, test conducted x either listw object example nb2listw square spatial weights matrix, optionally sparse matrix","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/invIrM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute SAR generating operator — invIrM","text":"invIrW function generates full weights matrix V, checks rho lies feasible range 1/min(eigen(V)) 1/max(eigen(V)), returns nxn inverted matrix $$(- \\rho V)^{-1}$$. method=“chol” (listw object), Cholesky decomposition used, thanks contributed code Markus Reder Werner Mueller. Note , situations simulation, may matter random vector rnorm similar exactly N(0, 1), also contain random amounts spatial autocorrelection , mix spatial autocorrelection injected process operator $$(- \\rho V)^{-1}$$. addition, follow stipulated distribution exactly either, several steps may needed scale random vector, remove artefacts coming deviance distributional parameters, remove random spatial autocorrelation - see examples . Thanks Rune Østergaard Pedersen bring question. powerWeights function uses power series summation cumulate product $$(- \\rho V)^{-1} \\%*\\% X$$ $$(+ \\rho V + (\\rho V)^2 + \\dots) \\%*\\% X$$, can done storing sparse V several matrices dimensions X. makes possible handle larger spatial weights matrices, sensitive power weights order tolerance arguments spatial coefficient close bounds, leading incorrect estimates implied inverse matrix.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/invIrM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute SAR generating operator — invIrM","text":"nxn matrix \"call\" attribute; powerWeights function returns matrix dimensions X multipled power series equivalent dense matrix $$(- \\rho V)^{-1}$$.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/invIrM.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Compute SAR generating operator — invIrM","text":"version 0.6-10, powerWeights worked correctly positive rho, differences true values increasing rho approached -1, exploding -1 true negative bound.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/invIrM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute SAR generating operator — invIrM","text":"Tiefelsdorf, M., Griffith, D. ., Boots, B. 1999 variance-stabilizing coding scheme spatial link matrices, Environment Planning , 31, pp. 165-180; Tiefelsdorf, M. 2000 Modelling spatial processes, Lecture notes earth sciences, Springer, p. 76; Haining, R. 1990 Spatial data analysis social environmental sciences, Cambridge University Press, p. 117; Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 152; Reder, M. Mueller, W. (2007) Improvement invIrM Routine Geostatistical R-package spdep Cholesky Inversion, Statistical Projects, LV : 238.205, SS 2006, Department Applied Statistics, Johannes Kepler University, Linz","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/invIrM.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute SAR generating operator — invIrM","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/invIrM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute SAR generating operator — invIrM","text":"","code":"library(spdep) nb7rt <- cell2nb(7, 7, torus=TRUE) lw <- nb2listw(nb7rt, style=\"W\") set.seed(1) x <- matrix(sample(rnorm(500*length(nb7rt))), nrow=length(nb7rt)) if (requireNamespace(\"spatialreg\", quietly=TRUE)) { # Only needed in some simulation settings where the input and # output distributions must agree in all but autocorrelation if (FALSE) { e <- spatialreg::eigenw(lw) x <- apply(x, 2, scale) st <- apply(x, 2, function(x) shapiro.test(x)$p.value) x <- x[, (st > 0.2 & st < 0.8)] x <- apply(x, 2, function(v) spatialreg::residuals.spautolm(  spatialreg::spautolm(v ~ 1, listw=lw, method=\"eigen\",  control=list(pre_eig=e, fdHess=FALSE)))) x <- apply(x, 2, scale) } res0 <- apply(invIrM(nb7rt, rho=0.0, method=\"chol\",  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x)) res2 <- apply(invIrM(nb7rt, rho=0.2, method=\"chol\",  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x)) res4 <- apply(invIrM(nb7rt, rho=0.4, method=\"chol\",  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x)) res6 <- apply(invIrM(nb7rt, rho=0.6, method=\"chol\",  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x)) res8 <- apply(invIrM(nb7rt, rho=0.8, method=\"chol\",  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x)) res9 <- apply(invIrM(nb7rt, rho=0.9, method=\"chol\",  feasible=TRUE) %*% x, 2, function(x) var(x)/length(x)) plot(density(res9), col=\"red\", xlim=c(-0.01, max(density(res9)$x)),   ylim=range(density(res0)$y),   xlab=\"estimated variance of the mean\",   main=expression(paste(\"Effects of spatial autocorrelation for different \",     rho, \" values\"))) lines(density(res0), col=\"black\") lines(density(res2), col=\"brown\") lines(density(res4), col=\"green\") lines(density(res6), col=\"orange\") lines(density(res8), col=\"pink\") legend(c(-0.02, 0.01), c(7, 25),  legend=c(\"0.0\", \"0.2\", \"0.4\", \"0.6\", \"0.8\", \"0.9\"),  col=c(\"black\", \"brown\", \"green\", \"orange\", \"pink\", \"red\"), lty=1, bty=\"n\") }  # \\dontrun{ x <- matrix(rnorm(length(nb7rt)), ncol=1) system.time(e <- invIrM(nb7rt, rho=0.9, method=\"chol\", feasible=TRUE) %*% x) #>    user  system elapsed  #>   0.003   0.000   0.002  system.time(e <- invIrM(nb7rt, rho=0.9, method=\"chol\", feasible=NULL) %*% x) #>    user  system elapsed  #>   0.002   0.000   0.002  system.time(e <- invIrM(nb7rt, rho=0.9, method=\"solve\", feasible=TRUE) %*% x) #>    user  system elapsed  #>   0.001   0.000   0.001  system.time(e <- invIrM(nb7rt, rho=0.9, method=\"solve\", feasible=NULL) %*% x) #>    user  system elapsed  #>   0.002   0.000   0.002  # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/lagmess.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix exponential spatial lag model — lagmess","title":"Matrix exponential spatial lag model — lagmess","text":"function fits matrix exponential spatial lag model, using optim find value alpha, spatial coefficient.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lagmess.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix exponential spatial lag model — lagmess","text":"","code":"lagmess(formula, data = list(), listw, zero.policy = NULL, na.action = na.fail,  q = 10, start = -2.5, control=list(), method=\"BFGS\", verbose=NULL,  use_expm=FALSE)"},{"path":"https://r-spatial.github.io/spatialreg/reference/lagmess.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix exponential spatial lag model — lagmess","text":"formula symbolic description model fit. details model specification given lm() data optional data frame containing variables model. default variables taken environment function called. listw listw object created example spdep::nb2listw() zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA - causing lagmess() terminate error na.action function (default options(\"na.action\")), can also na.omit na.exclude consequences residuals fitted values - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. q default 10; number powers spatial weights use start starting value numerical optimization, small negative number control control parameters passed optim method default BFGS, method passed optim verbose default NULL, use global option value; TRUE report function values optimization use_expm default FALSE; TRUE use expm::expAtv instead truncated power series W","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lagmess.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matrix exponential spatial lag model — lagmess","text":"underlying spatial lag model: $$y = \\rho W y + X \\beta + \\varepsilon$$ \\(\\rho\\) spatial parameter may fitted maximum likelihood. case, log likelihood function includes logarithm cumbersome Jacobian term \\(|- \\rho W|\\). rewrite model : $$S y = X \\beta + \\varepsilon$$ see ML case \\(S y = (- \\rho W) y\\). W row-stochastic, S may expressed linear combination row-stochastic matrices. pre-computing matrix \\([y, Wy, W^2y, ..., W^{q-1}y]\\), term \\(S y (\\alpha)\\) can readily found numerical optimization using matrix exponential approach. \\(\\alpha\\) \\(\\rho\\) related \\(\\rho = 1 - \\exp{\\alpha}\\), conditional number matrix power terms taken q.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lagmess.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix exponential spatial lag model — lagmess","text":"function returns object class Lagmess components: lmobj lm object returned fitting alpha alpha spatial coefficient alphase standard error spatial coefficient using numerical Hessian rho value rho implied alpha bestmess object returned optim q number powers spatial weights used start starting value numerical optimization used na.action (possibly) named vector excluded omitted observations non-default na.action argument used nullLL log likelihood aspatial model data","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lagmess.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Matrix exponential spatial lag model — lagmess","text":"J. P. LeSage R. K. Pace (2007) matrix exponential specification. Journal Econometrics, 140, 190-214; J. P. LeSage R. K. Pace (2009) Introduction Spatial Econometrics. CRC Press, Chapter 9.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lagmess.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Matrix exponential spatial lag model — lagmess","text":"Roger Bivand Roger.Bivand@nhh.Eric Blankmeyer","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/lagmess.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix exponential spatial lag model — lagmess","text":"","code":"#require(spdep, quietly=TRUE) data(baltimore, package=\"spData\") baltimore$AGE <- ifelse(baltimore$AGE < 1, 1, baltimore$AGE) lw <- spdep::nb2listw(spdep::knn2nb(spdep::knearneigh(cbind(baltimore$X, baltimore$Y), k=7))) obj1 <- lm(log(PRICE) ~ PATIO + log(AGE) + log(SQFT),  data=baltimore) spdep::lm.morantest(obj1, lw) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data = #> baltimore) #> weights: lw #>  #> Moran I statistic standard deviate = 7.4648, p-value = 4.171e-14 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>      0.245149959     -0.007853660      0.001148722  #>  spdep::lm.LMtests(obj1, lw, test=\"all\") #> Please update scripts to use lm.RStests in place of lm.LMtests #>  #> \tRao's score (a.k.a Lagrange multiplier) diagnostics for spatial #> \tdependence #>  #> data:   #> model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data = #> baltimore) #> test weights: listw #>  #> RSerr = 48.648, df = 1, p-value = 3.063e-12 #>  #>  #> \tRao's score (a.k.a Lagrange multiplier) diagnostics for spatial #> \tdependence #>  #> data:   #> model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data = #> baltimore) #> test weights: listw #>  #> RSlag = 83.091, df = 1, p-value < 2.2e-16 #>  #>  #> \tRao's score (a.k.a Lagrange multiplier) diagnostics for spatial #> \tdependence #>  #> data:   #> model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data = #> baltimore) #> test weights: listw #>  #> adjRSerr = 1.2535, df = 1, p-value = 0.2629 #>  #>  #> \tRao's score (a.k.a Lagrange multiplier) diagnostics for spatial #> \tdependence #>  #> data:   #> model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data = #> baltimore) #> test weights: listw #>  #> adjRSlag = 35.696, df = 1, p-value = 2.306e-09 #>  #>  #> \tRao's score (a.k.a Lagrange multiplier) diagnostics for spatial #> \tdependence #>  #> data:   #> model: lm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data = #> baltimore) #> test weights: listw #>  #> SARMA = 84.344, df = 2, p-value < 2.2e-16 #>  system.time(obj2 <- lagmess(log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data=baltimore, listw=lw)) #>    user  system elapsed  #>    0.03    0.00    0.03  (x <- summary(obj2)) #> Matrix exponential spatial lag model: #>  #> Call: #> lagmess(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT),  #>     data = baltimore, listw = lw) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -2.026722 -0.141191  0.050831  0.223830  1.073114  #>  #> Coefficients: #>              Estimate Std. Error t value  Pr(>|t|) #> (Intercept)  1.546376   0.214513  7.2088 1.039e-11 #> PATIO        0.258287   0.086891  2.9726  0.003303 #> log(AGE)    -0.148174   0.035252 -4.2033 3.912e-05 #> log(SQFT)    0.300966   0.071598  4.2036 3.908e-05 #>  #> Residual standard error: 0.41658 on 207 degrees of freedom #> Multiple R-squared:  0.22373,\tAdjusted R-squared:  0.21248  #> F-statistic: 19.887 on 3 and 207 DF,  p-value: 2.2881e-11 #>  #> Alpha: -0.64302, standard error: 0.1043 #>     z-value: -6.1649, p-value: 7.0511e-10 #> LR test value: 48.296, p-value: 3.6644e-12 #> Implied rho: 0.4742995  #>  coef(x) #>               Estimate Std. Error   t value     Pr(>|t|) #> (Intercept)  1.5463761 0.21451319  7.208769 1.038762e-11 #> PATIO        0.2582874 0.08689079  2.972552 3.303312e-03 #> log(AGE)    -0.1481738 0.03525174 -4.203305 3.912250e-05 #> log(SQFT)    0.3009659 0.07159771  4.203569 3.908038e-05 has_expm <- require(\"expm\", quietly=TRUE) #>  #> Attaching package: ‘expm’ #> The following object is masked from ‘package:Matrix’: #>  #>     expm if (has_expm) { system.time( obj2a <- lagmess(log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data=baltimore, listw=lw, use_expm=TRUE) ) summary(obj2a) } #> Matrix exponential spatial lag model: #> (calculated with expm) #>  #> Call: #> lagmess(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT),  #>     data = baltimore, listw = lw, use_expm = TRUE) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -2.026722 -0.141191  0.050831  0.223830  1.073114  #>  #> Coefficients: #>              Estimate Std. Error t value  Pr(>|t|) #> (Intercept)  1.546376   0.214513  7.2088 1.039e-11 #> PATIO        0.258287   0.086891  2.9726  0.003303 #> log(AGE)    -0.148174   0.035252 -4.2033 3.912e-05 #> log(SQFT)    0.300966   0.071598  4.2036 3.908e-05 #>  #> Residual standard error: 0.41658 on 207 degrees of freedom #> Multiple R-squared:  0.22373,\tAdjusted R-squared:  0.21248  #> F-statistic: 19.887 on 3 and 207 DF,  p-value: 2.2881e-11 #>  #> Alpha: -0.64302, standard error: 0.1043 #>     z-value: -6.1649, p-value: 7.0511e-10 #> LR test value: 48.296, p-value: 3.6644e-12 #> Implied rho: 0.4742995  #>  obj3 <- lagsarlm(log(PRICE) ~ PATIO + log(AGE) + log(SQFT), data=baltimore, listw=lw) summary(obj3) #>  #> Call:lagsarlm(formula = log(PRICE) ~ PATIO + log(AGE) + log(SQFT),  #>     data = baltimore, listw = lw) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.969554 -0.147514  0.042581  0.199567  1.076181  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept)  1.255885   0.320679  3.9163 8.991e-05 #> PATIO        0.244225   0.083448  2.9267 0.0034262 #> log(AGE)    -0.131947   0.034510 -3.8235 0.0001316 #> log(SQFT)    0.278888   0.070259  3.9694 7.205e-05 #>  #> Rho: 0.55765, LR test value: 52.661, p-value: 3.9635e-13 #> Asymptotic standard error: 0.072749 #>     z-value: 7.6653, p-value: 1.7764e-14 #> Wald statistic: 58.757, p-value: 1.7875e-14 #>  #> Log likelihood: -110.4248 for lag model #> ML residual variance (sigma squared): 0.1589, (sigma: 0.39862) #> Number of observations: 211  #> Number of parameters estimated: 6  #> AIC: 232.85, (AIC for lm: 283.51) #> LM test for residual autocorrelation #> test value: 8.7942, p-value: 0.0030219 #>  # \\donttest{ data(boston, package=\"spData\") lw <- spdep::nb2listw(boston.soi) gp2 <- lagsarlm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2)  +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),  data=boston.c, lw, method=\"Matrix\") summary(gp2) #>  #> Call:lagsarlm(formula = log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  #>     I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B +  #>     log(LSTAT), data = boston.c, listw = lw, method = \"Matrix\") #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -0.5262308 -0.0749699 -0.0044237  0.0713409  0.7122121  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>                Estimate  Std. Error  z value  Pr(>|z|) #> (Intercept)  2.2796e+00  1.7495e-01  13.0302 < 2.2e-16 #> CRIM        -7.1045e-03  9.6236e-04  -7.3824 1.554e-13 #> ZN           3.7985e-04  3.8510e-04   0.9864 0.3239507 #> INDUS        1.2572e-03  1.7986e-03   0.6990 0.4845472 #> CHAS1        7.3677e-03  2.5416e-02   0.2899 0.7719057 #> I(NOX^2)    -2.6892e-01  8.8026e-02  -3.0550 0.0022508 #> I(RM^2)      6.7243e-03  1.0039e-03   6.6985 2.106e-11 #> AGE         -2.7682e-04  4.0062e-04  -0.6910 0.4895829 #> log(DIS)    -1.5830e-01  2.5554e-02  -6.1947 5.841e-10 #> log(RAD)     7.0689e-02  1.4616e-02   4.8363 1.323e-06 #> TAX         -3.6569e-04  9.3744e-05  -3.9009 9.582e-05 #> PTRATIO     -1.2011e-02  3.9599e-03  -3.0330 0.0024211 #> B            2.8432e-04  7.9402e-05   3.5807 0.0003427 #> log(LSTAT)  -2.3216e-01  2.0425e-02 -11.3663 < 2.2e-16 #>  #> Rho: 0.48537, LR test value: 214.06, p-value: < 2.22e-16 #> Asymptotic standard error: 0.029426 #>     z-value: 16.494, p-value: < 2.22e-16 #> Wald statistic: 272.06, p-value: < 2.22e-16 #>  #> Log likelihood: 264.0089 for lag model #> ML residual variance (sigma squared): 0.019276, (sigma: 0.13884) #> Number of observations: 506  #> Number of parameters estimated: 16  #> AIC: -496.02, (AIC for lm: -283.96) #> LM test for residual autocorrelation #> test value: 10.74, p-value: 0.0010486 #>  gp2a <- lagmess(CMEDV ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2)  +  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),  data=boston.c, lw) summary(gp2a) #> Matrix exponential spatial lag model: #>  #> Call: #> lagmess(formula = CMEDV ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  #>     I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B +  #>     log(LSTAT), data = boston.c, listw = lw) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -17.03755  -2.05386  -0.30295   1.67710  21.82120  #>  #> Coefficients: #>               Estimate Std. Error  t value  Pr(>|t|) #> (Intercept) 35.3206850  3.0128759  11.7232 < 2.2e-16 #> CRIM        -0.0986056  0.0242819  -4.0609 5.688e-05 #> ZN           0.0198500  0.0098638   2.0124 0.0447222 #> INDUS        0.0071211  0.0461104   0.1544 0.8773301 #> CHAS1        0.8158059  0.6477224   1.2595 0.2084473 #> I(NOX^2)    -9.2592911  2.2072427  -4.1950 3.238e-05 #> I(RM^2)      0.2434745  0.0256001   9.5107 < 2.2e-16 #> AGE         -0.0040683  0.0102667  -0.3963 0.6920816 #> log(DIS)    -5.3974116  0.6514323  -8.2855 1.125e-15 #> log(RAD)     1.7142905  0.3732772   4.5925 5.569e-06 #> TAX         -0.0087053  0.0023933  -3.6373 0.0003046 #> PTRATIO     -0.4118524  0.0977997  -4.2112 3.021e-05 #> B            0.0056141  0.0020116   2.7908 0.0054614 #> log(LSTAT)  -6.1484203  0.4878957 -12.6019 < 2.2e-16 #>  #> Residual standard error: 3.5594 on 492 degrees of freedom #> Multiple R-squared:  0.76221,\tAdjusted R-squared:  0.75593  #> F-statistic: 121.31 on 13 and 492 DF,  p-value: < 2.22e-16 #>  #> Alpha: -0.41361, standard error: 0.038521 #>     z-value: -10.737, p-value: < 2.22e-16 #> LR test value: 121.4, p-value: < 2.22e-16 #> Implied rho: 0.3387434  #>  # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/lextrB.html","id":null,"dir":"Reference","previous_headings":"","what":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","title":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","text":"functions find extreme eigenvalues binary symmetric spatial weights, form planar graphs; general weights permiited. l_max finds largest eigenvalue using Rayleigh quotient methods “listw” object. lextrB first calls l_max, uses output find smallest eigenvalue addition binary symmetric spatial weights. lextrW extends find smallest eigenvalue intrinsically symmetric row-standardized binary weights matrices (transformed symmetric similarity internally). lextrS variance-stabilized (“S” style) intrinsically symmetric binary weights matrices (transformed symmetric similarity internally).","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lextrB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","text":"","code":"lextrB(lw, zero.policy = TRUE, control = list()) lextrW(lw, zero.policy=TRUE, control=list()) lextrS(lw, zero.policy=TRUE, control=list()) l_max(lw, zero.policy=TRUE, control=list())"},{"path":"https://r-spatial.github.io/spatialreg/reference/lextrB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","text":"lw binary symmetric listw object , example, nb2listw style “B” lextrB, style “W” lextrW style “S” lextrS; l_max, object may asymmetric binary zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA control list control arguments","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lextrB.html","id":"control-arguments","dir":"Reference","previous_headings":"","what":"Control arguments","title":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","text":"trace report values loops, default NULL assuming FALSE; logical tol tolerance breaking loops, default .Machine$double.eps^(1/2); numeric maxiter maximum number iterations loops, default 6 * (length(lw$neighbours) - 2; integer useC use C code, default TRUE, logical (l_max)","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lextrB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","text":"functions return approximations extreme eigenvalues eigenvectors returned attributes object.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lextrB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","text":"Griffith, D. . (2004). Extreme eigenfunctions adjacency matrices planar graphs employed spatial analyses. Linear Algebra Applications, 388:201–219.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lextrB.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","text":"Roger Bivand, Yongwan Chun, Daniel Griffith","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lextrB.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","text":"may necessary modify control arguments warnings lack convergence seen.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/lextrB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find extreme eigenvalues of binary symmetric spatial weights — lextrB","text":"","code":"data(boston, package=\"spData\") #require(spdep, quietly=TRUE) ab.listb <- spdep::nb2listw(boston.soi, style=\"B\") er <- range(eigenw(ab.listb)) er #> [1] -3.039465  5.306204 res_1 <- lextrB(ab.listb) c(res_1) #>  lambda_n  lambda_1  #> -3.039374  5.306203  run <- FALSE if (require(\"RSpectra\", quietly=TRUE)) run <- TRUE if (run) { B <- as(ab.listb, \"CsparseMatrix\") eigs(B, k=1, which=\"SR\")$values } #> [1] -3.039465 if (run) { eigs(B, k=1, which=\"LR\")$values } #> [1] 5.306204 k5 <- spdep::knn2nb(spdep::knearneigh(boston.utm, k=5)) c(l_max(spdep::nb2listw(k5, style=\"B\"))) #> [1] 5 max(Re(eigenw(spdep::nb2listw(k5, style=\"B\")))) #> [1] 5 c(l_max(spdep::nb2listw(k5, style=\"C\"))) #> [1] 1 max(Re(eigenw(spdep::nb2listw(k5, style=\"C\")))) #> [1] 1 ab.listw <- spdep::nb2listw(boston.soi, style=\"W\") er <- range(eigenw(similar.listw(ab.listw))) er #> [1] -0.9708644  1.0000000 res_1 <- lextrW(ab.listw) c(res_1) #>   lambda_n   lambda_1  #> -0.9708644  0.9999991  if (run) { B <- as(similar.listw(ab.listw), \"CsparseMatrix\") eigs(B, k=1, which=\"SR\")$values } #> [1] -0.9708644 if (run) { eigs(B, k=1, which=\"LR\")$values } #> [1] 1 # \\dontrun{ ab.listw <- spdep::nb2listw(boston.soi, style=\"S\") er <- range(eigenw(similar.listw(ab.listw))) er #> [1] -0.723495  1.110373 res_1 <- lextrS(ab.listw) c(res_1) #>   lambda_n   lambda_1  #> -0.7230376  1.1103694  # } if (run) { B <- as(similar.listw(ab.listw), \"CsparseMatrix\") eigs(B, k=1, which=\"SR\")$values } #> [1] -0.723495 if (run) { eigs(B, k=1, which=\"LR\")$values } #> [1] 1.110373"},{"path":"https://r-spatial.github.io/spatialreg/reference/predict.sarlm.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction for spatial simultaneous autoregressive linear model objects — predict.Sarlm","title":"Prediction for spatial simultaneous autoregressive linear model objects — predict.Sarlm","text":"predict.Sarlm() calculates predictions far present possible spatial simultaneous autoregressive linear model objects, using Haining's terminology decomposition trend, signal, noise, types predictors — see references.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/predict.sarlm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction for spatial simultaneous autoregressive linear model objects — predict.Sarlm","text":"","code":"# S3 method for class 'Sarlm' predict(object, newdata = NULL, listw = NULL, pred.type = \"TS\", all.data = FALSE,  zero.policy = NULL, legacy = TRUE, legacy.mixed = FALSE, power = NULL, order = 250,  tol = .Machine$double.eps^(3/5), spChk = NULL, ...) #\\method{predict}{SLX}(object, newdata, listw, zero.policy=NULL, ...) # S3 method for class 'Sarlm.pred' print(x, ...) # S3 method for class 'Sarlm.pred' as.data.frame(x, ...)"},{"path":"https://r-spatial.github.io/spatialreg/reference/predict.sarlm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction for spatial simultaneous autoregressive linear model objects — predict.Sarlm","text":"object Sarlm object returned lagsarlm, errorsarlm sacsarlm, method SLX objects takes output lmSLX newdata data frame predict — NULL, predictions data model fitted. row names corresponding region.id. row names exactly ones used training, uses -sample predictors forecast.  See ‘Details’ listw listw object created example nb2listw. --sample prediction case (ie. newdata NULL), legacy.mixed=FALSE pred.type!=\"TS\", include -sample --sample spatial units. case, regions listw correct order, reordered.  See ‘Details’ pred.type predictor type — default “TS”, use decomposition trend, signal, noise ; types available depending newdata. newdata=NULL (-sample prediction), “TS”, “trend”, “TC” “BP” available. newdata NULL row names data used fit model (forecast case), “TS”, “trend” “TC” available. cases (--sample prediction), “TS”, “trend”, “KP1”, “KP2”, “KP3”, “KP4”, “KP5”, “TC”, “BP”, “BPW”, “BPN”, “TS1”, “TC1”, “BP1”, “BPW1” “BPN1” available.  See ‘Details’ references .data (applies pred.type=\"TC\" newdata NULL) default FALSE: return predictions newdata units, TRUE return predictions data units.  See ‘Details’ zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE (default) assign NA - causing function terminate error legacy (applies lag Durbin (mixed) models pred.type=\"TS\") default TRUE: use ad-hoc predictor, FALSE use DGP-based predictor legacy.mixed (applies mixed models newdata NULL) default FALSE: compute lagged variables -sample --sample units \\([W X]_O\\) \\([W X]_S\\) X=cbind(Xs, Xo), TRUE compute lagged variables independantly -sample --sample units \\(W_{OO} X_O\\) \\(W_{SS} X_S\\) power (applies lag Durbin (mixed) models “TS”, “KP1”, “KP2”, “KP3”, “TC”, “TC1”, “BP”, “BP1”, “BPN”, “BPN1”, “BPW” “BPW1” types) use powerWeights, default NULL, set FALSE object$method “eigen”, otherwise TRUE order power series maximum limit power TRUE tol tolerance convergence power series power TRUE spChk row names data frames checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() x object printed  ... arguments passed ","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/predict.sarlm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prediction for spatial simultaneous autoregressive linear model objects — predict.Sarlm","text":"function supports three types prediction.  -sample prediction computation predictors data used fit model (newdata=NULL).  Prevision, also called forecast, computation predictors (“trend”, -sample “TC” --sample “TS”) spatial units ones used fit model, different observations variables model (row names newdata row names data frame used fit model).  --sample prediction computation predictors spatial units ones used fit model (newdata different row names).  extensive definitions, see Goulard et al. (2017). pred.type predictors available according model object type prediction.  two following tables, “yes” means predictor can used model, “” means predict.Sarlm() stop error, “yes*” means predictor designed specified model, can used predict.Sarlm().  last case, careful computation inappropriate predictor. -sample predictors models Note “trend” “TC” available prevision. --sample predictors models Values pred.type= include “TS1”, “TC”, “TC1”, “BP”, “BP1”, “BPW”, “BPW1”, “BPN”, “BPN1”, following notation Goulard et al. (2017), pred.type= “KP1”, “KP2”, “KP3”, “KP4”, “KP5”, following notation Kelejian et al. (2007).  pred.type=\"TS\" described bellow Bivand (2002). following, trend non-spatial smooth, signal spatial smooth, noise residual.  fit returned pred.type=\"TS\" sum trend signal. pred.type=\"TS\", function approaches prediction first dividing invocations without newdata.  newdata present, response variable may reconstructed sum trend, signal, noise (residuals).  Since values response variable known, spatial lags used calculate signal components (Cressie 1993, p. 564).  error model, trend = \\(X \\beta\\), signal = \\(\\lambda W y - \\lambda W X \\beta\\). lag mixed models, trend = \\(X \\beta\\), signal = \\(\\rho W y\\). approach differs design choices made software, example GeoDa, use observations response variable, corresponds newdata situation described . however newdata used prediction, observations response variable predicted available.  Consequently, trend components , signal take full account spatial smooth.  error model Durbin error model, signal set zero, since spatial smooth expressed terms error: \\((- \\lambda W)^{-1} \\varepsilon\\). lag model, signal can expressed following way (legacy=TRUE): $$(- \\rho W) y = X \\beta + \\varepsilon$$ $$y = (- \\rho W)^{-1} X \\beta + (- \\rho W)^{-1} \\varepsilon$$ giving feasible signal component : $$\\rho W y = \\rho W (- \\rho W)^{-1} X \\beta$$ legacy=FALSE, trend computed first : $$X \\beta$$ next prediction using DGP: $$(- \\rho W)^{-1} X \\beta$$ signal found difference prediction trend. numerical results legacy DGP methods identical. setting error term zero.  also means predictions signal component lag mixed models require inversion n--n matrix. outcomes spatial smooth error term unobservable, means signal values newdata incomplete.  mixed model, spatially lagged RHS variables influence trend signal, root mean square prediction error examples case newdata smallest, although model best fit. newdata one row, leave-one-predictors (pred.type= include “TS1”, “TC1”, “BP1”, “BPW1”, “BPN1”, “KP1”, “KP2”, “KP3”, “KP4”, “KP5”) computed separatly --sample unit. listw provided except newdata=NULL pred.type= include “TS”, “trend”, newdata NULL, pred.type=\"trend\" object mixed model. .data useful --sample predictors return different predictions -sample units, predictor type computed -sample data.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/predict.sarlm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction for spatial simultaneous autoregressive linear model objects — predict.Sarlm","text":"predict.Sarlm() returns vector predictions three attribute vectors trend, signal (pred.type=\"TS\") region.id values two attributes pred.type call class Sarlm.pred. print.Sarlm.pred() print function class, printing returning data frame columns: \"fit\", \"trend\" \"signal\" (available) region.id row names.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/predict.sarlm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prediction for spatial simultaneous autoregressive linear model objects — predict.Sarlm","text":"Haining, R. 1990 Spatial data analysis social environmental sciences, Cambridge: Cambridge University Press, p. 258; Cressie, N. . C. 1993 Statistics spatial data, Wiley, New York; Michel Goulard, Thibault Laurent & Christine Thomas-Agnan, 2017 predictions spatial autoregressive models: optimal almost optimal strategies,  Spatial Economic Analysis Volume 12, Issue 2–3, 304–325 doi:10.1080/17421772.2017.1300679 , ; Kelejian, H. H. Prucha, . R. 2007 relative efficiencies various predictors spatial econometric models containing spatial lags, Regional Science Urban Economics, Volume 37, Issue 3, 363–374; Bivand, R. 2002 Spatial econometrics functions R: Classes methods, Journal Geographical Systems, Volume 4, . 4, 405–421","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/predict.sarlm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Prediction for spatial simultaneous autoregressive linear model objects — predict.Sarlm","text":"Roger Bivand Roger.Bivand@nhh.Martin Gubri","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/predict.sarlm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction for spatial simultaneous autoregressive linear model objects — predict.Sarlm","text":"","code":"data(oldcol, package=\"spdep\") lw <- spdep::nb2listw(COL.nb) COL.lag.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw)  COL.mix.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw,   type=\"mixed\") print(p1 <- predict(COL.mix.eig)) #> This method assumes the response is known - see manual page #>            fit     trend    signal #> 1001 26.044310 14.854350 11.189960 #> 1002 44.034234 29.263210 14.771023 #> 1003 43.511934 25.819381 17.692554 #> 1004 37.656561 16.455557 21.201004 #> 1005 10.902976  0.366406 10.536570 #> 1006 36.829798 24.290524 12.539274 #> 1007 44.290467 27.038660 17.251807 #> 1008 38.853571 21.534238 17.319332 #> 1009 50.870854 29.509277 21.361577 #> 1010 16.401300  5.602910 10.798390 #> 1011 36.354390 28.641535  7.712855 #> 1012 20.452836 12.460727  7.992109 #> 1013 20.324088 14.417343  5.906745 #> 1014 19.243496 10.260642  8.982854 #> 1015 19.747775 12.255686  7.492089 #> 1016  6.962527 -2.013749  8.976277 #> 1017  7.452143 -6.380893 13.833037 #> 1018 28.481587 14.212559 14.269028 #> 1019 43.351392 28.044206 15.307187 #> 1020 50.359682 30.660814 19.698868 #> 1021 38.905226 24.749097 14.156129 #> 1022 44.724478 28.831429 15.893049 #> 1023 37.888974 23.777886 14.111088 #> 1024 45.527017 26.916318 18.610699 #> 1025 32.429571 17.189239 15.240332 #> 1026 26.490842 14.889397 11.601445 #> 1027 35.629157 23.457720 12.171437 #> 1028 35.574326 21.900100 13.674226 #> 1029 38.598639 23.181843 15.416796 #> 1030 36.602053 14.861406 21.740647 #> 1031 50.320031 30.101397 20.218634 #> 1032 53.698863 31.209416 22.489448 #> 1033 49.364208 26.515119 22.849089 #> 1034 46.262357 25.553822 20.708535 #> 1035 39.177121 15.768932 23.408190 #> 1036 54.984344 32.659083 22.325261 #> 1037 51.611458 33.129019 18.482439 #> 1038 51.998831 30.742830 21.256001 #> 1039 43.651605 27.410787 16.240818 #> 1040 44.196841 25.940924 18.255917 #> 1041 49.310593 29.510649 19.799944 #> 1042 37.995310 15.703901 22.291409 #> 1043 46.908709 28.268759 18.639949 #> 1044 28.976789 19.538922  9.437868 #> 1045 25.343793 17.183819  8.159973 #> 1046 24.006252 16.010370  7.995883 #> 1047 25.034907 18.461647  6.573260 #> 1048 10.478529  3.357357  7.121172 #> 1049 13.495623  5.335650  8.159973 print(p2 <- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, pred.type = \"TS\",  legacy.mixed = TRUE)) #>            fit     trend    signal #> 1001 29.038788 14.854350 14.184438 #> 1002 46.227075 29.263210 16.963865 #> 1003 45.640479 25.819381 19.821099 #> 1004 36.643520 16.455557 20.187963 #> 1005 14.819940  0.366406 14.453534 #> 1006 38.764777 24.290524 14.474253 #> 1007 45.715716 27.038660 18.677056 #> 1008 37.514611 21.534238 15.980372 #> 1009 49.324228 29.509277 19.814951 #> 1010 17.510606  5.602910 11.907697 #> 1011 34.973607 28.641535  6.332073 #> 1012 21.079100 12.460727  8.618373 #> 1013 19.704134 14.417343  5.286791 #> 1014 16.365521 10.260642  6.104879 #> 1015 17.063856 12.255686  4.808170 #> 1016  6.190282 -2.013749  8.204032 #> 1017  5.967260 -6.380893 12.348154 #> 1018 29.250462 14.212559 15.037903 #> 1019 41.530036 28.044206 13.485830 #> 1020 49.344769 30.660814 18.683955 #> 1021 39.508818 24.749097 14.759721 #> 1022 42.772692 28.831429 13.941263 #> 1023 37.114901 23.777886 13.337016 #> 1024 43.622499 26.916318 16.706181 #> 1025 33.247197 17.189239 16.057958 #> 1026 30.301331 14.889397 15.411934 #> 1027 38.316063 23.457720 14.858343 #> 1028 36.886068 21.900100 14.985968 #> 1029 38.970564 23.181843 15.788721 #> 1030 33.014615 14.861406 18.153209 #> 1031 48.209875 30.101397 18.108478 #> 1032 50.808064 31.209416 19.598648 #> 1033 44.555996 26.515119 18.040877 #> 1034 43.232773 25.553822 17.678952 #> 1035 35.009061 15.768932 19.240129 #> 1036 52.113364 32.659083 19.454281 #> 1037 52.189015 33.129019 19.059996 #> 1038 51.631805 30.742830 20.888974 #> 1039 46.543564 27.410787 19.132778 #> 1040 45.036095 25.940924 19.095171 #> 1041 45.907835 29.510649 16.397186 #> 1042 35.337110 15.703901 19.633209 #> 1043 43.948398 28.268759 15.679639 #> 1044 32.091257 19.538922 12.552335 #> 1045 29.647005 17.183819 12.463186 #> 1046 26.375304 16.010370 10.364935 #> 1047 27.235807 18.461647  8.774160 #> 1048 14.785518  3.357357 11.428161 #> 1049 17.798836  5.335650 12.463186 AIC(COL.mix.eig) #> [1] 376.787 sqrt(deviance(COL.mix.eig)/length(COL.nb)) #> [1] 9.580773 sqrt(sum((COL.OLD$CRIME - as.vector(p1))^2)/length(COL.nb)) #> [1] 9.580773 sqrt(sum((COL.OLD$CRIME - as.vector(p2))^2)/length(COL.nb)) #> [1] 10.35029  COL.err.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw) AIC(COL.err.eig) #> [1] 376.7609 sqrt(deviance(COL.err.eig)/length(COL.nb)) #> [1] 9.776221 sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.err.eig)))^2)/length(COL.nb)) #> This method assumes the response is known - see manual page #> [1] 9.776221 sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.err.eig, newdata=COL.OLD,   listw=lw, pred.type = \"TS\")))^2)/length(COL.nb)) #> [1] 11.61744  COL.SDerr.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw,  etype=\"emixed\") AIC(COL.SDerr.eig) #> [1] 377.1693 sqrt(deviance(COL.SDerr.eig)/length(COL.nb)) #> [1] 9.619298 sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.SDerr.eig)))^2)/length(COL.nb)) #> This method assumes the response is known - see manual page #> [1] 9.619298 sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.SDerr.eig, newdata=COL.OLD,   listw=lw, pred.type = \"TS\")))^2)/length(COL.nb)) #> Warning: only legacy.mixed=TRUE is supported for pred.type='TS' and mixed models. legacy.mixed is forced #> [1] 10.40472  AIC(COL.lag.eig) #> [1] 374.7809 sqrt(deviance(COL.lag.eig)/length(COL.nb)) #> [1] 9.772129 sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.lag.eig)))^2)/length(COL.nb)) #> This method assumes the response is known - see manual page #> [1] 9.772129 sqrt(sum((COL.OLD$CRIME - as.vector(predict(COL.lag.eig, newdata=COL.OLD,   listw=lw, pred.type = \"TS\")))^2)/length(COL.nb)) #> [1] 10.72654  p3 <- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, pred.type = \"TS\",  legacy=FALSE, legacy.mixed = TRUE) all.equal(p2, p3, check.attributes=FALSE) #> [1] TRUE p4 <- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, pred.type = \"TS\",  legacy=FALSE, power=TRUE, legacy.mixed = TRUE) all.equal(p2, p4, check.attributes=FALSE) #> [1] TRUE p5 <- predict(COL.mix.eig, newdata=COL.OLD, listw=lw, pred.type = \"TS\",  legacy=TRUE, power=TRUE, legacy.mixed = TRUE) all.equal(p2, p5, check.attributes=FALSE) #> [1] TRUE"},{"path":"https://r-spatial.github.io/spatialreg/reference/sarlm_tests.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood ratio test — LR.Sarlm","title":"Likelihood ratio test — LR.Sarlm","text":"LR.Sarlm() function provides likelihood ratio test objects logLik() function exists class, objects class logLik. LR1.Sarlm() Wald1.Sarlm() used internally summary.Sarlm(), may accessed directly; report values respectively LR Wald tests absence spatial dependence spatial lag error models. spatial Hausman test available models fitted errorSarlm GMerrorsar.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/sarlm_tests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood ratio test — LR.Sarlm","text":"","code":"LR.Sarlm(x, y) # S3 method for class 'Sarlm' logLik(object, ...) LR1.Sarlm(object) Wald1.Sarlm(object) # S3 method for class 'Sarlm' Hausman.test(object, ..., tol=NULL) # S3 method for class 'Sarlm' anova(object, ...) bptest.Sarlm(object, varformula=NULL, studentize = TRUE, data=list()) # S3 method for class 'Sarlm' impacts(obj, ..., tr, R = NULL, listw = NULL, evalues=NULL,  useHESS = NULL, tol = 1e-06, empirical = FALSE, Q=NULL)"},{"path":"https://r-spatial.github.io/spatialreg/reference/sarlm_tests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood ratio test — LR.Sarlm","text":"x logLik object object logLik() function exists y logLik object object logLik() function exists object, obj Sarlm object ... arguments passed methods  varformula formula describing potential explanatory variables variance (dependent variable needed). default explanatory variables taken main regression model studentize logical. set TRUE Koenker's studentized    version test statistic used. data optional data frame containing variables varformula tr vector traces powers spatial weights matrix created using trW, approximate impact measures; given, listw must given exact measures (small moderate spatial weights matrices); traces must spatial weights used fitting spatial regression, must row-standardised listw tr given, spatial weights object created nb2listw; must spatial weights used fitting spatial regression, row-standardised evalues vector eigenvalues spatial weights matrix impacts calculations R given, simulations used compute distributions impact measures, returned mcmc objects; objects used convenience output MCMC process useHESS Use Hessian approximation (available) even asymptotic coefficient covariance matrix available; used comparing methods tol Argument passed mvrnorm solve: tolerance (relative largest variance) numerical lack positive-definiteness coefficient covariance matrix empirical Argument passed mvrnorm (default FALSE): true, coefficients covariance matrix specify empirical population mean covariance matrix Q default NULL, else integer number cumulative power series impacts calculate tr given","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/sarlm_tests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood ratio test — LR.Sarlm","text":"tests return objects class htest : statistic value statistic parameter degrees freedom p.value Probability value estimate varies test method description test method logLik.Sarlm() returns object class logLik   LR1.Sarlm, Hausman.Sarlm Wald1.Sarlm returm objects class htest","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/sarlm_tests.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Likelihood ratio test — LR.Sarlm","text":"numbers degrees freedom returned logLik.Sarlm() include nuisance parameters, number regression coefficients, plus sigma, plus spatial parameter esitmate(s).","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/sarlm_tests.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Likelihood ratio test — LR.Sarlm","text":"LeSage J RK Pace (2009) Introduction Spatial Econometrics. CRC Press, Boca Raton, pp. 61–63; Pace RK LeSage J (2008) spatial Hausman test. Economics Letters 101, 282–284. T.S. Breusch & .R. Pagan (1979), Simple Test Heteroscedasticity Random Coefficient Variation. Econometrica 47, 1287–1294 W. Krämer & H. Sonnberger (1986), Linear Regression Model Test. Heidelberg: Physica. L. Anselin (1988) Spatial econometrics: methods models. Dordrecht: Kluwer, pp. 121–122.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/sarlm_tests.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Likelihood ratio test — LR.Sarlm","text":"Roger Bivand Roger.Bivand@nhh., bptest: Torsten Hothorn Achim Zeileis, modified Roger Bivand","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/sarlm_tests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood ratio test — LR.Sarlm","text":"","code":"require(\"sf\", quietly=TRUE) columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) #require(\"spdep\", quietly=TRUE) col.gal.nb <- spdep::read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) lm.mod <- lm(CRIME ~ HOVAL + INC, data=columbus) lag <- lagsarlm(CRIME ~ HOVAL + INC, data=columbus, spdep::nb2listw(col.gal.nb)) mixed <- lagsarlm(CRIME ~ HOVAL + INC, data=columbus, spdep::nb2listw(col.gal.nb), type=\"mixed\") error <- errorsarlm(CRIME ~ HOVAL + INC, data=columbus, spdep::nb2listw(col.gal.nb)) Hausman.test(error) #>  #> \tSpatial Hausman test (asymptotic) #>  #> data:  NULL #> Hausman test = 6.4729, df = 3, p-value = 0.09074 #>  LR.Sarlm(mixed, error) #>  #> \tLikelihood ratio for spatial linear models #>  #> data:   #> Likelihood ratio = 4.2782, df = 2, p-value = 0.1178 #> sample estimates: #> Log likelihood of mixed Log likelihood of error  #>               -182.0161               -184.1552  #>  anova(lag, lm.mod) #>        Model df    AIC  logLik Test L.Ratio   p-value #> lag        1  5 376.34 -183.17    1                   #> lm.mod     2  4 382.75 -187.38    2  8.4179 0.0037154 anova(lag, error, mixed) #>       Model df    AIC  logLik Test L.Ratio p-value #> lag       1  5 376.34 -183.17    1                 #> error     2  5 378.31 -184.16    1                 #> mixed     3  7 378.03 -182.02    2  4.2782 0.11776 AIC(lag, error, mixed) #>       df      AIC #> lag    5 376.3366 #> error  5 378.3104 #> mixed  7 378.0322 bptest.Sarlm(error) #>  #> \tstudentized Breusch-Pagan test #>  #> data:   #> BP = 9.3694, df = 2, p-value = 0.009235 #>  bptest.Sarlm(error, studentize=FALSE) #>  #> \tBreusch-Pagan test #>  #> data:   #> BP = 16.285, df = 2, p-value = 0.0002908 #>"},{"path":"https://r-spatial.github.io/spatialreg/reference/set.mcOption.html","id":null,"dir":"Reference","previous_headings":"","what":"Options for parallel support — set.mcOption","title":"Options for parallel support — set.mcOption","text":"Provides support use parallel computation parallel package.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.mcOption.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Options for parallel support — set.mcOption","text":"","code":"set.mcOption(value) get.mcOption() set.coresOption(value) get.coresOption() set.ClusterOption(cl) get.ClusterOption()"},{"path":"https://r-spatial.github.io/spatialreg/reference/set.mcOption.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Options for parallel support — set.mcOption","text":"value valid replacement value cl cluster object created makeCluster parallel","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.mcOption.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Options for parallel support — set.mcOption","text":"Options spatialreg package held environment local package namespace exported. Option values set retrieved pairs access functions, get set. mc option set default FALSE Windows systems, fork R session; default TRUE systems, may set FALSE. mc FALSE, Cluster option used: mc FALSE Cluster option NULL parallel computing done, Cluster option passed “cluster” object created parallel snow package access without passed argument. cores option set NULL default, can used store number cores use integer. cores NULL, facilities parallel package used.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.mcOption.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Options for parallel support — set.mcOption","text":"option access functions return current settings, assignment functions usually return previous value option.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.mcOption.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Options for parallel support — set.mcOption","text":"extended example shown documentation mom_calc, including treatment seeding RNG multicore/cluster.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.mcOption.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Options for parallel support — set.mcOption","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.mcOption.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Options for parallel support — set.mcOption","text":"","code":"ls(envir=spatialreg:::.spatialregOptions) #> [1] \"cluster\"      \"cores\"        \"mc\"           \"rlecuyerSeed\" \"verbose\"      #> [6] \"zeroPolicy\"   library(parallel) nc <- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L nc #> [1] 5 # set nc to 1L here if (nc > 1L) nc <- 1L #nc <- ifelse(nc > 2L, 2L, nc) coresOpt <- get.coresOption() coresOpt #> NULL if (!is.na(nc)) {  invisible(set.coresOption(nc))  print(exists(\"mom_calc\"))  if(.Platform$OS.type == \"windows\") { # forking not permitted on Windows - start cluster # removed for Github actions 210502 # \\dontrun{   print(get.mcOption())   cl <- makeCluster(get.coresOption())   print(clusterEvalQ(cl, exists(\"mom_calc\")))   set.ClusterOption(cl)   clusterEvalQ(get.ClusterOption(), library(spatialreg))   print(clusterEvalQ(cl, exists(\"mom_calc\")))   clusterEvalQ(get.ClusterOption(), detach(package:spatialreg))   set.ClusterOption(NULL)   print(clusterEvalQ(cl, exists(\"mom_calc\")))   stopCluster(cl) # }  } else {   mcOpt <- get.mcOption()   print(mcOpt)   print(mclapply(1:get.coresOption(), function(i) exists(\"mom_calc\"),    mc.cores=get.coresOption()))   invisible(set.mcOption(FALSE))   cl <- makeCluster(nc)   print(clusterEvalQ(cl, exists(\"mom_calc\")))   set.ClusterOption(cl)   clusterEvalQ(get.ClusterOption(), library(spatialreg))   print(clusterEvalQ(cl, exists(\"mom_calc\")))   clusterEvalQ(get.ClusterOption(), detach(package:spatialreg))   set.ClusterOption(NULL)   print(clusterEvalQ(cl, exists(\"mom_calc\")))   stopCluster(cl)   invisible(set.mcOption(mcOpt))  }  invisible(set.coresOption(coresOpt)) } #> [1] TRUE #> [1] TRUE #> [[1]] #> [1] TRUE #>  #> [[1]] #> [1] FALSE #>  #> [[1]] #> [1] TRUE #>  #> [[1]] #> [1] FALSE #>"},{"path":"https://r-spatial.github.io/spatialreg/reference/set.spChkOption.html","id":null,"dir":"Reference","previous_headings":"","what":"Control checking of spatial object IDs — set.ZeroPolicyOption","title":"Control checking of spatial object IDs — set.ZeroPolicyOption","text":"Provides support checking mutual integrity spatial neighbour weights spatial data; similar mechanisms used passing global verbose zero.policy options, providing access running cluster embarrassingly parallel tasks.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.spChkOption.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control checking of spatial object IDs — set.ZeroPolicyOption","text":"","code":"set.VerboseOption(check) get.VerboseOption() set.ZeroPolicyOption(check) get.ZeroPolicyOption() #set.listw_is_CsparseMatrix_Option(check) #get.listw_is_CsparseMatrix_Option()"},{"path":"https://r-spatial.github.io/spatialreg/reference/set.spChkOption.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control checking of spatial object IDs — set.ZeroPolicyOption","text":"check logical value, TRUE FALSE","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.spChkOption.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Control checking of spatial object IDs — set.ZeroPolicyOption","text":"Analysis functions spChk argument default set NULL, call get.spChkOption() get global spatial option whether check — initialised FALSE, consequently break anything. can changed TRUE using set.spChkOption(TRUE), spChk argument can assigned analysis functions. spNamedVec() provided ensure rownames passed single columns taken two-dimensional arrays data frames.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.spChkOption.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Control checking of spatial object IDs — set.ZeroPolicyOption","text":"set.spChkOption() returns old logical value, get.spChkOption() returns current logical value, chkIDs() returns logical value test lack difference. spNamedVec() returns selected column names set row names object extracted.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.spChkOption.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Control checking of spatial object IDs — set.ZeroPolicyOption","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/set.spChkOption.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Control checking of spatial object IDs — set.ZeroPolicyOption","text":"","code":"get.VerboseOption() #> [1] FALSE get.ZeroPolicyOption() #> [1] FALSE"},{"path":"https://r-spatial.github.io/spatialreg/reference/similar.listw.html","id":null,"dir":"Reference","previous_headings":"","what":"Create symmetric similar weights lists — similar.listw","title":"Create symmetric similar weights lists — similar.listw","text":"Ord's 1975 paper, known Jacobian SAR models may found \"symmetrizing\" similarity (eigenvalues similar matrices identical, Jacobian ). applies styles \"W\" \"S\" underlying symmetric binary neighbour relations symmetric general neighbour relations (k-nearest neighbour relations). function invoked automatically within SAR fitting functions, call eigen symmetric matrix default eigen method, make possible use Matrix method weights can \"symmetrized\" way.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/similar.listw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create symmetric similar weights lists — similar.listw","text":"","code":"similar.listw(listw)"},{"path":"https://r-spatial.github.io/spatialreg/reference/similar.listw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create symmetric similar weights lists — similar.listw","text":"listw listw object created example spdep::nb2listw","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/similar.listw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create symmetric similar weights lists — similar.listw","text":"listw object","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/similar.listw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create symmetric similar weights lists — similar.listw","text":"Ord, J. K. 1975 Estimation methods models spatial interaction, Journal American Statistical Association, 70, 120-126","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/similar.listw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create symmetric similar weights lists — similar.listw","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/similar.listw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create symmetric similar weights lists — similar.listw","text":"","code":"#require(\"spdep\", quietly=TRUE) data(oldcol, package=\"spdep\") COL.W <- spdep::nb2listw(COL.nb, style=\"W\") COL.S <- spdep::nb2listw(COL.nb, style=\"S\") sum(log(1 - 0.5 * eigenw(COL.W))) #> [1] -1.62766 sum(log(1 - 0.5 * eigenw(similar.listw(COL.W)))) #> [1] -1.62766 W_J <- as(as_dsTMatrix_listw(similar.listw(COL.W)), \"CsparseMatrix\") I <- as_dsCMatrix_I(dim(W_J)[1]) c(determinant(I - 0.5 * W_J, logarithm=TRUE)$modulus) #> [1] -1.62766 sum(log(1 - 0.5 * eigenw(COL.S))) #> [1] -1.602757 sum(log(1 - 0.5 * eigenw(similar.listw(COL.S)))) #> [1] -1.602757 W_J <- as(as_dsTMatrix_listw(similar.listw(COL.S)), \"CsparseMatrix\") c(determinant(I - 0.5 * W_J, logarithm=TRUE)$modulus) #> [1] -1.602757"},{"path":"https://r-spatial.github.io/spatialreg/reference/sparse_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial neighbour sparse representation — as.spam.listw","title":"Spatial neighbour sparse representation — as.spam.listw","text":"Interface Matrix class objects weights lists. .spam.listw method converts \"listw\" object sparse matrix defined spam package.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/sparse_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial neighbour sparse representation — as.spam.listw","text":"","code":"as.spam.listw(listw) listw2U_spam(lw) listw2U_Matrix(lw) as_dgRMatrix_listw(listw) as_dsTMatrix_listw(listw) as_dsCMatrix_I(n) as_dsCMatrix_IrW(W, rho) Jacobian_W(W, rho) powerWeights(W, rho, order=250, X, tol=.Machine$double.eps^(3/5))"},{"path":"https://r-spatial.github.io/spatialreg/reference/sparse_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial neighbour sparse representation — as.spam.listw","text":"listw, lw listw object example nb2listw W dsTMatrix object created using as_dsTMatrix_listw symmetric listw object rho spatial regression coefficient n length diagonal identity matrix order Power series maximum limit X numerical matrix tol Tolerance convergence power series","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/sparse_mat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial neighbour sparse representation — as.spam.listw","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/sparse_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial neighbour sparse representation — as.spam.listw","text":"","code":"# \\dontrun{ require(sf, quietly=TRUE) columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) #require(spdep, quietly=TRUE) col.gal.nb <- spdep::read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) col.listw <- spdep::nb2listw(col.gal.nb) if (require(\"spam\", quietly=TRUE)) {   col.sp <- as.spam.listw(col.listw)   str(col.sp) } #> Spam version 2.11-0 (2024-10-03) is loaded. #> Type 'help( Spam)' or 'demo( spam)' for a short introduction  #> and overview of this package. #> Help for individual functions is also obtained by adding the #> suffix '.spam' to the function name, e.g. 'help( chol.spam)'. #>  #> Attaching package: ‘spam’ #> The following object is masked from ‘package:Matrix’: #>  #>     det #> The following objects are masked from ‘package:base’: #>  #>     backsolve, forwardsolve #> Formal class 'spam' [package \"spam\"] with 4 slots #>   ..@ entries    : num [1:230] 0.5 0.5 0.333 0.333 0.333 ... #>   ..@ colindices : int [1:230] 2 3 1 3 4 1 2 4 5 2 ... #>   ..@ rowpointers: int [1:50] 1 3 6 10 14 21 23 27 33 41 ... #>   ..@ dimension  : int [1:2] 49 49 suppressMessages(nyadjmat <- as.matrix(foreign::read.dbf(system.file(  \"misc/nyadjwts.dbf\", package=\"spData\")[1])[-1])) nyadjlw <- spdep::mat2listw(nyadjmat) #> Warning: style is M (missing); style should be set to a valid value listw_NY <- spdep::nb2listw(nyadjlw$neighbours, style=\"B\") W_C <- as(listw_NY, \"CsparseMatrix\") W_R <- as(listw_NY, \"RsparseMatrix\") W_S <- as(listw_NY, \"symmetricMatrix\") n <- nrow(W_S) I <- Diagonal(n) rho <- 0.1 c(determinant(I - rho * W_S, logarithm=TRUE)$modulus) #> [1] -9.587255 sum(log(1 - rho * eigenw(listw_NY))) #> [1] -9.587255 nW <- - W_S nChol <- Cholesky(nW, Imult=8) n * log(rho) + (2 * c(determinant(update(nChol, nW, 1/rho))$modulus)) #> [1] 99.8069 # } nb7rt <- spdep::cell2nb(7, 7, torus=TRUE) x <- matrix(sample(rnorm(500*length(nb7rt))), nrow=length(nb7rt)) lw <- spdep::nb2listw(nb7rt) if (FALSE) { # Only needed in some simulation settings where the input and # output distributions must agree in all but autocorrelation e <- eigenw(lw) x <- apply(x, 2, scale) st <- apply(x, 2, function(x) shapiro.test(x)$p.value) x <- x[, (st > 0.2 & st < 0.8)] x <- apply(x, 2, function(v) residuals(spautolm(v ~ 1, listw=lw,  method=\"eigen\", control=list(pre_eig=e, fdHess=FALSE)))) x <- apply(x, 2, scale) } W <- as(lw, \"CsparseMatrix\") system.time(e <- invIrM(nb7rt, rho=0.98, method=\"solve\", feasible=NULL) %*% x) #>    user  system elapsed  #>   0.002   0.000   0.003  system.time(ee <- powerWeights(W, rho=0.98, X=x)) #> Warning: not converged within order iterations #>    user  system elapsed  #>   0.173   0.006   0.180  str(attr(ee, \"internal\")) #> List of 5 #>  $ series: num [1:250] 0.287 0.234 0.201 0.178 0.16 ... #>  $ order : num 250 #>  $ tol   : num 4.05e-10 #>  $ iter  : num 250 #>  $ conv  : logi FALSE all.equal(e, as(ee, \"matrix\"), check.attributes=FALSE) #> [1] \"Mean relative difference: 0.0060747\" # \\dontrun{ system.time(ee <- powerWeights(W, rho=0.9, X=x)) #>    user  system elapsed  #>   0.130   0.002   0.133  system.time(ee <- powerWeights(W, rho=0.98, order=1000, X=x)) #>    user  system elapsed  #>   0.662   0.011   0.675  all.equal(e, as(ee, \"matrix\"), check.attributes=FALSE) #> [1] TRUE nb60rt <- spdep::cell2nb(60, 60, torus=TRUE) W <- as(spdep::nb2listw(nb60rt), \"CsparseMatrix\") set.seed(1) x <- matrix(rnorm(dim(W)[1]), ncol=1) system.time(ee <- powerWeights(W, rho=0.3, X=x)) #>    user  system elapsed  #>   0.009   0.000   0.009  str(as(ee, \"matrix\")) #>  num [1:3600, 1] -0.383 0.207 -0.731 1.552 0.32 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : chr [1:3600] \"1:1\" \"2:1\" \"3:1\" \"4:1\" ... #>   ..$ : NULL obj <- errorsarlm(as(ee, \"matrix\")[,1] ~ 1, listw=spdep::nb2listw(nb60rt), method=\"Matrix\") coefficients(obj) #>      lambda (Intercept)  #>  0.30639880  0.01380415  # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial conditional and simultaneous autoregression model estimation — spautolm","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"Function taking family weights arguments spatial autoregression model estimation Maximum Likelihood, using dense matrix methods, suited large data sets thousands observations. one sparse matrix methods, larger numbers observations can handled, interval= argument set. implementation GLS using single spatial coefficient value, termed lambda, found line search using optimize maximise log likelihood.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"","code":"spautolm(formula, data = list(), listw, weights,  na.action, family = \"SAR\", method=\"eigen\", verbose = NULL, trs=NULL,  interval=NULL, zero.policy = NULL, tol.solve=.Machine$double.eps,  llprof=NULL, control=list()) # S3 method for class 'Spautolm' summary(object, correlation = FALSE, adj.se=FALSE,  Nagelkerke=FALSE, ...)"},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"formula symbolic description model fit. details model specification given lm() data optional data frame containing variables model. default variables taken environment function called. listw listw object created example nb2listw weights optional vector weights used fitting process na.action function (default options(\"na.action\")), can also na.omit na.exclude consequences residuals fitted values - cases weights list subsetted remove NAs data. Note weights lists created without using glist argument nb2listw may subsetted. family character string: either \"SAR\" \"CAR\" simultaneous conditional autoregressions; \"SMA\" spatial moving average added thanks Jielai Ma - \"SMA\" implemented method=\"eigen\" necessarily involves dense matrices method character string: default \"eigen\" use dense matrices, \"Matrix_J\" sparse matrices (restricted spatial weights symmetric similar symmetric) using methods Matrix package; “Matrix” provides updating Cholesky decomposition methods. Values method may also include \"LU\", provides alternative sparse matrix decomposition approach, \"Chebyshev\" Monte Carlo \"MC\" approximate log-determinant methods. verbose default NULL, use global option value; TRUE, reports function values optimization. trs default NULL, given, vector powered spatial weights matrix traces output trW; given, used Jacobian methods interval search interval autoregressive parameter using method=\"eigen\"; default c(-1,0.999), optimize reset NA/NaN bound gives warning interval poorly set; method=\"Matrix\" attempt search appropriate interval, find_interval=TRUE (fails platforms) zero.policy default NULL, use global option value; Include list -neighbour observations output TRUE — otherwise zero.policy handled within listw argument tol.solve tolerance detecting linear dependencies columns matrices inverted - passed solve() (default=double precision machine tolerance). Errors solve() may constitute indications poorly scaled variables: variables scales differing much autoregressive coefficient, values matrix may different scale, inverting matrix analytically possible definition, numerically unstable; rescaling RHS variables alleviates better setting tol.solve small value llprof default NULL, can either integer, divide feasible range llprof points, sequence spatial coefficient values, evaluate likelihood function control list extra control arguments - see section object Spautolm object spautolm correlation logical; 'TRUE', correlation matrix estimated parameters returned printed (default=FALSE) adj.se TRUE, adjust coefficient standard errors number fitted coefficients Nagelkerke TRUE, Nagelkerke pseudo R-squared reported ... arguments passed methods","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"implementation based lm.gls errorsarlm. particular, function (yet) prevent asymmetric spatial weights used \"CAR\" family models. appears numerical issues (convergence particular) uncertainties exact spatial weights matrix used make difficult reproduce Cressie Chan's 1989 results, also given Cressie 1993. Note fitted() function output object assumes response variable may reconstructed sum trend, signal, noise (residuals). Since values response variable known, spatial lags used calculate signal components (Cressie 1993, p. 564). differs software, including GeoDa, use knowledge response variable making predictions fitting data.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":"control-arguments","dir":"Reference","previous_headings":"","what":"Control arguments","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"tol.opt: desired accuracy optimization - passed optimize() (default=.Machine$double.eps^(2/3)) fdHess: default NULL, set (method != \"eigen\") internally; use fdHess compute approximate Hessian using finite differences using sparse matrix methods; used make coefficient covariance matrix number observations large; may turned save resources need optimHess: default FALSE, use fdHess nlme, TRUE, use optim calculate Hessian optimum optimHessMethod: default “optimHess”, may “nlm” one optim methods Imult: default 2; used preparing Cholesky decompositions updating Jacobian function super: NULL (default), set FALSE use simplicial decomposition sparse Cholesky decomposition method “Matrix_J”, set  .logical(NA) method “Matrix”, TRUE, use supernodal decomposition cheb_q: default 5; highest power approximating polynomial Chebyshev approximation MC_p: default 16; number random variates MC_m: default 30; number products random variates matrix spatial weights matrix type default “MC”, used method “moments”; alternatives “mult” “moments”, use trs missing, trW correct default TRUE, used method “moments” compute Smirnov/Anselin correction term trunc default TRUE, used method “moments” truncate Smirnov/Anselin correction term SE_method default “LU”, may “MC” nrho default 200, SE toolbox; size first stage lndet grid; may reduced example 40 interpn default 2000, SE toolbox; size second stage lndet grid small_asy default TRUE; method “eigen”, use asymmetric covariances rather numerical Hessian ones n <= small small default 1500; threshold number observations asymmetric covariances method “eigen” SElndet default NULL, may used pass pre-computed SE toolbox style matrix coefficients lndet values \"SE_classic\" \"SE_whichMin\" methods LU_order default FALSE; used “LU_prepermutate”, note warnings given lu method pre_eig default NULL; may used pass pre-computed vector eigenvalues","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"list object class Spautolm: fit list, items: coefficients ML coefficient estimates SSE ML sum squared errors s2 ML residual variance imat ML coefficient covariance matrix (multiplying s2) signal_trend non-spatial component fitted.values signal_stochastic spatial component fitted.values fitted.values sum non-spatial spatial components fitted.values residuals difference observed fitted values lambda ML autoregressive coefficient LL log likelihood fitted model LL0 log likelihood model lambda=0 call call used create object parameters number parameters estimated aliased NULL, details aliased variables method Jacobian method chosen family family chosen zero.policy zero.policy used weights case weights used interval line search interval used timings processing timings na.action (possibly) named vector excluded omitted observations non-default na.action argument used llprof NULL, list components lambda ll equal length lambda.se Numerical Hessian-based standard error lambda fdHess Numerical Hessian-based variance-covariance matrix X covariates used model fitting Y response used model fitting weights weights used model fitting","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion; Ord, J. K. 1975 Estimation methods models spatial interaction, Journal American Statistical Association, 70, 120-126; Waller, L. ., Gotway, C. . 2004 Applied spatial statistics public health, Wiley, Hoboken, NJ, 325-380; Cressie, N. . C. 1993 Statistics spatial data, Wiley, New York, 548-568; Ripley, B. D. 1981 Spatial statistics, Wiley, New York, 88-95; LeSage J RK Pace (2009) Introduction Spatial Econometrics. CRC Press, Boca Raton.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"standard errors given Waller Gotway (2004) adjusted numbers parameters estimated, may reproduced using additional argument adj.se=TRUE summary method. addition, function returns fitted values residuals given Cressie (1993) p. 564.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/spautolm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial conditional and simultaneous autoregression model estimation — spautolm","text":"","code":"require(\"sf\", quietly=TRUE) nydata <- st_read(system.file(\"shapes/NY8_bna_utm18.gpkg\", package=\"spData\")[1], quiet=TRUE) # \\dontrun{ lm0 <- lm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata) summary(lm0) #>  #> Call: #> lm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -1.7417 -0.3957 -0.0326  0.3353  4.1398  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept) -0.51728    0.15856  -3.262  0.00124 **  #> PEXPOSURE    0.04884    0.03506   1.393  0.16480     #> PCTAGE65P    3.95089    0.60550   6.525 3.22e-10 *** #> PCTOWNHOME  -0.56004    0.17031  -3.288  0.00114 **  #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 0.6571 on 277 degrees of freedom #> Multiple R-squared:  0.1932,\tAdjusted R-squared:  0.1844  #> F-statistic:  22.1 on 3 and 277 DF,  p-value: 7.306e-13 #>  lm0w <- lm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata, weights=POP8) summary(lm0w) #>  #> Call: #> lm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     weights = POP8) #>  #> Weighted Residuals: #>      Min       1Q   Median       3Q      Max  #> -129.067  -14.714    5.817   25.624   70.723  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept) -0.77837    0.14116  -5.514 8.03e-08 *** #> PEXPOSURE    0.07626    0.02731   2.792  0.00560 **  #> PCTAGE65P    3.85656    0.57126   6.751 8.60e-11 *** #> PCTOWNHOME  -0.39869    0.15305  -2.605  0.00968 **  #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 33.5 on 277 degrees of freedom #> Multiple R-squared:  0.1977,\tAdjusted R-squared:  0.189  #> F-statistic: 22.75 on 3 and 277 DF,  p-value: 3.382e-13 #>  # } suppressMessages(nyadjmat <- as.matrix(foreign::read.dbf(system.file(  \"misc/nyadjwts.dbf\", package=\"spData\")[1])[-1])) suppressMessages(ID <- as.character(names(foreign::read.dbf(system.file(  \"misc/nyadjwts.dbf\", package=\"spData\")[1]))[-1])) identical(substring(ID, 2, 10), substring(as.character(nydata$AREAKEY), 2, 10)) #> [1] TRUE #require(\"spdep\", quietly=TRUE) listw_NY <- spdep::mat2listw(nyadjmat, as.character(nydata$AREAKEY), style=\"B\") eigs <- eigenw(listw_NY) # \\dontrun{ esar0 <- errorsarlm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY) summary(esar0) #>  #> Call:errorsarlm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  #>     data = nydata, listw = listw_NY) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.56754 -0.38239 -0.02643  0.33109  4.01219  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.618193   0.176784 -3.4969 0.0004707 #> PEXPOSURE    0.071014   0.042051  1.6888 0.0912635 #> PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09 #> PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930 #>  #> Lambda: 0.040487, LR test value: 5.2438, p-value: 0.022026 #> Asymptotic standard error: 0.016214 #>     z-value: 2.4971, p-value: 0.01252 #> Wald statistic: 6.2356, p-value: 0.01252 #>  #> Log likelihood: -276.1069 for error model #> ML residual variance (sigma squared): 0.41388, (sigma: 0.64333) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 564.21, (AIC for lm: 567.46) #>  system.time(esar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  data=nydata, listw=listw_NY, family=\"SAR\", method=\"eigen\",  control=list(pre_eig=eigs))) #>    user  system elapsed  #>     0.2     0.0     0.2  res <- summary(esar1f) print(res) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, family = \"SAR\", method = \"eigen\", control = list(pre_eig = eigs)) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.56754 -0.38239 -0.02643  0.33109  4.01219  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.618193   0.176784 -3.4969 0.0004707 #> PEXPOSURE    0.071014   0.042051  1.6888 0.0912635 #> PCTAGE65P    3.754200   0.624722  6.0094 1.862e-09 #> PCTOWNHOME  -0.419890   0.191329 -2.1946 0.0281930 #>  #> Lambda: 0.040487 LR test value: 5.2438 p-value: 0.022026  #> Numerical Hessian standard error of lambda: 0.017201  #>  #> Log likelihood: -276.1069  #> ML residual variance (sigma squared): 0.41388, (sigma: 0.64333) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 564.21 #>  coef(res) #>                Estimate Std. Error   z value     Pr(>|z|) #> (Intercept) -0.61819272 0.17678351 -3.496891 4.707136e-04 #> PEXPOSURE    0.07101384 0.04205063  1.688770 9.126350e-02 #> PCTAGE65P    3.75419996 0.62472153  6.009397 1.862142e-09 #> PCTOWNHOME  -0.41988960 0.19132936 -2.194591 2.819298e-02 sqrt(diag(res$resvar)) #> (Intercept)   PEXPOSURE   PCTAGE65P  PCTOWNHOME  #>  0.17678351  0.04205063  0.62472153  0.19132936  sqrt(diag(esar1f$fit$imat)*esar1f$fit$s2) #> (Intercept)   PEXPOSURE   PCTAGE65P  PCTOWNHOME  #>  0.17678351  0.04205063  0.62472153  0.19132936  sqrt(diag(esar1f$fdHess)) #> [1] 0.01720109 0.18504698 0.04378056 0.62990270 0.20343911 system.time(esar1M <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  data=nydata, listw=listw_NY, family=\"SAR\", method=\"Matrix\")) #>    user  system elapsed  #>   0.227   0.000   0.227  summary(esar1M) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, family = \"SAR\", method = \"Matrix\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -3.406132 -0.561646 -0.092662  0.474796  5.384405  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.414826   0.102166 -4.0603 4.901e-05 #> PEXPOSURE    0.015081   0.017772  0.8486    0.3961 #> PCTAGE65P    5.159749   0.476498 10.8285 < 2.2e-16 #> PCTOWNHOME  -0.892387   0.099241 -8.9921 < 2.2e-16 #>  #> Lambda: -0.38889 LR test value: 254.73 p-value: < 2.22e-16  #> Numerical Hessian standard error of lambda: 0.044857  #>  #> Log likelihood: -151.3662  #> ML residual variance (sigma squared): 0.95111, (sigma: 0.97525) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 314.73 #>  system.time(esar1M <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  data=nydata, listw=listw_NY, family=\"SAR\", method=\"Matrix\",  control=list(super=TRUE))) #>    user  system elapsed  #>   0.203   0.000   0.204  summary(esar1M) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, family = \"SAR\", method = \"Matrix\", control = list(super = TRUE)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -3.178535 -0.521860 -0.074421  0.414212  5.184465  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.411041   0.104426 -3.9362 8.279e-05 #> PEXPOSURE    0.015768   0.018366  0.8585    0.3906 #> PCTAGE65P    5.070130   0.483332 10.4900 < 2.2e-16 #> PCTOWNHOME  -0.880883   0.102093 -8.6282 < 2.2e-16 #>  #> Lambda: -0.33146 LR test value: 247.44 p-value: < 2.22e-16  #> Numerical Hessian standard error of lambda: 0.030659  #>  #> Log likelihood: -155.0108  #> ML residual variance (sigma squared): 0.82436, (sigma: 0.90795) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 322.02 #>  esar1wf <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, weights=POP8, family=\"SAR\", method=\"eigen\",  control=list(pre_eig=eigs)) summary(esar1wf) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, weights = POP8, family = \"SAR\", method = \"eigen\",  #>     control = list(pre_eig = eigs)) #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.48488 -0.26823  0.09489  0.46552  4.28343  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.797063   0.144054 -5.5331 3.146e-08 #> PEXPOSURE    0.080545   0.028334  2.8428  0.004473 #> PCTAGE65P    3.816731   0.576037  6.6258 3.453e-11 #> PCTOWNHOME  -0.380778   0.156507 -2.4330  0.014975 #>  #> Lambda: 0.0095636 LR test value: 0.32665 p-value: 0.56764  #> Numerical Hessian standard error of lambda: 0.016522  #>  #> Log likelihood: -251.6017  #> ML residual variance (sigma squared): 1104.1, (sigma: 33.229) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: NA (not available for weighted model) #>  system.time(esar1wM <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  data=nydata, listw=listw_NY, weights=POP8, family=\"SAR\", method=\"Matrix\")) #>    user  system elapsed  #>    0.22    0.00    0.22  summary(esar1wM) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, weights = POP8, family = \"SAR\", method = \"Matrix\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -2.561100 -0.374524  0.057405  0.591094  5.700142  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.578546   0.090006 -6.4279 1.294e-10 #> PEXPOSURE    0.035402   0.013959  2.5361   0.01121 #> PCTAGE65P    4.651137   0.421285 11.0404 < 2.2e-16 #> PCTOWNHOME  -0.666898   0.091443 -7.2931 3.029e-13 #>  #> Lambda: -0.34423 LR test value: 264.24 p-value: < 2.22e-16  #> Numerical Hessian standard error of lambda: 0.036776  #>  #> Log likelihood: -119.6468  #> ML residual variance (sigma squared): 2129.1, (sigma: 46.142) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: NA (not available for weighted model) #>  esar1wlu <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, weights=POP8, family=\"SAR\", method=\"LU\") summary(esar1wlu) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, weights = POP8, family = \"SAR\", method = \"LU\") #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.48488 -0.26823  0.09489  0.46552  4.28343  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.797063   0.144054 -5.5331 3.146e-08 #> PEXPOSURE    0.080545   0.028334  2.8428  0.004473 #> PCTAGE65P    3.816731   0.576037  6.6258 3.453e-11 #> PCTOWNHOME  -0.380778   0.156507 -2.4330  0.014975 #>  #> Lambda: 0.0095636 LR test value: 0.32665 p-value: 0.56764  #> Numerical Hessian standard error of lambda: 0.016522  #>  #> Log likelihood: -251.6017  #> ML residual variance (sigma squared): 1104.1, (sigma: 33.229) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: NA (not available for weighted model) #>  esar1wch <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, weights=POP8, family=\"SAR\", method=\"Chebyshev\") summary(esar1wch) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, weights = POP8, family = \"SAR\", method = \"Chebyshev\") #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -4.39831 -0.86303  0.12117  1.09320  8.78570  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.538555   0.087573 -6.1498  7.76e-10 #> PEXPOSURE    0.029782   0.013074  2.2780   0.02273 #> PCTAGE65P    4.896346   0.419359 11.6758 < 2.2e-16 #> PCTOWNHOME  -0.737829   0.087569 -8.4257 < 2.2e-16 #>  #> Lambda: -1 LR test value: 236970 p-value: < 2.22e-16  #> Numerical Hessian standard error of lambda: NaN  #>  #> Log likelihood: 118232.5  #> ML residual variance (sigma squared): 9336.4, (sigma: 96.625) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: NA (not available for weighted model) #>  # } ecar1f <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, family=\"CAR\", method=\"eigen\",  control=list(pre_eig=eigs)) summary(ecar1f) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, family = \"CAR\", method = \"eigen\", control = list(pre_eig = eigs)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.539732 -0.384311 -0.030646  0.335126  3.808848  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.648362   0.181129 -3.5796 0.0003442 #> PEXPOSURE    0.077899   0.043692  1.7829 0.0745986 #> PCTAGE65P    3.703830   0.627185  5.9055 3.516e-09 #> PCTOWNHOME  -0.382789   0.195564 -1.9574 0.0503053 #>  #> Lambda: 0.084123 LR test value: 5.8009 p-value: 0.016018  #> Numerical Hessian standard error of lambda: 0.030872  #>  #> Log likelihood: -275.8283  #> ML residual variance (sigma squared): 0.40758, (sigma: 0.63842) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 563.66 #>  # \\dontrun{ system.time(ecar1M <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  data=nydata, listw=listw_NY, family=\"CAR\", method=\"Matrix\")) #>    user  system elapsed  #>   0.311   0.000   0.313  summary(ecar1M) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, family = \"CAR\", method = \"Matrix\") #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -3.449951 -0.633777 -0.072436  0.550248  6.039594  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.402788   0.112612 -3.5768 0.0003479 #> PEXPOSURE    0.020131   0.020783  0.9686 0.3327222 #> PCTAGE65P    4.632644   0.500526  9.2555 < 2.2e-16 #> PCTOWNHOME  -0.812981   0.112867 -7.2030 5.891e-13 #>  #> Lambda: -0.5 LR test value: 228.48 p-value: < 2.22e-16  #> Numerical Hessian standard error of lambda: NaN  #>  #> Log likelihood: -164.4897  #> ML residual variance (sigma squared): 0.50386, (sigma: 0.70983) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: 340.98 #>  # } ecar1wf <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data=nydata,  listw=listw_NY, weights=POP8, family=\"CAR\", method=\"eigen\",  control=list(pre_eig=eigs)) summary(ecar1wf) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, weights = POP8, family = \"CAR\", method = \"eigen\",  #>     control = list(pre_eig = eigs)) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -1.491042 -0.270906  0.081435  0.451556  4.198134  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.790154   0.144862 -5.4545 4.910e-08 #> PEXPOSURE    0.081922   0.028593  2.8651  0.004169 #> PCTAGE65P    3.825858   0.577720  6.6223 3.536e-11 #> PCTOWNHOME  -0.386820   0.157436 -2.4570  0.014010 #>  #> Lambda: 0.022419 LR test value: 0.38785 p-value: 0.53343  #> Numerical Hessian standard error of lambda: 0.038977  #>  #> Log likelihood: -251.5711  #> ML residual variance (sigma squared): 1102.9, (sigma: 33.21) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: NA (not available for weighted model) #>  # \\dontrun{ system.time(ecar1wM <- spautolm(Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME,  data=nydata, listw=listw_NY, weights=POP8, family=\"CAR\", method=\"Matrix\")) #>    user  system elapsed  #>   0.260   0.000   0.262  summary(ecar1wM) #>  #> Call:  #> spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = nydata,  #>     listw = listw_NY, weights = POP8, family = \"CAR\", method = \"Matrix\") #>  #> Residuals: #>      Min       1Q   Median       3Q      Max  #> -1.98144 -0.15716  0.37342  1.08857  7.10495  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) -0.714952   0.093905 -7.6136 2.665e-14 #> PEXPOSURE    0.041467   0.015279  2.7139   0.00665 #> PCTAGE65P    4.149207   0.425446  9.7526 < 2.2e-16 #> PCTOWNHOME  -0.478396   0.097030 -4.9304 8.205e-07 #>  #> Lambda: -0.5 LR test value: 262.65 p-value: < 2.22e-16  #> Numerical Hessian standard error of lambda: NaN  #>  #> Log likelihood: -120.4395  #> ML residual variance (sigma squared): 1159.2, (sigma: 34.046) #> Number of observations: 281  #> Number of parameters estimated: 6  #> AIC: NA (not available for weighted model) #>  # } # \\dontrun{ require(\"sf\", quietly=TRUE) nc.sids <- st_read(system.file(\"shapes/sids.gpkg\", package=\"spData\")[1], quiet=TRUE) ft.SID74 <- sqrt(1000)*(sqrt(nc.sids$SID74/nc.sids$BIR74) +  sqrt((nc.sids$SID74+1)/nc.sids$BIR74)) lm_nc <- lm(ft.SID74 ~ 1) sids.nhbr30 <- spdep::dnearneigh(cbind(nc.sids$east, nc.sids$north), 0, 30,  row.names=row.names(nc.sids)) #> Warning: neighbour object has 3 sub-graphs sids.nhbr30.dist <- spdep::nbdists(sids.nhbr30, cbind(nc.sids$east, nc.sids$north)) sids.nhbr <- spdep::listw2sn(spdep::nb2listw(sids.nhbr30,  glist=sids.nhbr30.dist, style=\"B\", zero.policy=TRUE)) dij <- sids.nhbr[,3] n <- nc.sids$BIR74 el1 <- min(dij)/dij el2 <- sqrt(n[sids.nhbr$to]/n[sids.nhbr$from]) sids.nhbr$weights <- el1*el2 sids.nhbr.listw <- spdep::sn2listw(sids.nhbr) #> Warning: style is M (missing); style should be set to a valid value #> Warning: 56, 87 are not origins #> Error in spdep::sn2listw(sids.nhbr): no-neighbour observations found, set zero.policy to TRUE both <- factor(paste(nc.sids$L_id, nc.sids$M_id, sep=\":\")) ft.NWBIR74 <- sqrt(1000)*(sqrt(nc.sids$NWBIR74/nc.sids$BIR74) +  sqrt((nc.sids$NWBIR74+1)/nc.sids$BIR74)) mdata <- data.frame(both, ft.NWBIR74, ft.SID74, BIR74=nc.sids$BIR74) outl <- which.max(rstandard(lm_nc)) as.character(nc.sids$NAME[outl]) #> [1] \"Anson\" mdata.4 <- mdata[-outl,] W <- spdep::listw2mat(sids.nhbr.listw) #> Error: object 'sids.nhbr.listw' not found W.4 <- W[-outl, -outl] #> Error: object 'W' not found sids.nhbr.listw.4 <- spdep::mat2listw(W.4) #> Error: object 'W.4' not found esarI <- errorsarlm(ft.SID74 ~ 1, data=mdata, listw=sids.nhbr.listw,  zero.policy=TRUE) #> Error: object 'sids.nhbr.listw' not found summary(esarI) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'esarI' not found esarIa <- spautolm(ft.SID74 ~ 1, data=mdata, listw=sids.nhbr.listw,  family=\"SAR\") #> Error: object 'sids.nhbr.listw' not found summary(esarIa) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'esarIa' not found esarIV <- errorsarlm(ft.SID74 ~ ft.NWBIR74, data=mdata, listw=sids.nhbr.listw,  zero.policy=TRUE) #> Error: object 'sids.nhbr.listw' not found summary(esarIV) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'esarIV' not found esarIVa <- spautolm(ft.SID74 ~ ft.NWBIR74, data=mdata, listw=sids.nhbr.listw,  family=\"SAR\") #> Error: object 'sids.nhbr.listw' not found summary(esarIVa) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'esarIVa' not found esarIaw <- spautolm(ft.SID74 ~ 1, data=mdata, listw=sids.nhbr.listw,  weights=BIR74, family=\"SAR\") #> Error: object 'sids.nhbr.listw' not found summary(esarIaw) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'esarIaw' not found esarIIaw <- spautolm(ft.SID74 ~ both - 1, data=mdata, listw=sids.nhbr.listw,  weights=BIR74, family=\"SAR\") #> Error: object 'sids.nhbr.listw' not found summary(esarIIaw) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'esarIIaw' not found esarIVaw <- spautolm(ft.SID74 ~ ft.NWBIR74, data=mdata,  listw=sids.nhbr.listw, weights=BIR74, family=\"SAR\") #> Error: object 'sids.nhbr.listw' not found summary(esarIVaw) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'esarIVaw' not found ecarIaw <- spautolm(ft.SID74 ~ 1, data=mdata.4, listw=sids.nhbr.listw.4,  weights=BIR74, family=\"CAR\") #> Error: object 'sids.nhbr.listw.4' not found summary(ecarIaw) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'ecarIaw' not found ecarIIaw <- spautolm(ft.SID74 ~ both - 1, data=mdata.4,  listw=sids.nhbr.listw.4, weights=BIR74, family=\"CAR\") #> Error: object 'sids.nhbr.listw.4' not found summary(ecarIIaw) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'ecarIIaw' not found ecarIVaw <- spautolm(ft.SID74 ~ ft.NWBIR74, data=mdata.4,  listw=sids.nhbr.listw.4, weights=BIR74, family=\"CAR\") #> Error: object 'sids.nhbr.listw.4' not found summary(ecarIVaw) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'ecarIVaw' not found nc.sids$fitIV <- append(fitted.values(ecarIVaw), NA, outl-1) #> Error: object 'ecarIVaw' not found plot(nc.sids[,\"fitIV\"], nbreaks=12) # Cressie 1993, p. 565 #> Error in `[.data.frame`(x, i, j, drop = drop): undefined columns selected # } # \\dontrun{ data(oldcol, package=\"spdep\") COL.errW.eig <- errorsarlm(CRIME ~ INC + HOVAL, data=COL.OLD,  spdep::nb2listw(COL.nb, style=\"W\")) summary(COL.errW.eig) #>  #> Call: #> errorsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"W\")) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -34.81174  -6.44031  -0.72142   7.61476  23.33626  #>  #> Type: error  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 59.893219   5.366163 11.1613 < 2.2e-16 #> INC         -0.941312   0.330569 -2.8476 0.0044057 #> HOVAL       -0.302250   0.090476 -3.3407 0.0008358 #>  #> Lambda: 0.56179, LR test value: 7.9935, p-value: 0.0046945 #> Asymptotic standard error: 0.13387 #>     z-value: 4.1966, p-value: 2.7098e-05 #> Wald statistic: 17.611, p-value: 2.7098e-05 #>  #> Log likelihood: -183.3805 for error model #> ML residual variance (sigma squared): 95.575, (sigma: 9.7762) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 376.76, (AIC for lm: 382.75) #>  COL.errW.sar <- spautolm(CRIME ~ INC + HOVAL, data=COL.OLD,  spdep::nb2listw(COL.nb, style=\"W\")) summary(COL.errW.sar) #>  #> Call:  #> spautolm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = spdep::nb2listw(COL.nb,  #>     style = \"W\")) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -34.81174  -6.44031  -0.72142   7.61476  23.33626  #>  #> Coefficients:  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 59.893219   5.366162 11.1613 < 2.2e-16 #> INC         -0.941312   0.330569 -2.8476 0.0044057 #> HOVAL       -0.302250   0.090476 -3.3407 0.0008358 #>  #> Lambda: 0.56179 LR test value: 7.9935 p-value: 0.0046945  #> Numerical Hessian standard error of lambda: 0.15241  #>  #> Log likelihood: -183.3805  #> ML residual variance (sigma squared): 95.575, (sigma: 9.7762) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 376.76 #>  data(boston, package=\"spData\") gp1 <- spautolm(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2)  + I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),   data=boston.c, spdep::nb2listw(boston.soi), family=\"SMA\") summary(gp1) #>  #> Call: spautolm(formula = log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  #>     I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B +  #>     log(LSTAT), data = boston.c, listw = spdep::nb2listw(boston.soi),  #>     family = \"SMA\") #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -0.5847694 -0.0713881  0.0012284  0.0827517  0.6071219  #>  #> Coefficients:  #>                Estimate  Std. Error  z value  Pr(>|z|) #> (Intercept)  4.28501607  0.15367176  27.8842 < 2.2e-16 #> CRIM        -0.00718807  0.00106298  -6.7622 1.359e-11 #> ZN           0.00023008  0.00051897   0.4433 0.6575185 #> INDUS        0.00047300  0.00263339   0.1796 0.8574551 #> CHAS1        0.01020698  0.02872047   0.3554 0.7222970 #> I(NOX^2)    -0.44885530  0.13675913  -3.2821 0.0010304 #> I(RM^2)      0.00638094  0.00110330   5.7835 7.316e-09 #> AGE         -0.00043973  0.00051336  -0.8566 0.3916862 #> log(DIS)    -0.15650578  0.03856337  -4.0584 4.941e-05 #> log(RAD)     0.07583760  0.02016468   3.7609 0.0001693 #> TAX         -0.00049364  0.00012162  -4.0588 4.933e-05 #> PTRATIO     -0.02494959  0.00538791  -4.6307 3.645e-06 #> B            0.00048517  0.00010944   4.4334 9.277e-06 #> log(LSTAT)  -0.32961379  0.02353891 -14.0029 < 2.2e-16 #>  #> Lambda: 0.61991 LR test value: 144.28 p-value: < 2.22e-16  #> Numerical Hessian standard error of lambda: 0.044296  #>  #> Log likelihood: 229.1208  #> ML residual variance (sigma squared): 0.02596, (sigma: 0.16112) #> Number of observations: 506  #> Number of parameters estimated: 16  #> AIC: -426.24 #>  # }"},{"path":"https://r-spatial.github.io/spatialreg/reference/stsls.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized spatial two stage least squares — stsls","title":"Generalized spatial two stage least squares — stsls","text":"function fits spatial lag model two stage least squares, option adjusting results heteroskedasticity.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/stsls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized spatial two stage least squares — stsls","text":"","code":"stsls(formula, data = list(), listw, zero.policy = NULL,  na.action = na.fail, robust = FALSE, HC=NULL, legacy=FALSE, W2X = TRUE,  sig2n_k=TRUE, adjust.n=FALSE) # S3 method for class 'Stsls' impacts(obj, ..., tr, R = NULL, listw = NULL, evalues=NULL,  tol = 1e-06, empirical = FALSE, Q=NULL)"},{"path":"https://r-spatial.github.io/spatialreg/reference/stsls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized spatial two stage least squares — stsls","text":"formula symbolic description model fit. details model specification given lm() data optional data frame containing variables model. default variables taken environment function called. listw listw object created example nb2listw zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE (default) assign NA - causing lagsarlm() terminate error na.action function (default na.fail), can also na.omit na.exclude consequences residuals fitted values - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. robust default FALSE, TRUE, apply heteroskedasticity correction coefficients covariances HC default NULL, robust TRUE, assigned “HC0”, may take values “HC0” “HC1” White estimates MacKinnon-White estimates respectively legacy argument chooses two implementations robustness correction: default FALSE - use estimate Omega White consistent estimator variance-covariance matrix, TRUE, use original implementation runs GLS using estimate Omega, overrides sig2n_k, yields different coefficient estimates well - see example W2X default TRUE, FALSE WX used instruments spatial two stage least squares; release 0.4-60, WX used - see example ; Python spreg::GM_Lag default FALSE sig2n_k default TRUE - use n-k calculate sigma^2, FALSE use n; Python spreg::GM_Lag default FALSE adjust.n default FALSE, used creating spatial weights constants Anselin-Kelejian (1997) test obj spatial regression object created lagsarlm, lagmess lmSLX; HPDinterval.LagImpact, LagImpact object ... Arguments passed methods coda package tr vector traces powers spatial weights matrix created using trW, approximate impact measures; given, listw must given exact measures (small moderate spatial weights matrices); traces must spatial weights used fitting spatial regression, must row-standardised evalues vector eigenvalues spatial weights matrix impacts calculations R given, simulations used compute distributions impact measures, returned mcmc objects; objects used convenience output MCMC process tol Argument passed mvrnorm: tolerance (relative largest variance) numerical lack positive-definiteness coefficient covariance matrix empirical Argument passed mvrnorm (default FALSE): true, coefficients covariance matrix specify empirical population mean covariance matrix Q default NULL, else integer number cumulative power series impacts calculate tr given","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/stsls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized spatial two stage least squares — stsls","text":"fitting implementation fits spatial lag model: $$y = \\rho W y + X \\beta + \\varepsilon$$ using spatially lagged X variables instruments spatially lagged dependent variable. version 1.3-6, general Anselin-Kelejian (1997) test residual spatial autocorrelation added.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/stsls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized spatial two stage least squares — stsls","text":"object class \"Stsls\" containing: coefficients coefficient estimates var coefficient covariance matrix sse sum squared errors residuals model residuals df degrees freedom","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/stsls.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized spatial two stage least squares — stsls","text":"Kelejian, H.H. .R. Prucha (1998). generalized spatial two stage least squares procedure estimating spatial autoregressive model autoregressive disturbances. Journal Real Estate Finance Economics 17, 99-121. doi:10.1023/:1007707430416 . Anselin, L., & Kelejian, H. H. (1997). Testing Spatial Error Autocorrelation Presence Endogenous Regressors. International Regional Science Review, 20(1-2), 153-182. doi:10.1177/016001769702000109 . Roger Bivand, Gianfranco Piras (2015). Comparing Implementations Estimation Methods Spatial Econometrics. Journal Statistical Software, 63(18), 1-36. doi:10.18637/jss.v063.i18 .","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/stsls.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generalized spatial two stage least squares — stsls","text":"Luc Anselin, Gianfranco Piras Roger Bivand","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/stsls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized spatial two stage least squares — stsls","text":"","code":"data(oldcol, package=\"spdep\") #require(spdep, quietly=TRUE) lw <- spdep::nb2listw(COL.nb) COL.lag.eig <- lagsarlm(CRIME ~ INC + HOVAL, data=COL.OLD, lw) summary(COL.lag.eig, correlation=TRUE) #>  #> Call:lagsarlm(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = lw) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.68585  -5.35636   0.05421   6.02013  23.20555  #>  #> Type: lag  #> Coefficients: (asymptotic standard errors)  #>              Estimate Std. Error z value  Pr(>|z|) #> (Intercept) 45.079250   7.177347  6.2808 3.369e-10 #> INC         -1.031616   0.305143 -3.3808 0.0007229 #> HOVAL       -0.265926   0.088499 -3.0049 0.0026570 #>  #> Rho: 0.43102, LR test value: 9.9736, p-value: 0.001588 #> Asymptotic standard error: 0.11768 #>     z-value: 3.6626, p-value: 0.00024962 #> Wald statistic: 13.415, p-value: 0.00024962 #>  #> Log likelihood: -182.3904 for lag model #> ML residual variance (sigma squared): 95.494, (sigma: 9.7721) #> Number of observations: 49  #> Number of parameters estimated: 5  #> AIC: 374.78, (AIC for lm: 382.75) #> LM test for residual autocorrelation #> test value: 0.31954, p-value: 0.57188 #>  #>  Correlation of coefficients  #>             sigma rho   (Intercept) INC   #> rho         -0.14                         #> (Intercept)  0.12 -0.83                   #> INC         -0.05  0.35 -0.61             #> HOVAL       -0.01  0.08 -0.25       -0.44 #>  COL.lag.stsls <- stsls(CRIME ~ INC + HOVAL, data=COL.OLD, lw) (x <- summary(COL.lag.stsls, correlation=TRUE)) #>  #> Call:stsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = lw) #>  #> Residuals: #>       Min        1Q    Median        3Q       Max  #> -37.86437  -5.65096  -0.13669   6.23315  22.90823  #>  #> Coefficients:  #>              Estimate Std. Error t value  Pr(>|t|) #> Rho          0.454567   0.185118  2.4555  0.014067 #> (Intercept) 43.793442  10.952229  3.9986 6.372e-05 #> INC         -1.000716   0.383858 -2.6070  0.009134 #> HOVAL       -0.265489   0.091852 -2.8904  0.003847 #>  #> Residual variance (sigma squared): 103.44, (sigma: 10.171) #> Anselin-Kelejian (1997) test for residual autocorrelation #> test value: 0.043401, p-value: 0.83497 #>  #> Correlation of Coefficients: #>             Rho   (Intercept) INC   #> (Intercept) -0.92                   #> INC          0.63 -0.76             #> HOVAL        0.04 -0.16       -0.36 #>  coef(x) #>               Estimate  Std. Error   t value     Pr(>|t|) #> Rho          0.4545669  0.18511845  2.455546 1.406706e-02 #> (Intercept) 43.7934425 10.95222944  3.998587 6.372175e-05 #> INC         -1.0007158  0.38385778 -2.606996 9.134037e-03 #> HOVAL       -0.2654890  0.09185167 -2.890410 3.847398e-03 W <- as(lw, \"CsparseMatrix\") trMatc <- trW(W, type=\"mult\") loobj1 <- impacts(COL.lag.stsls, R=200, tr=trMatc) summary(loobj1, zstats=TRUE, short=TRUE) #> Impact measures (lag, trace): #>           Direct   Indirect     Total #> INC   -1.0607411 -0.7739768 -1.834718 #> HOVAL -0.2814136 -0.2053354 -0.486749 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>           Direct  Indirect     Total #> INC   0.39668006 0.9695180 1.0529050 #> HOVAL 0.09757127 0.3123932 0.3649017 #>  #> Simulated z-values: #>          Direct   Indirect     Total #> INC   -2.768354 -0.8583926 -1.833383 #> HOVAL -2.954457 -0.8425926 -1.511339 #>  #> Simulated p-values: #>       Direct    Indirect Total    #> INC   0.0056340 0.39068  0.066746 #> HOVAL 0.0031322 0.39946  0.130702 ev <- eigenw(lw) loobj2 <- impacts(COL.lag.stsls, R=200, evalues=ev) summary(loobj2, zstats=TRUE, short=TRUE) #> Impact measures (lag, evalues): #>           Direct   Indirect     Total #> INC   -1.0607411 -0.7739768 -1.834718 #> HOVAL -0.2814136 -0.2053354 -0.486749 #> ======================================================== #> Simulation results ( variance matrix): #> ======================================================== #> Simulated standard errors #>          Direct  Indirect     Total #> INC   0.3841092 0.7160775 0.8241613 #> HOVAL 0.1008357 0.4126274 0.4698167 #>  #> Simulated z-values: #>          Direct   Indirect     Total #> INC   -2.895776 -1.1602746 -2.357719 #> HOVAL -2.743940 -0.6064747 -1.121576 #>  #> Simulated p-values: #>       Direct    Indirect Total    #> INC   0.0037822 0.24594  0.018388 #> HOVAL 0.0060707 0.54420  0.262043 require(coda) HPDinterval(loobj1) #>            lower       upper #> INC   -1.7799556 -0.35225230 #> HOVAL -0.4587508 -0.09515137 #> attr(,\"Probability\") #> [1] 0.95 COL.lag.stslsW <- stsls(CRIME ~ INC + HOVAL, data=COL.OLD, lw, W2X=FALSE) summary(COL.lag.stslsW, correlation=TRUE) #>  #> Call:stsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = lw,  #>     W2X = FALSE) #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -37.785778  -5.442414  -0.052649   6.170104  23.039123  #>  #> Coefficients:  #>              Estimate Std. Error t value  Pr(>|t|) #> Rho          0.444202   0.189141  2.3485  0.018848 #> (Intercept) 44.359512  11.157079  3.9759 7.011e-05 #> INC         -1.014319   0.387469 -2.6178  0.008850 #> HOVAL       -0.265681   0.091954 -2.8893  0.003861 #>  #> Residual variance (sigma squared): 103.67, (sigma: 10.182) #> Anselin-Kelejian (1997) test for residual autocorrelation #> test value: 0.058156, p-value: 0.80943 #>  #> Correlation of Coefficients: #>             Rho   (Intercept) INC   #> (Intercept) -0.93                   #> INC          0.64 -0.77             #> HOVAL        0.04 -0.16       -0.36 #>  COL.lag.stslsWn <- stsls(CRIME ~ INC + HOVAL, data=COL.OLD, lw, W2X=FALSE, sig2n_k=FALSE) summary(COL.lag.stslsWn, correlation=TRUE) #>  #> Call:stsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = lw,  #>     W2X = FALSE, sig2n_k = FALSE) #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -37.785778  -5.442414  -0.052649   6.170104  23.039123  #>  #> Coefficients:  #>              Estimate Std. Error t value  Pr(>|t|) #> Rho          0.444202   0.181257  2.4507  0.014259 #> (Intercept) 44.359512  10.691995  4.1489 3.341e-05 #> INC         -1.014319   0.371318 -2.7317  0.006301 #> HOVAL       -0.265681   0.088121 -3.0150  0.002570 #>  #> Residual variance (sigma squared): 95.203, (sigma: 9.7572) #> Anselin-Kelejian (1997) test for residual autocorrelation #> test value: 0.058156, p-value: 0.80943 #>  #> Correlation of Coefficients: #>             Rho   (Intercept) INC   #> (Intercept) -0.93                   #> INC          0.64 -0.77             #> HOVAL        0.04 -0.16       -0.36 #>  COL.lag.stslsR <- stsls(CRIME ~ INC + HOVAL, data=COL.OLD, lw, robust=TRUE, W2X=FALSE) summary(COL.lag.stslsR, correlation=TRUE) #>  #> Call:stsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = lw,  #>     robust = TRUE, W2X = FALSE) #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -37.785778  -5.442414  -0.052649   6.170104  23.039123  #>  #> Coefficients:  #>             Estimate HC0 std. Error z value  Pr(>|z|) #> Rho          0.44420        0.13748  3.2310  0.001234 #> (Intercept) 44.35951        7.67306  5.7812 7.417e-09 #> INC         -1.01432        0.44113 -2.2993  0.021486 #> HOVAL       -0.26568        0.17353 -1.5311  0.125752 #>  #> Residual variance (sigma squared): 103.67, (sigma: 10.182) #> Anselin-Kelejian (1997) test for residual autocorrelation #> test value: 0.056852, p-value: 0.81154 #>  #> Correlation of Coefficients: #>             Rho   (Intercept) INC   #> (Intercept) -0.90                   #> INC          0.15 -0.28             #> HOVAL        0.24 -0.24       -0.83 #>  COL.lag.stslsRl <- stsls(CRIME ~ INC + HOVAL, data=COL.OLD, lw, robust=TRUE, legacy=TRUE, W2X=FALSE) summary(COL.lag.stslsRl, correlation=TRUE) #>  #> Call:stsls(formula = CRIME ~ INC + HOVAL, data = COL.OLD, listw = lw,  #>     robust = TRUE, legacy = TRUE, W2X = FALSE) #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -38.654607  -5.141303  -0.065221   5.864384  23.671589  #>  #> Coefficients:  #>             Estimate HC0 std. Error z value  Pr(>|z|) #> Rho          0.40138        0.13554  2.9613  0.003064 #> (Intercept) 47.37696        7.49975  6.3171 2.664e-10 #> INC         -1.15183        0.43490 -2.6485  0.008085 #> HOVAL       -0.25047        0.17333 -1.4450  0.148461 #>  #> Asymptotic robust residual variance: 96.446, (sigma: 9.8207) #> Anselin-Kelejian (1997) test for residual autocorrelation #> test value: 0.10254, p-value: 0.7488 #>  #> Correlation of Coefficients: #>             Rho   (Intercept) INC   #> (Intercept) -0.89                   #> INC          0.12 -0.26             #> HOVAL        0.25 -0.26       -0.83 #>  data(boston, package=\"spData\") gp2a <- stsls(log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) + I(RM^2) +   AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B + log(LSTAT),  data=boston.c, spdep::nb2listw(boston.soi)) summary(gp2a) #>  #> Call:stsls(formula = log(CMEDV) ~ CRIM + ZN + INDUS + CHAS + I(NOX^2) +  #>     I(RM^2) + AGE + log(DIS) + log(RAD) + TAX + PTRATIO + B +  #>     log(LSTAT), data = boston.c, listw = spdep::nb2listw(boston.soi)) #>  #> Residuals: #>        Min         1Q     Median         3Q        Max  #> -0.5356002 -0.0758562 -0.0045074  0.0719613  0.7128012  #>  #> Coefficients:  #>                Estimate  Std. Error  t value  Pr(>|t|) #> Rho          4.5925e-01  3.8485e-02  11.9330 < 2.2e-16 #> (Intercept)  2.4025e+00  2.1710e-01  11.0661 < 2.2e-16 #> CRIM        -7.3557e-03  1.0345e-03  -7.1100 1.160e-12 #> ZN           3.6435e-04  3.9311e-04   0.9268 0.3540112 #> INDUS        1.1992e-03  1.8365e-03   0.6530 0.5137794 #> CHAS1        1.1929e-02  2.6632e-02   0.4479 0.6542202 #> I(NOX^2)    -2.8874e-01  9.2546e-02  -3.1199 0.0018091 #> I(RM^2)      6.6991e-03  1.0192e-03   6.5728 4.938e-11 #> AGE         -2.5810e-04  4.0940e-04  -0.6304 0.5284073 #> log(DIS)    -1.6043e-01  2.6107e-02  -6.1451 7.993e-10 #> log(RAD)     7.1704e-02  1.4926e-02   4.8038 1.557e-06 #> TAX         -3.6857e-04  9.5315e-05  -3.8668 0.0001103 #> PTRATIO     -1.2957e-02  4.1334e-03  -3.1347 0.0017203 #> B            2.8845e-04  8.0266e-05   3.5937 0.0003261 #> log(LSTAT)  -2.3984e-01  2.2470e-02 -10.6740 < 2.2e-16 #>  #> Residual variance (sigma squared): 0.020054, (sigma: 0.14161) #> Anselin-Kelejian (1997) test for residual autocorrelation #> test value: 4.3942, p-value: 0.036062 #>"},{"path":"https://r-spatial.github.io/spatialreg/reference/trW.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial weights matrix powers traces — trW","title":"Spatial weights matrix powers traces — trW","text":"function used prepare vector traces powers spatial weights matrix","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/trW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial weights matrix powers traces — trW","text":"","code":"trW(W=NULL, m = 30, p = 16, type = \"mult\", listw=NULL, momentsSymmetry=TRUE) mom_calc(lw, m) mom_calc_int2(is, m, nb, weights, Card)"},{"path":"https://r-spatial.github.io/spatialreg/reference/trW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial weights matrix powers traces — trW","text":"W spatial weights matrix CsparseMatrix form m number powers; must even number ‘type’=“moments” (default changed 100 30 (2010-11-17)) p number samples used Monte Carlo simulation traces type MC (default changed 50 16 (2010-11-17)) type Either “mult” (default) powering sparse matrix (moderate larger N, matrix becomes dense, may lead swapping), “MC” Monte Carlo simulation traces (first two simulated traces replaced analytical equivalents), “moments” use looping space saving algorithm proposed Smirnov Anselin (2009) - “moments”, W must symmetric, row-standardised weights similarity transformation listw, lw listw object, either fully symmetric, constructed similar symmetric intrinsically symmetric neighbours using similar.listw, used ‘type’=“moments” momentsSymmetry default TRUE; assert Smirnov/Anselin symmetry assumption (used internally mom_calc_int2 ‘type’=“moments” cluster) nb (used internally mom_calc_int2 ‘type’=“moments” cluster) weights (used internally mom_calc_int2 ‘type’=“moments” cluster) Card (used internally mom_calc_int2 ‘type’=“moments” cluster)","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/trW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial weights matrix powers traces — trW","text":"numeric vector m traces, “timings” “type” attributes; ‘type’=“MC” also returns standard deviation p-vector V divided square root p measure spread trace estimates.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/trW.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Spatial weights matrix powers traces — trW","text":"mom_calc mom_calc_int2 internal use ","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/trW.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial weights matrix powers traces — trW","text":"LeSage J RK Pace (2009) Introduction Spatial Econometrics. CRC Press, Boca Raton, pp. 96–105; Smirnov O L Anselin (2009) O(N) parallel method computing Log-Jacobian variable transformation models spatial interaction lattice. Computational Statistics Data Analysis 53 (2009) 2983–2984.","code":""},{"path":"https://r-spatial.github.io/spatialreg/reference/trW.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial weights matrix powers traces — trW","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spatialreg/reference/trW.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial weights matrix powers traces — trW","text":"","code":"require(\"sf\", quietly=TRUE)  columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) #require(spdep, quietly=TRUE) col.gal.nb <- spdep::read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) listw <- spdep::nb2listw(col.gal.nb) W <- as(listw, \"CsparseMatrix\") system.time(trMat <- trW(W, type=\"mult\")) #>    user  system elapsed  #>   0.002   0.000   0.002  str(trMat) #>  num [1:30] 0 10.91 3.65 5.62 3.66 ... #>  - attr(*, \"timings\")= Named num [1:2] 0.002 0.002 #>   ..- attr(*, \"names\")= chr [1:2] \"user.self\" \"elapsed\" #>  - attr(*, \"type\")= chr \"mult\" #>  - attr(*, \"n\")= int 49 set.seed(1100) system.time(trMC <- trW(W, type=\"MC\")) #>    user  system elapsed  #>   0.005   0.000   0.005  str(trMC) #>  num [1:30] 0 10.91 3.69 5.36 3.64 ... #>  - attr(*, \"sd\")= num [1:30] NA NA 0.598 0.495 0.489 ... #>  - attr(*, \"timings\")= Named num [1:2] 0.005 0.005 #>   ..- attr(*, \"names\")= chr [1:2] \"user.self\" \"elapsed\" #>  - attr(*, \"type\")= chr \"MC\" #>  - attr(*, \"n\")= int 49 plot(trMat, trMC) abline(a=0, b=1) for(i in 3:length(trMC)) {  segments(trMat[i], trMC[i]-2*attr(trMC, \"sd\")[i], trMat[i],   trMC[i]+2*attr(trMC, \"sd\")[i]) }  listwS <- similar.listw(listw) W <- forceSymmetric(as(listwS, \"CsparseMatrix\")) system.time(trmom <- trW(listw=listwS, m=24, type=\"moments\")) #>    user  system elapsed  #>   0.002   0.000   0.002  str(trmom) #>  num [1:24] 0 10.91 3.65 5.62 3.66 ... #>  - attr(*, \"timings\")= Named num [1:2] 0.002 0.002 #>   ..- attr(*, \"names\")= chr [1:2] \"user.self\" \"elapsed\" #>  - attr(*, \"type\")= chr \"moments\" #>  - attr(*, \"n\")= int 49 all.equal(trMat[1:24], trmom, check.attributes=FALSE) #> [1] TRUE system.time(trMat <- trW(W, m=24, type=\"mult\")) #>    user  system elapsed  #>   0.003   0.000   0.003  str(trMat) #>  num [1:24] 0 10.91 3.65 5.62 3.66 ... #>  - attr(*, \"timings\")= Named num [1:2] 0.003 0.003 #>   ..- attr(*, \"names\")= chr [1:2] \"user.self\" \"elapsed\" #>  - attr(*, \"type\")= chr \"mult\" #>  - attr(*, \"n\")= int 49 all.equal(trMat, trmom, check.attributes=FALSE) #> [1] TRUE set.seed(1) system.time(trMC <- trW(W, m=24, type=\"MC\")) #>    user  system elapsed  #>   0.006   0.000   0.006  str(trMC) #>  num [1:24] 0 10.91 2.44 4.97 2.82 ... #>  - attr(*, \"sd\")= num [1:24] NA NA 0.618 0.501 0.451 ... #>  - attr(*, \"timings\")= Named num [1:2] 0.006 0.006 #>   ..- attr(*, \"names\")= chr [1:2] \"user.self\" \"elapsed\" #>  - attr(*, \"type\")= chr \"MC\" #>  - attr(*, \"n\")= int 49 # \\dontrun{ data(boston, package=\"spData\") listw <- spdep::nb2listw(boston.soi) listwS <- similar.listw(listw) system.time(trmom <- trW(listw=listwS, m=24, type=\"moments\")) #>    user  system elapsed  #>   0.116   0.000   0.117  str(trmom) #>  num [1:24] 0 124.2 32.7 63.7 33.2 ... #>  - attr(*, \"timings\")= Named num [1:2] 0.116 0.117 #>   ..- attr(*, \"names\")= chr [1:2] \"user.self\" \"elapsed\" #>  - attr(*, \"type\")= chr \"moments\" #>  - attr(*, \"n\")= int 506 library(parallel) nc <- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L # set nc to 1L here if (nc > 1L) nc <- 1L coresOpt <- get.coresOption() invisible(set.coresOption(nc)) if(!get.mcOption()) {   cl <- makeCluster(get.coresOption())   set.ClusterOption(cl) } system.time(trmomp <- trW(listw=listwS, m=24, type=\"moments\")) #>    user  system elapsed  #>   0.119   0.000   0.119  if(!get.mcOption()) {   set.ClusterOption(NULL)   stopCluster(cl) } all.equal(trmom, trmomp, check.attributes=FALSE) #> [1] TRUE invisible(set.coresOption(coresOpt)) # }"},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-13-6-development","dir":"Changelog","previous_headings":"","what":"Version 1.3-6 (development)","title":"Version 1.3-6 (development)","text":"#56 add Anselin-Kelejian (1997) test stsls, reported summary method, analogous reporting summary method lagsarlm Lagrange multiplier test, residual spatial autocorrelation adding missing man page anchors","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-13-5-2024-08-19","dir":"Changelog","previous_headings":"","what":"Version 1.3-5 (2024-08-19)","title":"Version 1.3-5 (2024-08-19)","text":"CRAN release: 2024-08-19 conforming STRICT_R_HEADERS=1 Condition forthcoming tmap 4 #52 subgraph updates","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-13-4-2024-06-10","dir":"Changelog","previous_headings":"","what":"Version 1.3-4 (2024-06-10)","title":"Version 1.3-4 (2024-06-10)","text":"CRAN release: 2024-06-10 migrate ESRI Shapefile GeoPackage #50","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-13-3-2024-05-31","dir":"Changelog","previous_headings":"","what":"Version 1.3-3 (2024-05-31)","title":"Version 1.3-3 (2024-05-31)","text":"CRAN release: 2024-05-31 protect errorsarlm missing Durbin= intercept fix longstanding bugs getVmate non-default side logic branch add return_impacts= lmSLX work around issues aliased variables; impacts improved handle case time permits add sqrt=TRUE calls Matrix determinant methods matrix_ldet add igraph (>= 2.0.0) DESCRIPTION re-named igraph functions","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-13-2-2024-02-06","dir":"Changelog","previous_headings":"","what":"Version 1.3-2 (2024-02-06)","title":"Version 1.3-2 (2024-02-06)","text":"CRAN release: 2024-02-06 pass SlX formula call re-corrected #19 fitted model weights component may NULL suppress warning multcomp::glht test throws warning discarded","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-13-1-2023-11-23","dir":"Changelog","previous_headings":"","what":"Version 1.3-1 (2023-11-23)","title":"Version 1.3-1 (2023-11-23)","text":"CRAN release: 2023-11-23 move expm Imports Suggests #42 added zero.policy pass-spdep::mat2listw calls predict.Sarlm spdep::sn2listw sids_models.Rmd; set spdep requirement 1.3-1 corrected #19 fitted model weights component never NULL, may single unique value","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-12-9-2023-05-25","dir":"Changelog","previous_headings":"","what":"Version 1.2-9 (2023-05-25)","title":"Version 1.2-9 (2023-05-25)","text":"CRAN release: 2023-05-25 raised #39, support weights SEM/SDEM/SLX #39 address #37; #38 remains (formula Durbin support prediction using Sarlm object) address #19 reporting AIC case weights used spautolm errorsarlm address bug predict() new data, SDEM. Others #37, #38 need work. added checking SLX/SDEM impacts edge/corner cases; starting transition use multcomp place og gmodels","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-12-8-2023-03-01","dir":"Changelog","previous_headings":"","what":"Version 1.2-8 (2023-03-01)","title":"Version 1.2-8 (2023-03-01)","text":"CRAN release: 2023-03-01 Attending SLX/Durbin/non-W-style weights: #7, #36, #26, #35, #30 #24, #23, partly based #13","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-12-6-2022-10-07","dir":"Changelog","previous_headings":"","what":"Version 1.2-6 (2022-10-07)","title":"Version 1.2-6 (2022-10-07)","text":"CRAN release: 2022-10-07 make local copy gmodels::estimable() lm objects , add authors package contributors -Wstrict-prototypes fixes","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-12-5-2022-08-16","dir":"Changelog","previous_headings":"","what":"Version 1.2-5 (2022-08-16)","title":"Version 1.2-5 (2022-08-16)","text":"CRAN release: 2022-08-16 updating coercion Matrix 1.4-2 updating dontrun/donttest package split (previously unchecked, mostly aple)","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-12-3-2022-04-18","dir":"Changelog","previous_headings":"","what":"Version 1.2-3 (2022-04-18)","title":"Version 1.2-3 (2022-04-18)","text":"CRAN release: 2022-04-18 protect definition USE_FC_LEN_T unescape underscores help pages","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-12-1-2021-11-11","dir":"Changelog","previous_headings":"","what":"Version 1.2-1 (2021-11-11)","title":"Version 1.2-1 (2021-11-11)","text":"CRAN release: 2021-11-11 Add Fortran character handling USE_FC_LEN_T WRE §6.6.1 Add spdep split-functionality","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-11-8-2021-05-03","dir":"Changelog","previous_headings":"","what":"Version 1.1-8 (2021-05-03)","title":"Version 1.1-8 (2021-05-03)","text":"CRAN release: 2021-05-03 #18 standardize use coef() methods () fitted model summary objects https://github.com/tidymodels/broom/issues/1003#issuecomment-798694400 changing spatialreg model output class names: spdep sarlm -> spatialreg Sarlm, spautolm -> Spautolm, stsls -> Stsls, gmsar -> Gmsar, lagmess -> Lagmess, SLX -> , SlX, MCMC_s*_g -> MCMC_s*_G, SFResult -> SfResult, ME_res -> Me_res, lagImpact -> LagImpact, WXImpact -> WXimpact #16 merged coordination impacts methods (Gianfranco Piras) #14 merged correction SDEM SLX impacts lagged intercept present (Tobias Rüttenauer).","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-11-5-2019-12-01","dir":"Changelog","previous_headings":"","what":"Version 1.1-5 (2019-12-01)","title":"Version 1.1-5 (2019-12-01)","text":"CRAN release: 2019-12-01 #6, #11 na.action precomputed eigenvalue bug #9 Griddy Gibbs issue #8 Predict method SLX #7, #13-14 Offset impacts SDEM/SLX #5, #10 Panel Durbin= argument","code":""},{"path":"https://r-spatial.github.io/spatialreg/news/index.html","id":"version-11-3-2019-04-01","dir":"Changelog","previous_headings":"","what":"Version 1.1-3 (2019-04-01)","title":"Version 1.1-3 (2019-04-01)","text":"CRAN release: 2019-04-01 #2 Split spatialreg spdep; spdep functions still present deprecated","code":""}]
